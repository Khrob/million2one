<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MILLION2ONE - Enemy Designer</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #0a0a12; font-family: 'Share Tech Mono', 'Courier New', monospace; color: #ccc; display: flex; height: 100vh; }

/* === VIEWPORT === */
#viewport { flex: 1; position: relative; background: #0d0d18; }
#viewport canvas { display: block; width: 100% !important; height: 100% !important; }
#vp-info { position: absolute; bottom: 12px; left: 12px; color: #555; font-size: 11px; pointer-events: none; }
#vp-title { position: absolute; top: 12px; left: 16px; color: #8af; font-size: 13px; letter-spacing: 2px; pointer-events: none; text-transform: uppercase; }

/* === PANEL === */
#panel {
    width: 380px; min-width: 380px; background: rgba(10,10,18,0.98);
    border-left: 1px solid rgba(136,170,255,0.1); display: flex; flex-direction: column;
    overflow: hidden;
}
.panel-header {
    padding: 12px 16px; font-size: 14px; font-weight: bold; color: #fff;
    border-bottom: 1px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.02);
    display: flex; justify-content: space-between; align-items: center; letter-spacing: 2px;
    flex-shrink: 0;
}
.panel-header span { color: #555; font-size: 11px; font-weight: normal; }

/* Tabs */
.tab-bar {
    display: flex; border-bottom: 1px solid rgba(255,255,255,0.06);
    background: rgba(0,0,0,0.2); flex-shrink: 0;
}
.tab-btn {
    flex: 1; padding: 9px 4px; background: none; border: none; border-bottom: 2px solid transparent;
    color: #666; font-family: inherit; font-size: 10px; cursor: pointer; letter-spacing: 1px;
    text-transform: uppercase; transition: all 0.15s; text-align: center;
}
.tab-btn:hover { color: #aaa; background: rgba(255,255,255,0.02); }
.tab-btn.active { color: #8af; border-bottom-color: #8af; background: rgba(136,170,255,0.04); }
.tab-content { display: none; flex: 1; overflow-y: auto; padding: 0; }
.tab-content.active { display: block; }
.tab-content::-webkit-scrollbar { width: 5px; }
.tab-content::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.12); border-radius: 3px; }

/* Sections */
.section { border-bottom: 1px solid rgba(255,255,255,0.04); }
.section-title {
    padding: 10px 16px; font-size: 11px; font-weight: bold; color: #8af;
    text-transform: uppercase; letter-spacing: 1px; background: rgba(255,255,255,0.015);
    cursor: pointer; display: flex; justify-content: space-between; align-items: center;
}
.section-title:hover { background: rgba(255,255,255,0.03); }
.section-body { padding: 6px 16px 12px; }

/* Controls */
.ctrl-row { display: flex; align-items: center; gap: 8px; margin: 5px 0; }
.ctrl-row label { flex: 0 0 85px; color: #888; font-size: 11px; white-space: nowrap; overflow: hidden; }
.ctrl-row input[type="range"] {
    flex: 1; height: 4px; -webkit-appearance: none; background: rgba(255,255,255,0.12);
    border-radius: 2px; outline: none;
}
.ctrl-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%;
    background: #8af; cursor: pointer;
}
.ctrl-row .val { flex: 0 0 48px; text-align: right; color: #8af; font-size: 11px; }
.ctrl-row select {
    flex: 1; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1);
    color: #ccc; padding: 4px 6px; border-radius: 3px; font-family: inherit; font-size: 11px;
    outline: none;
}
.ctrl-row select:focus { border-color: rgba(136,170,255,0.3); }
.ctrl-row input[type="color"] {
    width: 28px; height: 22px; border: 1px solid rgba(255,255,255,0.1);
    border-radius: 3px; cursor: pointer; background: none; padding: 1px;
}

/* Buttons */
.btn {
    padding: 6px 12px; margin: 3px 2px; background: rgba(136,170,255,0.1);
    color: #8af; border: 1px solid rgba(136,170,255,0.2); border-radius: 4px;
    cursor: pointer; font-family: inherit; font-size: 11px; letter-spacing: 0.5px; transition: all 0.15s;
}
.btn:hover { background: rgba(136,170,255,0.2); border-color: rgba(136,170,255,0.4); color: #fff; }
.btn-danger { background: rgba(255,68,68,0.1); color: #f66; border-color: rgba(255,68,68,0.2); }
.btn-danger:hover { background: rgba(255,68,68,0.2); border-color: rgba(255,68,68,0.4); color: #fff; }
.btn-sm { padding: 3px 8px; font-size: 10px; }
.btn-row { padding: 8px 16px; display: flex; flex-wrap: wrap; gap: 4px; }

/* Part list */
.part-item {
    padding: 6px 12px; margin: 2px 0; background: rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.04); border-radius: 3px; cursor: pointer;
    display: flex; align-items: center; gap: 8px; font-size: 11px; transition: all 0.1s;
}
.part-item:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.08); }
.part-item.selected { background: rgba(136,170,255,0.08); border-color: rgba(136,170,255,0.25); color: #fff; }
.part-item .part-color { width: 12px; height: 12px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.1); flex-shrink: 0; }
.part-item .part-name { flex: 1; }
.part-item .part-shape { color: #666; font-size: 10px; }
.part-item .part-group { color: #555; font-size: 9px; background: rgba(255,255,255,0.05); padding: 1px 5px; border-radius: 2px; }

/* Code export */
#code-output {
    background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.06);
    border-radius: 4px; padding: 12px; margin: 8px 16px; font-size: 10px;
    color: #aaa; white-space: pre-wrap; word-break: break-all; max-height: 500px;
    overflow-y: auto; line-height: 1.6; tab-size: 2;
}
#code-output::-webkit-scrollbar { width: 5px; }
#code-output::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }

/* Preset bar */
#preset-bar {
    padding: 8px 16px; display: flex; gap: 4px; flex-wrap: wrap;
    border-bottom: 1px solid rgba(255,255,255,0.04);
}
.preset-btn {
    padding: 4px 10px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06);
    border-radius: 3px; color: #888; font-family: inherit; font-size: 10px; cursor: pointer;
    letter-spacing: 0.5px; transition: all 0.15s;
}
.preset-btn:hover { background: rgba(136,170,255,0.1); color: #8af; border-color: rgba(136,170,255,0.2); }
.preset-btn.active { background: rgba(136,170,255,0.12); color: #8af; border-color: rgba(136,170,255,0.3); }

/* Preview mode toggle */
.preview-toggle { display: flex; gap: 3px; margin: 8px 0; }
.preview-toggle .btn { flex: 1; text-align: center; }
.preview-toggle .btn.active { background: rgba(136,170,255,0.2); color: #fff; border-color: rgba(136,170,255,0.4); }

/* Trait color preview */
.color-preview {
    width: 100%; height: 24px; border-radius: 3px; margin: 8px 0 4px;
    border: 1px solid rgba(255,255,255,0.06);
}
.trait-formula { color: #555; font-size: 10px; margin: 2px 0 8px; line-height: 1.5; }

/* Save indicator */
.preset-btn.modified { border-color: rgba(255,170,68,0.4); color: #fa4; }
.preset-btn .save-dot { display: none; color: #fa4; font-size: 8px; margin-left: 2px; vertical-align: super; }
.preset-btn.modified .save-dot { display: inline; }
#btn-save-preset { background: rgba(255,170,68,0.12); color: #fa4; border-color: rgba(255,170,68,0.3); }
#btn-save-preset:hover { background: rgba(255,170,68,0.25); color: #fff; }
.export-all-section { padding: 12px 16px; border-bottom: 1px solid rgba(255,255,255,0.04); }
.export-all-btn {
    width: 100%; padding: 10px; background: rgba(68,255,68,0.08); color: #4e4;
    border: 1px solid rgba(68,255,68,0.2); border-radius: 4px; cursor: pointer;
    font-family: inherit; font-size: 12px; letter-spacing: 1px; transition: all 0.15s;
}
.export-all-btn:hover { background: rgba(68,255,68,0.18); color: #fff; border-color: rgba(68,255,68,0.4); }
.saved-list { margin-top: 8px; }
.saved-item {
    display: flex; align-items: center; justify-content: space-between;
    padding: 5px 10px; margin: 2px 0; background: rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.04); border-radius: 3px; font-size: 11px;
}
.saved-item .saved-name { color: #aaa; }
.saved-item .saved-parts { color: #555; font-size: 10px; }
.export-note { color: #555; font-size: 10px; line-height: 1.6; margin-top: 8px; }
</style>
</head>
<body>

<div id="viewport">
    <div id="vp-title">ENEMY DESIGNER</div>
    <div id="vp-info">Orbit: LMB | Zoom: Scroll | Pan: RMB</div>
</div>

<div id="panel">
    <div class="panel-header">
        MILLION2ONE <span>CREATURE LAB</span>
    </div>

    <div id="preset-bar">
        <button class="preset-btn active" data-preset="grunt">GRUNT</button>
        <button class="preset-btn" data-preset="brute">BRUTE</button>
        <button class="preset-btn" data-preset="runner">RUNNER</button>
        <button class="preset-btn" data-preset="crawler">CRAWLER</button>
        <button class="preset-btn" data-preset="flyer">FLYER</button>
        <button class="btn" id="btn-save-preset" title="Save current design to active preset">SAVE</button>
    </div>

    <div class="tab-bar">
        <button class="tab-btn active" data-tab="design">DESIGN</button>
        <button class="tab-btn" data-tab="traits">TRAITS</button>
        <button class="tab-btn" data-tab="anim">ANIM</button>
        <button class="tab-btn" data-tab="preview">PREVIEW</button>
        <button class="tab-btn" data-tab="export">EXPORT</button>
    </div>

    <!-- DESIGN TAB -->
    <div class="tab-content active" id="tab-design">
        <div class="btn-row">
            <button class="btn" id="btn-add-part">+ ADD PART</button>
            <button class="btn btn-danger" id="btn-del-part">DELETE</button>
            <button class="btn" id="btn-dup-part">DUPLICATE</button>
            <button class="btn" id="btn-mirror-part">MIRROR X</button>
        </div>
        <div class="section">
            <div class="section-title">PARTS <span id="part-count">0</span></div>
            <div class="section-body" id="part-list"></div>
        </div>
        <div class="section" id="part-editor" style="display:none">
            <div class="section-title">EDIT PART <span id="edit-part-name"></span></div>
            <div class="section-body">
                <div class="ctrl-row">
                    <label>Name</label>
                    <input type="text" id="pe-name" style="flex:1;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);color:#ccc;padding:3px 6px;border-radius:3px;font-family:inherit;font-size:11px;outline:none">
                </div>
                <div class="ctrl-row">
                    <label>Shape</label>
                    <select id="pe-shape">
                        <option value="box">Box</option>
                        <option value="sphere">Sphere</option>
                        <option value="cylinder">Cylinder</option>
                        <option value="cone">Cone</option>
                        <option value="dodecahedron">Dodecahedron</option>
                        <option value="tetrahedron">Tetrahedron</option>
                        <option value="torus">Torus</option>
                        <option value="octahedron">Octahedron</option>
                    </select>
                </div>
                <div class="ctrl-row">
                    <label>Color</label>
                    <input type="color" id="pe-color" value="#888888">
                    <span class="val" id="pe-color-hex">#888888</span>
                </div>
                <div class="ctrl-row">
                    <label>Body Group</label>
                    <select id="pe-group">
                        <option value="0">0 - Body</option>
                        <option value="1">1 - Head</option>
                        <option value="2">2 - Arm L</option>
                        <option value="3">3 - Arm R</option>
                        <option value="4">4 - Leg L</option>
                        <option value="5">5 - Leg R</option>
                        <option value="6">6 - Extra A</option>
                        <option value="7">7 - Extra B</option>
                    </select>
                </div>
                <div class="ctrl-row">
                    <label>Pivot</label>
                    <select id="pe-pivot">
                        <option value="center">Center</option>
                        <option value="top">Top (hips/shoulders)</option>
                        <option value="bottom">Bottom (grow up)</option>
                        <option value="left">Left edge</option>
                        <option value="right">Right edge</option>
                    </select>
                </div>
                <div style="margin-top:8px;color:#666;font-size:10px;letter-spacing:1px">POSITION</div>
                <div class="ctrl-row"><label>X</label><input type="range" id="pe-px" min="-2" max="2" step="0.01" value="0"><span class="val" id="pe-px-v">0</span></div>
                <div class="ctrl-row"><label>Y</label><input type="range" id="pe-py" min="-2" max="2" step="0.01" value="0"><span class="val" id="pe-py-v">0</span></div>
                <div class="ctrl-row"><label>Z</label><input type="range" id="pe-pz" min="-2" max="2" step="0.01" value="0"><span class="val" id="pe-pz-v">0</span></div>
                <div style="margin-top:8px;color:#666;font-size:10px;letter-spacing:1px">ROTATION (deg)</div>
                <div class="ctrl-row"><label>X</label><input type="range" id="pe-rx" min="-180" max="180" step="1" value="0"><span class="val" id="pe-rx-v">0</span></div>
                <div class="ctrl-row"><label>Y</label><input type="range" id="pe-ry" min="-180" max="180" step="1" value="0"><span class="val" id="pe-ry-v">0</span></div>
                <div class="ctrl-row"><label>Z</label><input type="range" id="pe-rz" min="-180" max="180" step="1" value="0"><span class="val" id="pe-rz-v">0</span></div>
                <div style="margin-top:8px;color:#666;font-size:10px;letter-spacing:1px">SCALE</div>
                <div class="ctrl-row"><label>X</label><input type="range" id="pe-sx" min="0.02" max="2" step="0.01" value="0.5"><span class="val" id="pe-sx-v">0.5</span></div>
                <div class="ctrl-row"><label>Y</label><input type="range" id="pe-sy" min="0.02" max="2" step="0.01" value="0.5"><span class="val" id="pe-sy-v">0.5</span></div>
                <div class="ctrl-row"><label>Z</label><input type="range" id="pe-sz" min="0.02" max="2" step="0.01" value="0.5"><span class="val" id="pe-sz-v">0.5</span></div>
            </div>
        </div>
    </div>

    <!-- TRAITS TAB -->
    <div class="tab-content" id="tab-traits">
        <div class="section">
            <div class="section-title">TRAIT VALUES</div>
            <div class="section-body">
                <div class="ctrl-row"><label>Size</label><input type="range" id="tr-size" min="0.5" max="2" step="0.01" value="1"><span class="val" id="tr-size-v">1.00</span></div>
                <div class="ctrl-row"><label>Speed</label><input type="range" id="tr-speed" min="0.5" max="2" step="0.01" value="1"><span class="val" id="tr-speed-v">1.00</span></div>
                <div class="ctrl-row"><label>Toughness</label><input type="range" id="tr-tough" min="0.5" max="2" step="0.01" value="1"><span class="val" id="tr-tough-v">1.00</span></div>
                <div class="ctrl-row"><label>Aggression</label><input type="range" id="tr-aggro" min="0" max="1" step="0.01" value="0.5"><span class="val" id="tr-aggro-v">0.50</span></div>
            </div>
        </div>
        <div class="section">
            <div class="section-title">COMPUTED COLOR</div>
            <div class="section-body">
                <div class="color-preview" id="trait-color-preview"></div>
                <div class="trait-formula">
                    speed: blue(0.3,0.5,0.7) &rarr; purple(0.65,0.25,0.85)<br>
                    toughness: brown(0.55,0.45,0.3) &rarr; green(0.2,0.65,0.25)<br>
                    aggression: gray(0.5,0.5,0.5) &rarr; red(0.85,0.25,0.2)<br>
                    final = 40% speed + 40% tough + 20% aggro
                </div>
            </div>
        </div>
        <div class="section">
            <div class="section-title">GAME PARAMS</div>
            <div class="section-body">
                <div class="ctrl-row"><label>Base Size</label><input type="range" id="tr-basesize" min="0.3" max="3" step="0.1" value="1.2"><span class="val" id="tr-basesize-v">1.2</span></div>
                <div class="ctrl-row"><label>Base Speed</label><input type="range" id="tr-basespeed" min="0.5" max="10" step="0.1" value="3.5"><span class="val" id="tr-basespeed-v">3.5</span></div>
                <div class="ctrl-row"><label>Base Health</label><input type="range" id="tr-basehealth" min="10" max="500" step="5" value="100"><span class="val" id="tr-basehealth-v">100</span></div>
                <div class="ctrl-row"><label>Attack Range</label><input type="range" id="tr-atkrange" min="1" max="10" step="0.5" value="3"><span class="val" id="tr-atkrange-v">3</span></div>
            </div>
        </div>
    </div>

    <!-- ANIMATION TAB -->
    <div class="tab-content" id="tab-anim">
        <div class="section">
            <div class="section-title">PLAYBACK</div>
            <div class="section-body">
                <div class="btn-row" style="padding:0">
                    <button class="btn" id="btn-anim-play">PLAY</button>
                    <button class="btn" id="btn-anim-pause">PAUSE</button>
                    <button class="btn" id="btn-anim-reset">RESET</button>
                </div>
                <div class="ctrl-row"><label>Speed</label><input type="range" id="an-speed" min="0.1" max="3" step="0.1" value="1"><span class="val" id="an-speed-v">1.0</span></div>
            </div>
        </div>
        <div class="section">
            <div class="section-title">IDLE</div>
            <div class="section-body">
                <div class="ctrl-row"><label>Bob Amp</label><input type="range" id="an-bob-amp" min="0" max="0.3" step="0.005" value="0.06"><span class="val" id="an-bob-amp-v">0.06</span></div>
                <div class="ctrl-row"><label>Bob Freq</label><input type="range" id="an-bob-freq" min="0.5" max="5" step="0.1" value="2"><span class="val" id="an-bob-freq-v">2.0</span></div>
                <div class="ctrl-row"><label>Sway Amp</label><input type="range" id="an-sway-amp" min="0" max="0.3" step="0.005" value="0.05"><span class="val" id="an-sway-amp-v">0.05</span></div>
                <div class="ctrl-row"><label>Sway Freq</label><input type="range" id="an-sway-freq" min="0.1" max="3" step="0.1" value="0.7"><span class="val" id="an-sway-freq-v">0.7</span></div>
            </div>
        </div>
        <div class="section">
            <div class="section-title">WALK CYCLE</div>
            <div class="section-body">
                <div class="ctrl-row"><label>Leg Swing</label><input type="range" id="an-leg-amp" min="0" max="1.2" step="0.01" value="0.5"><span class="val" id="an-leg-amp-v">0.50</span></div>
                <div class="ctrl-row"><label>Leg Freq</label><input type="range" id="an-leg-freq" min="1" max="8" step="0.1" value="3"><span class="val" id="an-leg-freq-v">3.0</span></div>
                <div class="ctrl-row"><label>Arm Swing</label><input type="range" id="an-arm-amp" min="0" max="1" step="0.01" value="0.35"><span class="val" id="an-arm-amp-v">0.35</span></div>
                <div class="ctrl-row"><label>Head Bob</label><input type="range" id="an-head-amp" min="0" max="0.2" step="0.005" value="0.04"><span class="val" id="an-head-amp-v">0.04</span></div>
            </div>
        </div>
        <div class="section">
            <div class="section-title">EXTRAS</div>
            <div class="section-body">
                <div class="ctrl-row"><label>Extra Amp</label><input type="range" id="an-extra-amp" min="0" max="1" step="0.01" value="0.3"><span class="val" id="an-extra-amp-v">0.30</span></div>
                <div class="ctrl-row"><label>Extra Freq</label><input type="range" id="an-extra-freq" min="0.5" max="6" step="0.1" value="2"><span class="val" id="an-extra-freq-v">2.0</span></div>
                <div class="ctrl-row"><label>Breathe</label><input type="range" id="an-breathe" min="0" max="0.15" step="0.005" value="0.03"><span class="val" id="an-breathe-v">0.03</span></div>
            </div>
        </div>
    </div>

    <!-- PREVIEW TAB -->
    <div class="tab-content" id="tab-preview">
        <div class="section">
            <div class="section-title">INSTANCE MODE</div>
            <div class="section-body">
                <div class="preview-toggle">
                    <button class="btn active" data-mode="single">SINGLE</button>
                    <button class="btn" data-mode="grid3">3x3</button>
                    <button class="btn" data-mode="grid5">5x5</button>
                    <button class="btn" data-mode="grid7">7x7</button>
                </div>
                <button class="btn" id="btn-randomize" style="width:100%;margin-top:6px">RANDOMIZE TRAITS</button>
            </div>
        </div>
        <div class="section">
            <div class="section-title">VARIATION</div>
            <div class="section-body">
                <div class="ctrl-row"><label>Size Var</label><input type="range" id="pv-sizevar" min="0" max="1" step="0.01" value="0.5"><span class="val" id="pv-sizevar-v">0.50</span></div>
                <div class="ctrl-row"><label>Color Var</label><input type="range" id="pv-colorvar" min="0" max="1" step="0.01" value="0.5"><span class="val" id="pv-colorvar-v">0.50</span></div>
                <div class="ctrl-row"><label>Spacing</label><input type="range" id="pv-spacing" min="1" max="8" step="0.1" value="3"><span class="val" id="pv-spacing-v">3.0</span></div>
            </div>
        </div>
        <div class="section">
            <div class="section-title">DISPLAY</div>
            <div class="section-body">
                <div class="ctrl-row"><label>Show Grid</label><input type="checkbox" id="pv-grid" checked style="accent-color:#8af"></div>
                <div class="ctrl-row"><label>Show Axes</label><input type="checkbox" id="pv-axes" checked style="accent-color:#8af"></div>
                <div class="ctrl-row"><label>Wireframe</label><input type="checkbox" id="pv-wireframe" style="accent-color:#8af"></div>
                <div class="ctrl-row"><label>Shadows</label><input type="checkbox" id="pv-shadows" checked style="accent-color:#8af"></div>
                <div class="ctrl-row"><label>BG Color</label><input type="color" id="pv-bgcolor" value="#0d0d18"></div>
            </div>
        </div>
    </div>

    <!-- EXPORT TAB -->
    <div class="tab-content" id="tab-export">
        <div class="export-all-section">
            <button class="export-all-btn" id="btn-export-all">EXPORT ALL CREATURES &rarr; creatures.js</button>
            <div class="export-note">
                Downloads <b>creatures.js</b> with all saved creature types, geometry builders,
                animation data, and game params.<br><br>
                <b style="color:#8af">1.</b> Drop next to index.html<br>
                <b style="color:#8af">2.</b> Add <span style="color:#8af">&lt;script src="creatures.js"&gt;&lt;/script&gt;</span> before the module<br>
                <b style="color:#8af">3.</b> Call <span style="color:#8af">CREATURES.init(THREE);</span> at top of module<br>
                <b style="color:#8af">4.</b> Replace <span style="color:#666">BoxGeometry</span> with <span style="color:#8af">CREATURES.buildGeometry('grunt')</span>
            </div>
            <div class="section-title" style="padding:10px 0 4px;margin-top:8px">SAVED CREATURES</div>
            <div class="saved-list" id="saved-list"></div>
        </div>
        <div class="section">
            <div class="section-title">SINGLE TYPE CODE</div>
            <div class="section-body">
                <div class="btn-row" style="padding:0">
                    <button class="btn" id="btn-gen-geometry">GEOMETRY</button>
                    <button class="btn" id="btn-gen-material">MATERIAL TSL</button>
                    <button class="btn" id="btn-gen-full">FULL BUILDMESH</button>
                </div>
                <button class="btn" id="btn-copy-code" style="width:100%;margin-top:6px">COPY TO CLIPBOARD</button>
            </div>
        </div>
        <div class="section">
            <div class="section-title">OUTPUT</div>
            <div class="section-body" style="padding:0">
                <pre id="code-output">// Click a generation button above to produce code.
// Generated code targets GPUEnemySystem.buildMesh()
// in index.html (Three.js WebGPU + TSL)</pre>
            </div>
        </div>
        <div class="section">
            <div class="section-title">CREATURE JSON</div>
            <div class="section-body">
                <div class="btn-row" style="padding:0">
                    <button class="btn" id="btn-export-json">EXPORT JSON</button>
                    <button class="btn" id="btn-import-json">IMPORT JSON</button>
                </div>
                <textarea id="json-io" style="width:100%;height:80px;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.06);border-radius:3px;color:#888;padding:8px;font-family:inherit;font-size:10px;resize:vertical;margin-top:6px;outline:none" placeholder="Paste JSON here to import..."></textarea>
            </div>
        </div>
    </div>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { mergeGeometries } from 'three/addons/utils/BufferGeometryUtils.js';

// ================================================================
//  STATE
// ================================================================
let nextPartId = 0;
const state = {
    parts: [],
    selectedId: null,
    traits: { size: 1.0, speed: 1.0, toughness: 1.0, aggression: 0.5 },
    gameParams: { baseSize: 1.2, baseSpeed: 3.5, baseHealth: 100, attackRange: 3 },
    anim: {
        playing: true, speed: 1.0, time: 0,
        bobAmp: 0.06, bobFreq: 2, swayAmp: 0.05, swayFreq: 0.7,
        legAmp: 0.5, legFreq: 3, armAmp: 0.35, headAmp: 0.04,
        extraAmp: 0.3, extraFreq: 2, breathe: 0.03
    },
    preview: { mode: 'single', sizeVar: 0.5, colorVar: 0.5, spacing: 3 },
    display: { grid: true, axes: true, wireframe: false, shadows: true, bgColor: '#0d0d18' }
};

// ================================================================
//  PRESETS
// ================================================================
const PRESETS = {
    // ── GRUNT: standard humanoid, built from ground up ──
    // Legs: pivot='top' → hip joint at pos.y, geometry hangs down to ground
    // Body: pivot='bottom' → sits on hip. Arms: pivot='top' → hang from shoulder
    // Body dimensions: scale=[0.50,0.32,0.35], so width=1.00, top at y=0.60+0.64=1.24
    grunt: {
        name: 'Grunt',
        parts: [
            // Legs: pivot='top' → rotation at hip (pos.y=0.60), foot at ground
            { name: 'Leg L', shape: 'box', pos: [-0.16,0.60,0], rot: [0,0,0], scale: [0.13,0.30,0.14], color: '#585858', group: 4, pivot: 'top' },
            { name: 'Leg R', shape: 'box', pos: [0.16,0.60,0], rot: [0,0,0], scale: [0.13,0.30,0.14], color: '#585858', group: 5, pivot: 'top' },
            // Body: bottom sits on hip (y=0.60), top at y=1.24
            { name: 'Body', shape: 'box', pos: [0,0.60,0], rot: [0,0,0], scale: [0.50,0.32,0.35], color: '#707070', group: 0, pivot: 'bottom' },
            // Head: bottom at top of body (y=1.24)
            { name: 'Head', shape: 'box', pos: [0,1.24,0.04], rot: [0,0,0], scale: [0.32,0.20,0.30], color: '#808080', group: 1, pivot: 'bottom' },
            { name: 'Eye L', shape: 'sphere', pos: [-0.13,1.48,0.20], rot: [0,0,0], scale: [0.055,0.055,0.055], color: '#ff2222', group: 1, pivot: 'center' },
            { name: 'Eye R', shape: 'sphere', pos: [0.13,1.48,0.20], rot: [0,0,0], scale: [0.055,0.055,0.055], color: '#ff2222', group: 1, pivot: 'center' },
            // Arms: pivot='top' at shoulder (body top edge, body half-width=0.50)
            { name: 'Arm L', shape: 'box', pos: [-0.50,1.20,0], rot: [0,0,12], scale: [0.12,0.35,0.12], color: '#606060', group: 2, pivot: 'top' },
            { name: 'Arm R', shape: 'box', pos: [0.50,1.20,0], rot: [0,0,-12], scale: [0.12,0.35,0.12], color: '#606060', group: 3, pivot: 'top' },
        ]
    },
    // ── BRUTE: heavy tank, short legs, wide body ──
    // Legs: hip at y=0.44, body half-width=0.70, body top at y=0.44+0.84=1.28
    brute: {
        name: 'Brute',
        parts: [
            // Legs: pivot='top' → hip at 0.44, feet at ground
            { name: 'Leg L', shape: 'box', pos: [-0.22,0.44,0], rot: [0,0,0], scale: [0.18,0.22,0.18], color: '#4a5a45', group: 4, pivot: 'top' },
            { name: 'Leg R', shape: 'box', pos: [0.22,0.44,0], rot: [0,0,0], scale: [0.18,0.22,0.18], color: '#4a5a45', group: 5, pivot: 'top' },
            // Body: bottom at hip (y=0.44), top at y=1.28
            { name: 'Body', shape: 'box', pos: [0,0.44,0], rot: [0,0,0], scale: [0.70,0.42,0.50], color: '#5a6a55', group: 0, pivot: 'bottom' },
            // Head at y=1.28
            { name: 'Head', shape: 'box', pos: [0,1.28,0.08], rot: [5,0,0], scale: [0.40,0.18,0.35], color: '#6a7a65', group: 1, pivot: 'bottom' },
            { name: 'Jaw', shape: 'box', pos: [0,1.28,0.22], rot: [0,0,0], scale: [0.30,0.10,0.15], color: '#4a5a45', group: 1, pivot: 'center' },
            { name: 'Eye L', shape: 'sphere', pos: [-0.15,1.52,0.22], rot: [0,0,0], scale: [0.06,0.04,0.05], color: '#ffaa00', group: 1, pivot: 'center' },
            { name: 'Eye R', shape: 'sphere', pos: [0.15,1.52,0.22], rot: [0,0,0], scale: [0.06,0.04,0.05], color: '#ffaa00', group: 1, pivot: 'center' },
            // Shoulders + Arms: at body top-side (body half-width=0.70, shoulder near top)
            { name: 'Shoulder L', shape: 'sphere', pos: [-0.70,1.24,0], rot: [0,0,0], scale: [0.20,0.18,0.18], color: '#5a6a55', group: 2, pivot: 'center' },
            { name: 'Shoulder R', shape: 'sphere', pos: [0.70,1.24,0], rot: [0,0,0], scale: [0.20,0.18,0.18], color: '#5a6a55', group: 3, pivot: 'center' },
            { name: 'Arm L', shape: 'box', pos: [-0.70,1.22,0.05], rot: [0,0,8], scale: [0.16,0.45,0.16], color: '#4a5a45', group: 2, pivot: 'top' },
            { name: 'Arm R', shape: 'box', pos: [0.70,1.22,0.05], rot: [0,0,-8], scale: [0.16,0.45,0.16], color: '#4a5a45', group: 3, pivot: 'top' },
            { name: 'Spike L', shape: 'cone', pos: [-0.35,1.60,0], rot: [0,0,25], scale: [0.08,0.25,0.08], color: '#3a4a35', group: 0, pivot: 'bottom' },
            { name: 'Spike R', shape: 'cone', pos: [0.35,1.60,0], rot: [0,0,-25], scale: [0.08,0.25,0.08], color: '#3a4a35', group: 0, pivot: 'bottom' },
        ]
    },
    // ── RUNNER: long legs, lean body ──
    // Legs: hip at y=0.76, body half-width=0.25, body top at y=0.76+0.44=1.20
    runner: {
        name: 'Runner',
        parts: [
            // Legs: pivot='top' → hip at 0.76, feet at ground
            { name: 'Leg L', shape: 'box', pos: [-0.12,0.76,0], rot: [0,0,0], scale: [0.07,0.38,0.07], color: '#606090', group: 4, pivot: 'top' },
            { name: 'Leg R', shape: 'box', pos: [0.12,0.76,0], rot: [0,0,0], scale: [0.07,0.38,0.07], color: '#606090', group: 5, pivot: 'top' },
            // Body at y=0.76, top at y=1.20
            { name: 'Body', shape: 'box', pos: [0,0.76,0], rot: [8,0,0], scale: [0.25,0.22,0.20], color: '#7070a0', group: 0, pivot: 'bottom' },
            // Head at y=1.20
            { name: 'Head', shape: 'sphere', pos: [0,1.20,0.12], rot: [0,0,0], scale: [0.18,0.18,0.20], color: '#8080b0', group: 1, pivot: 'bottom' },
            { name: 'Eye L', shape: 'sphere', pos: [-0.08,1.42,0.25], rot: [0,0,0], scale: [0.04,0.06,0.04], color: '#00ffaa', group: 1, pivot: 'center' },
            { name: 'Eye R', shape: 'sphere', pos: [0.08,1.42,0.25], rot: [0,0,0], scale: [0.04,0.06,0.04], color: '#00ffaa', group: 1, pivot: 'center' },
            // Arms at body top-side (half-width=0.25, near top y=1.16)
            { name: 'Arm L', shape: 'box', pos: [-0.25,1.16,-0.05], rot: [15,0,15], scale: [0.06,0.28,0.06], color: '#606090', group: 2, pivot: 'top' },
            { name: 'Arm R', shape: 'box', pos: [0.25,1.16,-0.05], rot: [15,0,-15], scale: [0.06,0.28,0.06], color: '#606090', group: 3, pivot: 'top' },
            { name: 'Tail', shape: 'cone', pos: [0,0.85,-0.28], rot: [70,0,0], scale: [0.06,0.30,0.06], color: '#8080b0', group: 6, pivot: 'top' },
        ]
    },
    // ── CRAWLER: spider, body low, legs splay from body ──
    crawler: {
        name: 'Crawler',
        parts: [
            { name: 'Thorax', shape: 'sphere', pos: [0,0.25,0], rot: [0,0,0], scale: [0.30,0.20,0.30], color: '#886644', group: 0, pivot: 'center' },
            { name: 'Abdomen', shape: 'sphere', pos: [0,0.22,-0.40], rot: [0,0,0], scale: [0.25,0.20,0.35], color: '#775533', group: 0, pivot: 'center' },
            { name: 'Head', shape: 'sphere', pos: [0,0.28,0.30], rot: [0,0,0], scale: [0.15,0.12,0.15], color: '#997755', group: 1, pivot: 'center' },
            { name: 'Mandible L', shape: 'cone', pos: [-0.08,0.22,0.42], rot: [-30,-20,0], scale: [0.03,0.12,0.03], color: '#aa8866', group: 1, pivot: 'top' },
            { name: 'Mandible R', shape: 'cone', pos: [0.08,0.22,0.42], rot: [-30,20,0], scale: [0.03,0.12,0.03], color: '#aa8866', group: 1, pivot: 'top' },
            // Legs: pivot='top' → attached at body, extend outward/down
            { name: 'Leg FL', shape: 'cylinder', pos: [-0.28,0.22,0.20], rot: [0,0,50], scale: [0.025,0.28,0.025], color: '#664422', group: 2, pivot: 'top' },
            { name: 'Leg FR', shape: 'cylinder', pos: [0.28,0.22,0.20], rot: [0,0,-50], scale: [0.025,0.28,0.025], color: '#664422', group: 3, pivot: 'top' },
            { name: 'Leg ML', shape: 'cylinder', pos: [-0.30,0.22,0], rot: [0,0,55], scale: [0.025,0.30,0.025], color: '#664422', group: 4, pivot: 'top' },
            { name: 'Leg MR', shape: 'cylinder', pos: [0.30,0.22,0], rot: [0,0,-55], scale: [0.025,0.30,0.025], color: '#664422', group: 5, pivot: 'top' },
            { name: 'Leg BL', shape: 'cylinder', pos: [-0.26,0.22,-0.20], rot: [0,0,45], scale: [0.025,0.26,0.025], color: '#664422', group: 6, pivot: 'top' },
            { name: 'Leg BR', shape: 'cylinder', pos: [0.26,0.22,-0.20], rot: [0,0,-45], scale: [0.025,0.26,0.025], color: '#664422', group: 7, pivot: 'top' },
            { name: 'Eye L', shape: 'sphere', pos: [-0.06,0.32,0.38], rot: [0,0,0], scale: [0.035,0.035,0.035], color: '#ff3300', group: 1, pivot: 'center' },
            { name: 'Eye R', shape: 'sphere', pos: [0.06,0.32,0.38], rot: [0,0,0], scale: [0.035,0.035,0.035], color: '#ff3300', group: 1, pivot: 'center' },
        ]
    },
    // ── FLYER: wings from body edges, legs dangle ──
    flyer: {
        name: 'Flyer',
        parts: [
            { name: 'Body', shape: 'sphere', pos: [0,0.80,0], rot: [0,0,0], scale: [0.20,0.25,0.18], color: '#8866aa', group: 0, pivot: 'center' },
            { name: 'Head', shape: 'sphere', pos: [0,1.10,0.08], rot: [0,0,0], scale: [0.15,0.15,0.15], color: '#9977bb', group: 1, pivot: 'bottom' },
            { name: 'Eye', shape: 'sphere', pos: [0,1.32,0.18], rot: [0,0,0], scale: [0.07,0.07,0.04], color: '#ff00ff', group: 1, pivot: 'center' },
            // Wings: pivot='right'/'left' → attached at body-side edge
            { name: 'Wing L', shape: 'box', pos: [-0.20,0.90,0], rot: [0,0,-15], scale: [0.35,0.02,0.20], color: '#aa88cc', group: 6, pivot: 'right' },
            { name: 'Wing R', shape: 'box', pos: [0.20,0.90,0], rot: [0,0,15], scale: [0.35,0.02,0.20], color: '#aa88cc', group: 7, pivot: 'left' },
            { name: 'Wing Tip L', shape: 'box', pos: [-0.85,0.85,-0.05], rot: [0,0,-25], scale: [0.15,0.015,0.12], color: '#9977bb', group: 6, pivot: 'right' },
            { name: 'Wing Tip R', shape: 'box', pos: [0.85,0.85,-0.05], rot: [0,0,25], scale: [0.15,0.015,0.12], color: '#9977bb', group: 7, pivot: 'left' },
            { name: 'Tail', shape: 'cone', pos: [0,0.65,-0.25], rot: [50,0,0], scale: [0.05,0.25,0.05], color: '#7755aa', group: 0, pivot: 'top' },
            // Legs: pivot='top' → dangle from body
            { name: 'Leg L', shape: 'cylinder', pos: [-0.10,0.55,0], rot: [0,0,5], scale: [0.03,0.20,0.03], color: '#665588', group: 4, pivot: 'top' },
            { name: 'Leg R', shape: 'cylinder', pos: [0.10,0.55,0], rot: [0,0,-5], scale: [0.03,0.20,0.03], color: '#665588', group: 5, pivot: 'top' },
        ]
    }
};

// ================================================================
//  PIVOT SYSTEM
// ================================================================
const PIVOT_MAP = {
    center: [0, 0, 0],
    top:    [0, -0.5, 0],   // shift geo down → top edge at origin (hips/shoulders)
    bottom: [0, 0.5, 0],    // shift geo up → bottom edge at origin (feet/ground)
    left:   [0.5, 0, 0],    // shift right → left edge at origin
    right:  [-0.5, 0, 0]    // shift left → right edge at origin
};
function getPivotOffset(pivot) {
    return PIVOT_MAP[pivot] || PIVOT_MAP.center;
}

// ================================================================
//  SAVED CREATURES REGISTRY
// ================================================================
// Deep-clone all presets into a mutable registry
const savedCreatures = {};
for (const [name, preset] of Object.entries(PRESETS)) {
    savedCreatures[name] = {
        name: preset.name,
        parts: preset.parts.map(p => ({ ...p, pos: [...p.pos], rot: [...p.rot], scale: [...p.scale], pivot: p.pivot || 'center' })),
        anim: { bobAmp: 0.06, bobFreq: 2, swayAmp: 0.05, swayFreq: 0.7, legAmp: 0.5, legFreq: 3, armAmp: 0.35, headAmp: 0.04, extraAmp: 0.3, extraFreq: 2, breathe: 0.03 },
        gameParams: { baseSize: 1.2, baseSpeed: 3.5, baseHealth: 100, attackRange: 3 }
    };
}

function getActivePresetName() {
    return document.querySelector('.preset-btn.active')?.dataset.preset || null;
}

function saveCurrentToPreset() {
    const name = getActivePresetName();
    if (!name) return;
    savedCreatures[name] = {
        name: PRESETS[name]?.name || name,
        parts: state.parts.map(p => ({
            name: p.name, shape: p.shape, pos: [...p.pos], rot: [...p.rot],
            scale: [...p.scale], color: p.color, group: p.group, pivot: p.pivot || 'center'
        })),
        anim: {
            bobAmp: state.anim.bobAmp, bobFreq: state.anim.bobFreq,
            swayAmp: state.anim.swayAmp, swayFreq: state.anim.swayFreq,
            legAmp: state.anim.legAmp, legFreq: state.anim.legFreq,
            armAmp: state.anim.armAmp, headAmp: state.anim.headAmp,
            extraAmp: state.anim.extraAmp, extraFreq: state.anim.extraFreq,
            breathe: state.anim.breathe
        },
        gameParams: { ...state.gameParams }
    };
    // Mark button as saved
    const btn = document.querySelector(`.preset-btn[data-preset="${name}"]`);
    if (btn) { btn.classList.add('modified'); }
    updateSavedList();
}

function updateSavedList() {
    const list = document.getElementById('saved-list');
    if (!list) return;
    list.innerHTML = '';
    for (const [key, creature] of Object.entries(savedCreatures)) {
        const item = document.createElement('div');
        item.className = 'saved-item';
        item.innerHTML = `<span class="saved-name">${creature.name.toUpperCase()}</span><span class="saved-parts">${creature.parts.length} parts</span>`;
        list.appendChild(item);
    }
}

// ================================================================
//  THREE.JS SETUP
// ================================================================
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setClearColor(0x0d0d18);
const vpEl = document.getElementById('viewport');
vpEl.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0d0d18, 0.035);

const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 200);
camera.position.set(2.5, 2, 3);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.target.set(0, 0.6, 0);
controls.minDistance = 1;
controls.maxDistance = 50;

// Lighting
const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffeedd, 1.2);
dirLight.position.set(5, 10, 5);
dirLight.castShadow = true;
dirLight.shadow.mapSize.set(1024, 1024);
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 30;
dirLight.shadow.camera.left = -8;
dirLight.shadow.camera.right = 8;
dirLight.shadow.camera.top = 8;
dirLight.shadow.camera.bottom = -8;
scene.add(dirLight);

const hemiLight = new THREE.HemisphereLight(0x8888cc, 0x443322, 0.3);
scene.add(hemiLight);

// Grid + Axes
const gridHelper = new THREE.GridHelper(10, 20, 0x222233, 0x181825);
scene.add(gridHelper);

const axesHelper = new THREE.AxesHelper(0.5);
axesHelper.position.set(-4.5, 0.01, -4.5);
scene.add(axesHelper);

// Ground plane for shadows
const groundGeo = new THREE.PlaneGeometry(20, 20);
const groundMat = new THREE.ShadowMaterial({ opacity: 0.3 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// ================================================================
//  GEOMETRY FACTORY
// ================================================================
function createGeometry(shape) {
    switch (shape) {
        case 'box': return new THREE.BoxGeometry(1, 1, 1, 1, 1, 1);
        case 'sphere': return new THREE.SphereGeometry(0.5, 12, 8);
        case 'cylinder': return new THREE.CylinderGeometry(0.5, 0.5, 1, 12);
        case 'cone': return new THREE.ConeGeometry(0.5, 1, 12);
        case 'dodecahedron': return new THREE.DodecahedronGeometry(0.5, 0);
        case 'tetrahedron': return new THREE.TetrahedronGeometry(0.5, 0);
        case 'torus': return new THREE.TorusGeometry(0.35, 0.15, 8, 16);
        case 'octahedron': return new THREE.OctahedronGeometry(0.5, 0);
        default: return new THREE.BoxGeometry(1, 1, 1);
    }
}

function geoExportString(shape) {
    switch (shape) {
        case 'box': return 'new THREE.BoxGeometry(1, 1, 1)';
        case 'sphere': return 'new THREE.SphereGeometry(0.5, 12, 8)';
        case 'cylinder': return 'new THREE.CylinderGeometry(0.5, 0.5, 1, 12)';
        case 'cone': return 'new THREE.ConeGeometry(0.5, 1, 12)';
        case 'dodecahedron': return 'new THREE.DodecahedronGeometry(0.5, 0)';
        case 'tetrahedron': return 'new THREE.TetrahedronGeometry(0.5, 0)';
        case 'torus': return 'new THREE.TorusGeometry(0.35, 0.15, 8, 16)';
        case 'octahedron': return 'new THREE.OctahedronGeometry(0.5, 0)';
        default: return 'new THREE.BoxGeometry(1, 1, 1)';
    }
}

// ================================================================
//  CREATURE RENDERING
// ================================================================
const creatureGroup = new THREE.Group();
scene.add(creatureGroup);
const partMeshes = new Map(); // partId -> { mesh, wireframe }
let instanceGroup = null;

function rebuildCreature() {
    // Clear existing
    creatureGroup.clear();
    partMeshes.clear();

    for (const part of state.parts) {
        addPartMesh(part);
    }
    updateTraitVisuals();
    rebuildInstances();
}

function addPartMesh(part) {
    const geo = createGeometry(part.shape);
    // Apply pivot offset in unit geometry space (before mesh scale)
    const piv = getPivotOffset(part.pivot || 'center');
    if (piv[0] || piv[1] || piv[2]) geo.translate(piv[0], piv[1], piv[2]);

    const mat = new THREE.MeshLambertMaterial({
        color: new THREE.Color(part.color),
        wireframe: state.display.wireframe
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = state.display.shadows;

    // Wireframe overlay for selection
    const wireMat = new THREE.MeshBasicMaterial({ color: 0x88aaff, wireframe: true, transparent: true, opacity: 0.4 });
    const wireMesh = new THREE.Mesh(geo, wireMat);
    wireMesh.visible = false;
    mesh.add(wireMesh);

    applyPartTransform(mesh, part);
    mesh.userData.partId = part.id;
    creatureGroup.add(mesh);
    partMeshes.set(part.id, { mesh, wire: wireMesh });
}

function applyPartTransform(mesh, part) {
    mesh.position.set(part.pos[0], part.pos[1], part.pos[2]);
    mesh.rotation.set(
        part.rot[0] * Math.PI / 180,
        part.rot[1] * Math.PI / 180,
        part.rot[2] * Math.PI / 180
    );
    mesh.scale.set(part.scale[0] * 2, part.scale[1] * 2, part.scale[2] * 2);
}

function updatePartMesh(part) {
    const entry = partMeshes.get(part.id);
    if (!entry) return;

    // Always rebuild geometry (shape or pivot may have changed)
    const newGeo = createGeometry(part.shape);
    const piv = getPivotOffset(part.pivot || 'center');
    if (piv[0] || piv[1] || piv[2]) newGeo.translate(piv[0], piv[1], piv[2]);

    entry.mesh.geometry.dispose();
    entry.mesh.geometry = newGeo;
    entry.wire.geometry.dispose();
    entry.wire.geometry = newGeo;

    entry.mesh.material.color.set(part.color);
    entry.mesh.material.wireframe = state.display.wireframe;
    applyPartTransform(entry.mesh, part);
}

function selectPart(id) {
    // Deselect previous
    if (state.selectedId !== null) {
        const prev = partMeshes.get(state.selectedId);
        if (prev) prev.wire.visible = false;
    }
    state.selectedId = id;
    if (id !== null) {
        const entry = partMeshes.get(id);
        if (entry) entry.wire.visible = true;
    }
    updatePartEditor();
    updatePartListUI();
}

// ================================================================
//  TRAIT SYSTEM
// ================================================================
function computeTraitColor(speed, toughness, aggression) {
    const tS = Math.max(0, Math.min(1, speed / 2));
    const tT = Math.max(0, Math.min(1, toughness / 2));
    const tA = Math.max(0, Math.min(1, aggression));

    const lerp = (a, b, t) => a + (b - a) * t;

    // Speed: blue→purple
    const sR = lerp(0.3, 0.65, tS), sG = lerp(0.5, 0.25, tS), sB = lerp(0.7, 0.85, tS);
    // Toughness: brown→green
    const tR = lerp(0.55, 0.2, tT), tG = lerp(0.45, 0.65, tT), tB = lerp(0.3, 0.25, tT);
    // Aggression: gray→red
    const aR = lerp(0.5, 0.85, tA), aG = lerp(0.5, 0.25, tA), aB = lerp(0.5, 0.2, tA);

    // Blend: 40% speed + 40% tough + 20% aggro
    return {
        r: sR * 0.4 + tR * 0.4 + aR * 0.2,
        g: sG * 0.4 + tG * 0.4 + aG * 0.2,
        b: sB * 0.4 + tB * 0.4 + aB * 0.2
    };
}

function updateTraitVisuals() {
    const { size, speed, toughness, aggression } = state.traits;
    const traitColor = computeTraitColor(speed, toughness, aggression);

    // Toughness-driven proportions (0.5→2.0 range, normalized to 0→1)
    const tNorm = clampF((toughness - 0.5) / 1.5, 0, 1);
    // High toughness → shorter legs, wider/taller body
    const legYMult   = 1.0 - tNorm * 0.3;   // 1.0 → 0.7
    const bodyYMult  = 1.0 + tNorm * 0.25;   // 1.0 → 1.25
    const bodyXZMult = 1.0 + tNorm * 0.35;   // 1.0 → 1.35

    // Compute ground shift: when legs shrink, body must shift down to keep feet on ground
    // Find the tallest leg's base visual height (scale.y * 2) and compare shrunk vs original
    let maxLegVisualH = 0;
    for (const part of state.parts) {
        if (part.group === 4 || part.group === 5) {
            maxLegVisualH = Math.max(maxLegVisualH, part.scale[1] * 2);
        }
    }
    const yShift = maxLegVisualH * (1 - legYMult); // how much the legs shortened

    // Apply trait-driven tint and toughness proportions to all parts
    for (const part of state.parts) {
        const entry = partMeshes.get(part.id);
        if (!entry) continue;

        // Color: blend 50% base + 50% trait
        const base = new THREE.Color(part.color);
        const trait = new THREE.Color(traitColor.r, traitColor.g, traitColor.b);
        const blended = base.clone().lerp(trait, 0.5);
        entry.mesh.material.color.copy(blended);

        // Toughness proportions: scale multipliers per body group
        let sxMul = 1, syMul = 1, szMul = 1;
        const isLeg = (part.group === 4 || part.group === 5);
        const isBody = (part.group === 0);

        if (isLeg) {
            syMul = legYMult;
        } else if (isBody) {
            sxMul = bodyXZMult;
            syMul = bodyYMult;
            szMul = bodyXZMult;
        }

        entry.mesh.scale.set(
            part.scale[0] * 2 * sxMul,
            part.scale[1] * 2 * syMul,
            part.scale[2] * 2 * szMul
        );

        // Shift ALL parts down by yShift to keep feet on ground
        // (with pivot='top' legs, shrinking the leg lifts the foot;
        //  shifting everything down compensates)
        entry.mesh.position.y = part.pos[1] - yShift;
    }

    // Apply size trait to creature group scale
    const s = state.gameParams.baseSize * size;
    creatureGroup.scale.set(s, s, s);

    // Update color preview
    const preview = document.getElementById('trait-color-preview');
    if (preview) {
        const r = Math.round(traitColor.r * 255);
        const g = Math.round(traitColor.g * 255);
        const b = Math.round(traitColor.b * 255);
        preview.style.background = `rgb(${r},${g},${b})`;
    }
}

// ================================================================
//  ANIMATION SYSTEM
// ================================================================

// Compute the current toughness-driven Y shift for the creature
function getToughnessShift() {
    const tNorm = clampF((state.traits.toughness - 0.5) / 1.5, 0, 1);
    const legYMult = 1.0 - tNorm * 0.3;
    let maxLegVisualH = 0;
    for (const part of state.parts) {
        if (part.group === 4 || part.group === 5) {
            maxLegVisualH = Math.max(maxLegVisualH, part.scale[1] * 2);
        }
    }
    return { yShift: maxLegVisualH * (1 - legYMult), legYMult, tNorm };
}

function animateCreature(dt) {
    if (!state.anim.playing) return;
    state.anim.time += dt * state.anim.speed;
    const t = state.anim.time;
    const a = state.anim;
    const { yShift, legYMult, tNorm } = getToughnessShift();
    const bodyXZMult = 1.0 + tNorm * 0.35;
    const bodyYMult  = 1.0 + tNorm * 0.25;

    for (const part of state.parts) {
        const entry = partMeshes.get(part.id);
        if (!entry) continue;

        let oY = 0, oX = 0, oZ = 0;
        let rX = 0, rY = 0, rZ = 0;
        const isLeg = (part.group === 4 || part.group === 5);
        const isBody = (part.group === 0);
        // Shift ALL parts down by yShift (keeps feet on ground with 'top' pivot legs)
        const baseY = part.pos[1] - yShift;

        switch (part.group) {
            case 0: // Body
                oY = Math.sin(t * a.bobFreq) * a.bobAmp;
                rY = Math.sin(t * a.swayFreq) * a.swayAmp;
                // Breathing scale pulse (combined with toughness multipliers)
                const breathe = 1 + Math.sin(t * 1.5) * a.breathe;
                entry.mesh.scale.set(
                    part.scale[0] * 2 * bodyXZMult * breathe,
                    part.scale[1] * 2 * bodyYMult,
                    part.scale[2] * 2 * bodyXZMult * breathe
                );
                break;
            case 1: // Head
                oY = Math.sin(t * a.bobFreq + 0.3) * a.headAmp;
                rY = Math.sin(t * a.swayFreq + 0.5) * a.swayAmp * 0.5;
                break;
            case 2: // Arm L — swings opposite to Leg L (with Leg R)
                rX = Math.sin(t * a.legFreq + Math.PI) * a.armAmp;
                break;
            case 3: // Arm R — swings opposite to Leg R (with Leg L)
                rX = Math.sin(t * a.legFreq) * a.armAmp;
                break;
            case 4: // Leg L
                rX = Math.sin(t * a.legFreq) * a.legAmp;
                // Apply leg Y scale multiplier during animation
                entry.mesh.scale.set(
                    part.scale[0] * 2,
                    part.scale[1] * 2 * legYMult,
                    part.scale[2] * 2
                );
                break;
            case 5: // Leg R
                rX = Math.sin(t * a.legFreq + Math.PI) * a.legAmp;
                entry.mesh.scale.set(
                    part.scale[0] * 2,
                    part.scale[1] * 2 * legYMult,
                    part.scale[2] * 2
                );
                break;
            case 6: // Extra A
                rZ = Math.sin(t * a.extraFreq) * a.extraAmp;
                oY += Math.sin(t * a.extraFreq) * a.extraAmp * 0.1;
                break;
            case 7: // Extra B
                rZ = Math.sin(t * a.extraFreq + Math.PI) * a.extraAmp;
                oY += Math.sin(t * a.extraFreq + Math.PI) * a.extraAmp * 0.1;
                break;
        }

        entry.mesh.position.set(
            part.pos[0] + oX,
            baseY + oY,
            part.pos[2] + oZ
        );
        entry.mesh.rotation.set(
            (part.rot[0]) * Math.PI / 180 + rX,
            (part.rot[1]) * Math.PI / 180 + rY,
            (part.rot[2]) * Math.PI / 180 + rZ
        );
    }
}

// ================================================================
//  INSTANCE PREVIEW
// ================================================================
function rebuildInstances() {
    if (instanceGroup) {
        scene.remove(instanceGroup);
        instanceGroup.traverse(c => { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); });
        instanceGroup = null;
    }

    if (state.preview.mode === 'single') return;

    const n = state.preview.mode === 'grid3' ? 3 : state.preview.mode === 'grid5' ? 5 : 7;
    const spacing = state.preview.spacing;
    instanceGroup = new THREE.Group();

    // Merge all parts into one geometry
    const mergedGeo = buildMergedGeometry();
    if (!mergedGeo) return;

    const instanceMesh = new THREE.InstancedMesh(
        mergedGeo,
        new THREE.MeshLambertMaterial({ vertexColors: false, wireframe: state.display.wireframe }),
        n * n
    );
    instanceMesh.castShadow = true;
    instanceMesh.instanceColor = new THREE.InstancedBufferAttribute(
        new Float32Array(n * n * 3), 3
    );

    const dummy = new THREE.Matrix4();
    const color = new THREE.Color();
    let idx = 0;

    for (let iz = 0; iz < n; iz++) {
        for (let ix = 0; ix < n; ix++) {
            const cx = (ix - (n - 1) / 2) * spacing;
            const cz = (iz - (n - 1) / 2) * spacing;

            // Skip center (that's the editable one)
            if (ix === Math.floor(n / 2) && iz === Math.floor(n / 2)) {
                dummy.makeScale(0, 0, 0);
                instanceMesh.setMatrixAt(idx, dummy);
                instanceMesh.setColorAt(idx, new THREE.Color(0, 0, 0));
                idx++;
                continue;
            }

            // Random traits per instance
            const rng = mulberry32(ix * 100 + iz * 37 + 42);
            const iSize = clampF(state.traits.size + (rng() - 0.5) * state.preview.sizeVar, 0.5, 2);
            const iSpeed = clampF(state.traits.speed + (rng() - 0.5) * state.preview.colorVar * 2, 0.5, 2);
            const iTough = clampF(state.traits.toughness + (rng() - 0.5) * state.preview.colorVar * 2, 0.5, 2);
            const iAggro = clampF(state.traits.aggression + (rng() - 0.5) * state.preview.colorVar, 0, 1);

            const s = state.gameParams.baseSize * iSize;
            // Non-uniform scaling variation (matching game)
            const sw = s * (0.8 + rng() * 0.4);
            const sh = s * (0.8 + rng() * 0.6);
            const sd = s * (0.8 + rng() * 0.4);

            dummy.makeScale(sw, sh, sd);
            dummy.setPosition(cx, 0, cz);
            instanceMesh.setMatrixAt(idx, dummy);

            const tc = computeTraitColor(iSpeed, iTough, iAggro);
            color.setRGB(tc.r, tc.g, tc.b);
            instanceMesh.setColorAt(idx, color);
            idx++;
        }
    }

    instanceMesh.instanceMatrix.needsUpdate = true;
    instanceMesh.instanceColor.needsUpdate = true;
    instanceGroup.add(instanceMesh);
    scene.add(instanceGroup);
}

function buildMergedGeometry() {
    if (state.parts.length === 0) return null;

    const geometries = [];
    for (const part of state.parts) {
        const geo = createGeometry(part.shape);

        // Apply pivot offset in unit space first
        const piv = getPivotOffset(part.pivot || 'center');
        if (piv[0] || piv[1] || piv[2]) geo.translate(piv[0], piv[1], piv[2]);

        // Apply transforms
        geo.scale(part.scale[0] * 2, part.scale[1] * 2, part.scale[2] * 2);
        const euler = new THREE.Euler(
            part.rot[0] * Math.PI / 180,
            part.rot[1] * Math.PI / 180,
            part.rot[2] * Math.PI / 180
        );
        geo.applyQuaternion(new THREE.Quaternion().setFromEuler(euler));
        geo.translate(part.pos[0], part.pos[1], part.pos[2]);

        // Add partGroup attribute
        const count = geo.attributes.position.count;
        const groups = new Float32Array(count).fill(part.group);
        geo.setAttribute('partGroup', new THREE.BufferAttribute(groups, 1));

        // Add base color attribute
        const c = new THREE.Color(part.color);
        const colors = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            colors[i * 3] = c.r;
            colors[i * 3 + 1] = c.g;
            colors[i * 3 + 2] = c.b;
        }
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        geometries.push(geo);
    }

    try {
        return mergeGeometries(geometries, false);
    } catch (e) {
        console.warn('Merge failed:', e);
        return geometries[0] || null;
    }
}

// ================================================================
//  UTILITY
// ================================================================
function mulberry32(seed) {
    return function() {
        seed |= 0; seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}
function clampF(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

// ================================================================
//  UI CONTROLLER
// ================================================================

// --- Tab switching ---
document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
    });
});

// --- Preset buttons ---
document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        loadPreset(btn.dataset.preset);
    });
});

function loadPreset(name) {
    const preset = PRESETS[name];
    if (!preset) return;

    state.parts = preset.parts.map(p => ({
        ...p,
        id: nextPartId++,
        pos: [...p.pos],
        rot: [...p.rot],
        scale: [...p.scale],
        pivot: p.pivot || 'center'
    }));
    state.selectedId = null;
    rebuildCreature();

    updatePartListUI();
    updatePartEditor();
}

// --- Part list ---
function updatePartListUI() {
    const list = document.getElementById('part-list');
    document.getElementById('part-count').textContent = state.parts.length;
    list.innerHTML = '';

    for (const part of state.parts) {
        const item = document.createElement('div');
        item.className = 'part-item' + (part.id === state.selectedId ? ' selected' : '');
        item.innerHTML = `
            <div class="part-color" style="background:${part.color}"></div>
            <span class="part-name">${part.name}</span>
            <span class="part-shape">${part.shape}</span>
            <span class="part-group">G${part.group}</span>
        `;
        item.addEventListener('click', () => selectPart(part.id));
        list.appendChild(item);
    }
}

// --- Part editor ---
function updatePartEditor() {
    const editor = document.getElementById('part-editor');
    const part = state.parts.find(p => p.id === state.selectedId);

    if (!part) {
        editor.style.display = 'none';
        return;
    }

    editor.style.display = '';
    document.getElementById('edit-part-name').textContent = part.name;

    setVal('pe-name', part.name);
    setVal('pe-shape', part.shape);
    setVal('pe-color', part.color);
    document.getElementById('pe-color-hex').textContent = part.color;
    setVal('pe-group', part.group);
    setVal('pe-pivot', part.pivot || 'center');

    setSlider('pe-px', part.pos[0]);
    setSlider('pe-py', part.pos[1]);
    setSlider('pe-pz', part.pos[2]);
    setSlider('pe-rx', part.rot[0]);
    setSlider('pe-ry', part.rot[1]);
    setSlider('pe-rz', part.rot[2]);
    setSlider('pe-sx', part.scale[0]);
    setSlider('pe-sy', part.scale[1]);
    setSlider('pe-sz', part.scale[2]);
}

function setVal(id, val) {
    const el = document.getElementById(id);
    if (el) el.value = val;
}

function setSlider(id, val) {
    const el = document.getElementById(id);
    if (el) {
        el.value = val;
        const vEl = document.getElementById(id + '-v');
        if (vEl) vEl.textContent = typeof val === 'number' ? val.toFixed(2) : val;
    }
}

// --- Part editor event bindings ---
function bindPartEditor() {
    const update = () => {
        const part = state.parts.find(p => p.id === state.selectedId);
        if (!part) return;

        part.name = document.getElementById('pe-name').value;
        part.shape = document.getElementById('pe-shape').value;
        part.color = document.getElementById('pe-color').value;
        document.getElementById('pe-color-hex').textContent = part.color;
        part.group = parseInt(document.getElementById('pe-group').value);
        part.pivot = document.getElementById('pe-pivot').value;

        part.pos[0] = parseFloat(document.getElementById('pe-px').value);
        part.pos[1] = parseFloat(document.getElementById('pe-py').value);
        part.pos[2] = parseFloat(document.getElementById('pe-pz').value);
        part.rot[0] = parseFloat(document.getElementById('pe-rx').value);
        part.rot[1] = parseFloat(document.getElementById('pe-ry').value);
        part.rot[2] = parseFloat(document.getElementById('pe-rz').value);
        part.scale[0] = parseFloat(document.getElementById('pe-sx').value);
        part.scale[1] = parseFloat(document.getElementById('pe-sy').value);
        part.scale[2] = parseFloat(document.getElementById('pe-sz').value);

        // Update display values
        ['pe-px','pe-py','pe-pz','pe-rx','pe-ry','pe-rz','pe-sx','pe-sy','pe-sz'].forEach(id => {
            const v = document.getElementById(id + '-v');
            if (v) v.textContent = parseFloat(document.getElementById(id).value).toFixed(2);
        });

        updatePartMesh(part);
        updateTraitVisuals();
    
        rebuildInstances();
        updatePartListUI();
        document.getElementById('edit-part-name').textContent = part.name;
    };

    // Bind all inputs in part editor
    ['pe-name','pe-shape','pe-color','pe-group','pe-pivot'].forEach(id => {
        document.getElementById(id).addEventListener('input', update);
    });
    ['pe-px','pe-py','pe-pz','pe-rx','pe-ry','pe-rz','pe-sx','pe-sy','pe-sz'].forEach(id => {
        document.getElementById(id).addEventListener('input', update);
    });
}
bindPartEditor();

// --- Add/Delete/Duplicate/Mirror ---
document.getElementById('btn-add-part').addEventListener('click', () => {
    const newPart = {
        id: nextPartId++,
        name: 'Part ' + state.parts.length,
        shape: 'box',
        pos: [0, 0.5, 0],
        rot: [0, 0, 0],
        scale: [0.2, 0.2, 0.2],
        color: '#888888',
        group: 0,
        pivot: 'center'
    };
    state.parts.push(newPart);
    addPartMesh(newPart);

    selectPart(newPart.id);
    updatePartListUI();
    rebuildInstances();
});

document.getElementById('btn-del-part').addEventListener('click', () => {
    if (state.selectedId === null) return;
    const idx = state.parts.findIndex(p => p.id === state.selectedId);
    if (idx === -1) return;
    state.parts.splice(idx, 1);
    const entry = partMeshes.get(state.selectedId);
    if (entry) creatureGroup.remove(entry.mesh);
    partMeshes.delete(state.selectedId);
    state.selectedId = null;
    updatePartListUI();
    updatePartEditor();

    rebuildInstances();
});

document.getElementById('btn-dup-part').addEventListener('click', () => {
    const part = state.parts.find(p => p.id === state.selectedId);
    if (!part) return;
    const dup = {
        ...part,
        id: nextPartId++,
        name: part.name + ' Copy',
        pos: [...part.pos],
        rot: [...part.rot],
        scale: [...part.scale],
        pivot: part.pivot || 'center'
    };
    dup.pos[0] += 0.2;
    state.parts.push(dup);
    addPartMesh(dup);

    selectPart(dup.id);
    updatePartListUI();
    rebuildInstances();
});

document.getElementById('btn-mirror-part').addEventListener('click', () => {
    const part = state.parts.find(p => p.id === state.selectedId);
    if (!part) return;
    // Mirror pivot: left↔right, top/bottom/center stay
    const pivotMirror = { left: 'right', right: 'left' };
    const mirrorPivot = pivotMirror[part.pivot] || part.pivot || 'center';
    const mirror = {
        ...part,
        id: nextPartId++,
        name: part.name + ' (M)',
        pos: [-part.pos[0], part.pos[1], part.pos[2]],
        rot: [part.rot[0], -part.rot[1], -part.rot[2]],
        scale: [...part.scale],
        pivot: mirrorPivot,
        // Auto-assign mirror body group (2↔3, 4↔5, 6↔7)
        group: part.group % 2 === 0 ? part.group + 1 : part.group - 1
    };
    if (mirror.group < 0) mirror.group = 0;
    if (mirror.group > 7) mirror.group = 7;
    state.parts.push(mirror);
    addPartMesh(mirror);

    selectPart(mirror.id);
    updatePartListUI();
    rebuildInstances();
});

// --- Trait sliders ---
function bindTraitSliders() {
    const ids = [
        ['tr-size', 'size'], ['tr-speed', 'speed'],
        ['tr-tough', 'toughness'], ['tr-aggro', 'aggression']
    ];
    ids.forEach(([id, key]) => {
        document.getElementById(id).addEventListener('input', e => {
            state.traits[key] = parseFloat(e.target.value);
            document.getElementById(id + '-v').textContent = parseFloat(e.target.value).toFixed(2);
            updateTraitVisuals();
            rebuildInstances();
        });
    });

    // Game params
    const params = [
        ['tr-basesize', 'baseSize'], ['tr-basespeed', 'baseSpeed'],
        ['tr-basehealth', 'baseHealth'], ['tr-atkrange', 'attackRange']
    ];
    params.forEach(([id, key]) => {
        document.getElementById(id).addEventListener('input', e => {
            state.gameParams[key] = parseFloat(e.target.value);
            document.getElementById(id + '-v').textContent = parseFloat(e.target.value).toFixed(1);
            updateTraitVisuals();
            rebuildInstances();
        });
    });
}
bindTraitSliders();

// --- Animation sliders ---
function bindAnimSliders() {
    const map = [
        ['an-speed', 'speed'], ['an-bob-amp', 'bobAmp'], ['an-bob-freq', 'bobFreq'],
        ['an-sway-amp', 'swayAmp'], ['an-sway-freq', 'swayFreq'],
        ['an-leg-amp', 'legAmp'], ['an-leg-freq', 'legFreq'],
        ['an-arm-amp', 'armAmp'], ['an-head-amp', 'headAmp'],
        ['an-extra-amp', 'extraAmp'], ['an-extra-freq', 'extraFreq'],
        ['an-breathe', 'breathe']
    ];
    map.forEach(([id, key]) => {
        document.getElementById(id).addEventListener('input', e => {
            state.anim[key] = parseFloat(e.target.value);
            document.getElementById(id + '-v').textContent = parseFloat(e.target.value).toFixed(2);
        });
    });

    document.getElementById('btn-anim-play').addEventListener('click', () => { state.anim.playing = true; });
    document.getElementById('btn-anim-pause').addEventListener('click', () => { state.anim.playing = false; });
    document.getElementById('btn-anim-reset').addEventListener('click', () => {
        state.anim.time = 0;
        state.anim.playing = false;
        // Reset to base transforms + toughness visuals
        updateTraitVisuals();
        for (const part of state.parts) {
            const entry = partMeshes.get(part.id);
            if (entry) applyPartTransform(entry.mesh, part);
        }
    });
}
bindAnimSliders();

// --- Preview mode ---
document.querySelectorAll('.preview-toggle .btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.preview-toggle .btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.preview.mode = btn.dataset.mode;
        rebuildInstances();
    });
});

document.getElementById('btn-randomize').addEventListener('click', () => {
    rebuildInstances();
});

['pv-sizevar', 'pv-colorvar', 'pv-spacing'].forEach(id => {
    document.getElementById(id).addEventListener('input', e => {
        const key = { 'pv-sizevar': 'sizeVar', 'pv-colorvar': 'colorVar', 'pv-spacing': 'spacing' }[id];
        state.preview[key] = parseFloat(e.target.value);
        document.getElementById(id + '-v').textContent = parseFloat(e.target.value).toFixed(2);
        rebuildInstances();
    });
});

// --- Display toggles ---
document.getElementById('pv-grid').addEventListener('change', e => {
    state.display.grid = e.target.checked;
    gridHelper.visible = e.target.checked;
});
document.getElementById('pv-axes').addEventListener('change', e => {
    state.display.axes = e.target.checked;
    axesHelper.visible = e.target.checked;
});
document.getElementById('pv-wireframe').addEventListener('change', e => {
    state.display.wireframe = e.target.checked;
    for (const part of state.parts) updatePartMesh(part);
    rebuildInstances();
});
document.getElementById('pv-shadows').addEventListener('change', e => {
    state.display.shadows = e.target.checked;
    renderer.shadowMap.enabled = e.target.checked;
    for (const [, entry] of partMeshes) entry.mesh.castShadow = e.target.checked;
});
document.getElementById('pv-bgcolor').addEventListener('input', e => {
    const c = new THREE.Color(e.target.value);
    renderer.setClearColor(c);
    scene.fog.color.copy(c);
});

// --- JSON import/export ---
document.getElementById('btn-export-json').addEventListener('click', () => {
    const data = {
        name: document.querySelector('.preset-btn.active')?.dataset.preset || 'custom',
        parts: state.parts.map(p => ({
            name: p.name, shape: p.shape, pos: p.pos, rot: p.rot,
            scale: p.scale, color: p.color, group: p.group, pivot: p.pivot || 'center'
        })),
        traits: { ...state.traits },
        gameParams: { ...state.gameParams },
        anim: { ...state.anim }
    };
    document.getElementById('json-io').value = JSON.stringify(data, null, 2);
});

document.getElementById('btn-import-json').addEventListener('click', () => {
    try {
        const data = JSON.parse(document.getElementById('json-io').value);
        if (data.parts) {
            state.parts = data.parts.map(p => ({ ...p, id: nextPartId++, pos: [...p.pos], rot: [...p.rot], scale: [...p.scale], pivot: p.pivot || 'center' }));
        }
        if (data.traits) Object.assign(state.traits, data.traits);
        if (data.gameParams) Object.assign(state.gameParams, data.gameParams);
        if (data.anim) Object.assign(state.anim, data.anim);
        state.selectedId = null;
        rebuildCreature();
    
        updatePartListUI();
        updatePartEditor();
        // Sync trait sliders
        setSlider('tr-size', state.traits.size);
        setSlider('tr-speed', state.traits.speed);
        setSlider('tr-tough', state.traits.toughness);
        setSlider('tr-aggro', state.traits.aggression);
        // Sync game param sliders
        setSlider('tr-basesize', state.gameParams.baseSize);
        setSlider('tr-basespeed', state.gameParams.baseSpeed);
        setSlider('tr-basehealth', state.gameParams.baseHealth);
        setSlider('tr-atkrange', state.gameParams.attackRange);
        // Sync animation sliders
        setSlider('an-speed', state.anim.speed);
        setSlider('an-bob-amp', state.anim.bobAmp);
        setSlider('an-bob-freq', state.anim.bobFreq);
        setSlider('an-sway-amp', state.anim.swayAmp);
        setSlider('an-sway-freq', state.anim.swayFreq);
        setSlider('an-leg-amp', state.anim.legAmp);
        setSlider('an-leg-freq', state.anim.legFreq);
        setSlider('an-arm-amp', state.anim.armAmp);
        setSlider('an-head-amp', state.anim.headAmp);
        setSlider('an-extra-amp', state.anim.extraAmp);
        setSlider('an-extra-freq', state.anim.extraFreq);
        setSlider('an-breathe', state.anim.breathe);
    } catch (e) {
        alert('Invalid JSON: ' + e.message);
    }
});

// ================================================================
//  CODE GENERATION
// ================================================================
function generateGeometryCode() {
    let code = `// ============================================================\n`;
    code += `// ENEMY GEOMETRY - Generated by Enemy Designer\n`;
    code += `// ============================================================\n`;
    code += `function createEnemyGeometry() {\n`;
    code += `  const geos = [];\n\n`;

    for (const part of state.parts) {
        const pivot = part.pivot || 'center';
        const piv = getPivotOffset(pivot);
        code += `  // ${part.name} (group: ${part.group}, pivot: ${pivot})\n`;
        code += `  {\n`;
        code += `    const g = ${geoExportString(part.shape)};\n`;
        if (piv[0] || piv[1] || piv[2]) {
            code += `    g.translate(${piv[0].toFixed(1)}, ${piv[1].toFixed(1)}, ${piv[2].toFixed(1)}); // pivot: ${pivot}\n`;
        }
        code += `    g.scale(${(part.scale[0]*2).toFixed(3)}, ${(part.scale[1]*2).toFixed(3)}, ${(part.scale[2]*2).toFixed(3)});\n`;
        if (part.rot[0] || part.rot[1] || part.rot[2]) {
            code += `    const e = new THREE.Euler(${(part.rot[0]*Math.PI/180).toFixed(4)}, ${(part.rot[1]*Math.PI/180).toFixed(4)}, ${(part.rot[2]*Math.PI/180).toFixed(4)});\n`;
            code += `    g.applyQuaternion(new THREE.Quaternion().setFromEuler(e));\n`;
        }
        code += `    g.translate(${part.pos[0].toFixed(3)}, ${part.pos[1].toFixed(3)}, ${part.pos[2].toFixed(3)});\n`;
        code += `    // Tag vertices with body group\n`;
        code += `    const n = g.attributes.position.count;\n`;
        code += `    g.setAttribute('partGroup', new THREE.BufferAttribute(new Float32Array(n).fill(${part.group}), 1));\n`;
        code += `    geos.push(g);\n`;
        code += `  }\n\n`;
    }

    code += `  return mergeGeometries(geos, false);\n`;
    code += `}\n`;
    return code;
}

function generateMaterialCode() {
    const a = state.anim;
    let code = `// ============================================================\n`;
    code += `// ENEMY MATERIAL TSL - Generated by Enemy Designer\n`;
    code += `// Replace geometry + material section in buildMesh()\n`;
    code += `// ============================================================\n\n`;
    code += `// --- Use composed geometry instead of BoxGeometry ---\n`;
    code += `const baseGeo = createEnemyGeometry();\n`;
    code += `const instancedGeo = new THREE.InstancedBufferGeometry();\n`;
    code += `instancedGeo.index = baseGeo.index;\n`;
    code += `for (const key in baseGeo.attributes) {\n`;
    code += `  instancedGeo.setAttribute(key, baseGeo.attributes[key]);\n`;
    code += `}\n`;
    code += `instancedGeo.instanceCount = ENEMY_COUNT;\n\n`;

    code += `const material = new THREE.MeshLambertMaterial();\n`;
    code += `const instPos = this.positions.element(instanceIndex);\n`;
    code += `const instState = this.states.element(instanceIndex);\n`;
    code += `const instTrait = this.traits.element(instanceIndex);\n`;
    code += `const isAlive = step(float(0.01), instState.x);\n\n`;

    code += `// --- Per-vertex body group (from merged geometry attribute) ---\n`;
    code += `// const partGroup = attribute('partGroup', 'float');\n\n`;

    code += `// Distance cull\n`;
    code += `const toCam = instPos.sub(this.cameraPosU);\n`;
    code += `const distSq = toCam.dot(toCam);\n`;
    code += `const inRange = step(distSq, this.cullDistU.mul(this.cullDistU));\n\n`;

    code += `// Non-uniform scaling: per-enemy size trait\n`;
    code += `const sizeTrait = instTrait.x;\n`;
    code += `const scaleW = sizeTrait.mul(float(0.8).add(hash(instanceIndex.add(40)).mul(0.4)));\n`;
    code += `const scaleH = sizeTrait.mul(float(0.8).add(hash(instanceIndex.add(41)).mul(0.6)));\n`;
    code += `const scaleD = sizeTrait.mul(float(0.8).add(hash(instanceIndex.add(42)).mul(0.4)));\n`;
    code += `const aliveScaleVec = vec3(\n`;
    code += `  this.enemySizeU.mul(scaleW),\n`;
    code += `  this.enemySizeU.mul(scaleH),\n`;
    code += `  this.enemySizeU.mul(scaleD)\n`;
    code += `);\n`;
    code += `const deadScaleVec = aliveScaleVec.mul(0.2);\n`;
    code += `const finalScale = inRange.mul(mix(deadScaleVec, aliveScaleVec, isAlive));\n\n`;

    code += `// --- ANIMATION (vertex-level, per body group) ---\n`;
    code += `// Uncomment and adapt if using partGroup attribute:\n`;
    code += `// const phase = hash(instanceIndex).mul(${(Math.PI * 2).toFixed(4)});\n`;
    code += `// const walkT = time.mul(${a.legFreq.toFixed(1)}).add(phase);\n`;
    code += `// Body bob (group 0)\n`;
    code += `// const bodyBob = sin(walkT.mul(${a.bobFreq.toFixed(1)})).mul(${a.bobAmp.toFixed(3)});\n`;
    code += `// Leg swing (groups 4,5)\n`;
    code += `// const legSwing = sin(walkT).mul(${a.legAmp.toFixed(2)});\n`;
    code += `// Arm swing (groups 2,3)\n`;
    code += `// const armSwing = sin(walkT).mul(${a.armAmp.toFixed(2)});\n\n`;

    code += `material.positionNode = vec3(\n`;
    code += `  positionLocal.x.mul(finalScale.x),\n`;
    code += `  positionLocal.y.mul(finalScale.y),\n`;
    code += `  positionLocal.z.mul(finalScale.z)\n`;
    code += `).add(instPos);\n\n`;

    code += `// Trait-driven color (same formula as original)\n`;
    code += `const tSpeed = instTrait.y.div(2.0).clamp(0, 1);\n`;
    code += `const tTough = instTrait.z.div(2.0).clamp(0, 1);\n`;
    code += `const tAggro = instTrait.w;\n`;
    code += `const colSpeed = mix(vec3(0.3, 0.5, 0.7), vec3(0.65, 0.25, 0.85), tSpeed);\n`;
    code += `const colTough = mix(vec3(0.55, 0.45, 0.3), vec3(0.2, 0.65, 0.25), tTough);\n`;
    code += `const colAggro = mix(vec3(0.5, 0.5, 0.5), vec3(0.85, 0.25, 0.2), tAggro);\n`;
    code += `const traitBase = colSpeed.mul(0.4).add(colTough.mul(0.4)).add(colAggro.mul(0.2));\n\n`;
    code += `const healthPct = instState.x.div(instState.z.max(1)).clamp(0, 1);\n`;
    code += `const healthTint = mix(vec3(0.9, 0.15, 0.1), vec3(1, 1, 1), healthPct);\n`;
    code += `const aliveColor = traitBase.mul(healthTint);\n`;
    code += `const flashAmt = clamp(instState.w.mul(10), 0, 1);\n`;
    code += `const aliveColorFlashed = mix(aliveColor, vec3(1, 1, 1), flashAmt);\n`;
    code += `const deadColor = vec3(0.22, 0.22, 0.22);\n`;
    code += `material.colorNode = mix(deadColor, aliveColorFlashed, isAlive);\n`;

    return code;
}

function generateFullCode() {
    let code = generateGeometryCode();
    code += `\n\n`;
    code += generateMaterialCode();
    code += `\n\n`;
    code += `// ============================================================\n`;
    code += `// GAME CONFIG (recommended values from designer)\n`;
    code += `// ============================================================\n`;
    code += `// enemies: {\n`;
    code += `//   speed: ${state.gameParams.baseSpeed},\n`;
    code += `//   health: ${state.gameParams.baseHealth},\n`;
    code += `//   size: ${state.gameParams.baseSize},\n`;
    code += `//   attackRange: ${state.gameParams.attackRange},\n`;
    code += `// }\n`;
    return code;
}

document.getElementById('btn-gen-geometry').addEventListener('click', () => {
    document.getElementById('code-output').textContent = generateGeometryCode();
});
document.getElementById('btn-gen-material').addEventListener('click', () => {
    document.getElementById('code-output').textContent = generateMaterialCode();
});
document.getElementById('btn-gen-full').addEventListener('click', () => {
    document.getElementById('code-output').textContent = generateFullCode();
});
document.getElementById('btn-copy-code').addEventListener('click', () => {
    const code = document.getElementById('code-output').textContent;
    navigator.clipboard.writeText(code).then(() => {
        const btn = document.getElementById('btn-copy-code');
        btn.textContent = 'COPIED!';
        btn.style.color = '#4e4';
        setTimeout(() => { btn.textContent = 'COPY TO CLIPBOARD'; btn.style.color = ''; }, 1500);
    });
});

// ================================================================
//  SAVE & EXPORT ALL CREATURES
// ================================================================
document.getElementById('btn-save-preset').addEventListener('click', () => {
    saveCurrentToPreset();
    const btn = document.getElementById('btn-save-preset');
    btn.textContent = 'SAVED!';
    btn.style.color = '#4e4';
    setTimeout(() => { btn.textContent = 'SAVE'; btn.style.color = ''; }, 1200);
});

document.getElementById('btn-export-all').addEventListener('click', () => {
    // Auto-save current creature first
    saveCurrentToPreset();
    const fileContent = generateCreaturesFile();
    downloadFile('creatures.js', fileContent, 'text/javascript');
});

function downloadFile(filename, content, type) {
    const blob = new Blob([content], { type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function generateCreaturesFile() {
    const timestamp = new Date().toISOString().slice(0, 19).replace('T', ' ');
    const typeCount = Object.keys(savedCreatures).length;
    const typeNames = Object.keys(savedCreatures).join(', ');

    let f = '';
    f += `// ============================================================\n`;
    f += `// creatures.js — MILLION2ONE Enemy Creature Definitions\n`;
    f += `// Generated: ${timestamp}\n`;
    f += `// Types: ${typeCount} (${typeNames})\n`;
    f += `//\n`;
    f += `// INTEGRATION (two options):\n`;
    f += `//\n`;
    f += `// OPTION A — Regular script (load before module, uses init):\n`;
    f += `//   1. Place this file next to index.html\n`;
    f += `//   2. Add before the <script type="module"> tag:\n`;
    f += `//        <script src="creatures.js"><\\/script>\n`;
    f += `//   3. At the top of your module, call:\n`;
    f += `//        CREATURES.init(THREE);\n`;
    f += `//   4. In GPUEnemySystem.buildMesh(), replace:\n`;
    f += `//        const baseGeo = new THREE.BoxGeometry(1, 1.2, 1);\n`;
    f += `//      with:\n`;
    f += `//        const baseGeo = CREATURES.buildGeometry('grunt');\n`;
    f += `//\n`;
    f += `// OPTION B — Paste directly into index.html module:\n`;
    f += `//   1. Copy the CREATURES block into your module script\n`;
    f += `//   2. Call CREATURES.init(THREE); once after import\n`;
    f += `//   3. Use CREATURES.buildGeometry('grunt') etc.\n`;
    f += `//\n`;
    f += `// API:\n`;
    f += `//   CREATURES.init(THREE)        — bind Three.js (call once)\n`;
    f += `//   CREATURES.types              — ['grunt','brute',...]\n`;
    f += `//   CREATURES.buildGeometry(n)   — merged BufferGeometry\n`;
    f += `//   CREATURES.getParams(n)       — { baseSize, baseSpeed, ... }\n`;
    f += `//   CREATURES.getAnim(n)         — { bobAmp, legFreq, ... }\n`;
    f += `//   CREATURES.randomType()       — random type name\n`;
    f += `//   CREATURES.defs               — raw definitions object\n`;
    f += `// ============================================================\n\n`;

    f += `const CREATURES = (function() {\n`;
    f += `  'use strict';\n\n`;

    f += `  // Three.js reference — set via init()\n`;
    f += `  let T = null;\n\n`;

    f += `  function init(THREE) {\n`;
    f += `    T = THREE;\n`;
    f += `  }\n\n`;

    // Shape factory
    f += `  // --- Shape factory ---\n`;
    f += `  function _shape(type) {\n`;
    f += `    switch (type) {\n`;
    f += `      case 'box':           return new T.BoxGeometry(1, 1, 1);\n`;
    f += `      case 'sphere':        return new T.SphereGeometry(0.5, 12, 8);\n`;
    f += `      case 'cylinder':      return new T.CylinderGeometry(0.5, 0.5, 1, 12);\n`;
    f += `      case 'cone':          return new T.ConeGeometry(0.5, 1, 12);\n`;
    f += `      case 'dodecahedron':  return new T.DodecahedronGeometry(0.5, 0);\n`;
    f += `      case 'tetrahedron':   return new T.TetrahedronGeometry(0.5, 0);\n`;
    f += `      case 'torus':         return new T.TorusGeometry(0.35, 0.15, 8, 16);\n`;
    f += `      case 'octahedron':    return new T.OctahedronGeometry(0.5, 0);\n`;
    f += `      default:              return new T.BoxGeometry(1, 1, 1);\n`;
    f += `    }\n`;
    f += `  }\n\n`;

    // Merge helper
    f += `  // --- Merge helper (standalone, no addons import needed) ---\n`;
    f += `  function _merge(geos) {\n`;
    f += `    if (geos.length === 0) return new T.BoxGeometry(1, 1.2, 1);\n`;
    f += `    if (geos.length === 1) return geos[0];\n`;
    f += `    const attrNames = Object.keys(geos[0].attributes);\n`;
    f += `    let totalVerts = 0, totalIdx = 0;\n`;
    f += `    for (const g of geos) {\n`;
    f += `      totalVerts += g.attributes.position.count;\n`;
    f += `      totalIdx += g.index ? g.index.count : g.attributes.position.count;\n`;
    f += `    }\n`;
    f += `    const merged = new T.BufferGeometry();\n`;
    f += `    const mergedAttrs = {};\n`;
    f += `    for (const name of attrNames) {\n`;
    f += `      const itemSize = geos[0].attributes[name].itemSize;\n`;
    f += `      mergedAttrs[name] = new Float32Array(totalVerts * itemSize);\n`;
    f += `    }\n`;
    f += `    const mergedIndex = new Uint32Array(totalIdx);\n`;
    f += `    let vOff = 0, iOff = 0;\n`;
    f += `    for (const g of geos) {\n`;
    f += `      const vCount = g.attributes.position.count;\n`;
    f += `      for (const name of attrNames) {\n`;
    f += `        const src = g.attributes[name];\n`;
    f += `        if (!src) continue;\n`;
    f += `        const is = src.itemSize;\n`;
    f += `        for (let i = 0; i < vCount * is; i++)\n`;
    f += `          mergedAttrs[name][vOff * is + i] = src.array[i];\n`;
    f += `      }\n`;
    f += `      if (g.index) {\n`;
    f += `        for (let i = 0; i < g.index.count; i++)\n`;
    f += `          mergedIndex[iOff + i] = g.index.array[i] + vOff;\n`;
    f += `        iOff += g.index.count;\n`;
    f += `      } else {\n`;
    f += `        for (let i = 0; i < vCount; i++)\n`;
    f += `          mergedIndex[iOff + i] = vOff + i;\n`;
    f += `        iOff += vCount;\n`;
    f += `      }\n`;
    f += `      vOff += vCount;\n`;
    f += `    }\n`;
    f += `    for (const name of attrNames) {\n`;
    f += `      const is = geos[0].attributes[name].itemSize;\n`;
    f += `      merged.setAttribute(name,\n`;
    f += `        new T.BufferAttribute(mergedAttrs[name], is));\n`;
    f += `    }\n`;
    f += `    merged.setIndex(new T.BufferAttribute(mergedIndex, 1));\n`;
    f += `    return merged;\n`;
    f += `  }\n\n`;

    // Creature definitions (the big data blob)
    f += `  // ============================================================\n`;
    f += `  //  CREATURE TYPE DEFINITIONS\n`;
    f += `  // ============================================================\n`;
    f += `  const defs = ${JSON.stringify(savedCreatures, null, 4)};\n\n`;

    f += `  const types = Object.keys(defs);\n\n`;

    // buildGeometry
    f += `  // ============================================================\n`;
    f += `  //  BUILD MERGED GEOMETRY FOR A CREATURE TYPE\n`;
    f += `  //  Returns a single BufferGeometry with 'partGroup' attribute\n`;
    f += `  //  ready for GPU instancing.\n`;
    f += `  // ============================================================\n`;
    f += `  function buildGeometry(typeName) {\n`;
    f += `    if (!T) throw new Error('CREATURES: call init(THREE) first');\n`;
    f += `    const def = defs[typeName];\n`;
    f += `    if (!def) {\n`;
    f += `      console.warn('CREATURES: unknown type "' + typeName +\n`;
    f += `        '", falling back to box');\n`;
    f += `      return new T.BoxGeometry(1, 1.2, 1);\n`;
    f += `    }\n`;
    f += `    const pivotMap = {\n`;
    f += `      center:[0,0,0], top:[0,-0.5,0], bottom:[0,0.5,0],\n`;
    f += `      left:[0.5,0,0], right:[-0.5,0,0]\n`;
    f += `    };\n`;
    f += `    const geos = [];\n`;
    f += `    for (const part of def.parts) {\n`;
    f += `      const g = _shape(part.shape);\n`;
    f += `      const piv = pivotMap[part.pivot || 'center'] || [0,0,0];\n`;
    f += `      if (piv[0] || piv[1] || piv[2]) g.translate(piv[0], piv[1], piv[2]);\n`;
    f += `      g.scale(part.scale[0] * 2, part.scale[1] * 2, part.scale[2] * 2);\n`;
    f += `      if (part.rot[0] || part.rot[1] || part.rot[2]) {\n`;
    f += `        const e = new T.Euler(\n`;
    f += `          part.rot[0] * Math.PI / 180,\n`;
    f += `          part.rot[1] * Math.PI / 180,\n`;
    f += `          part.rot[2] * Math.PI / 180);\n`;
    f += `        g.applyQuaternion(new T.Quaternion().setFromEuler(e));\n`;
    f += `      }\n`;
    f += `      g.translate(part.pos[0], part.pos[1], part.pos[2]);\n`;
    f += `      const n = g.attributes.position.count;\n`;
    f += `      g.setAttribute('partGroup',\n`;
    f += `        new T.BufferAttribute(new Float32Array(n).fill(part.group), 1));\n`;
    f += `      geos.push(g);\n`;
    f += `    }\n`;
    f += `    return _merge(geos);\n`;
    f += `  }\n\n`;

    // Helpers
    f += `  function getParams(typeName) {\n`;
    f += `    return defs[typeName]?.gameParams ||\n`;
    f += `      { baseSize: 1.2, baseSpeed: 3.5, baseHealth: 100, attackRange: 3 };\n`;
    f += `  }\n\n`;

    f += `  function getAnim(typeName) {\n`;
    f += `    return defs[typeName]?.anim || {};\n`;
    f += `  }\n\n`;

    f += `  function randomType() {\n`;
    f += `    return types[Math.floor(Math.random() * types.length)];\n`;
    f += `  }\n\n`;

    // Public API
    f += `  // ============================================================\n`;
    f += `  //  PUBLIC API\n`;
    f += `  // ============================================================\n`;
    f += `  return {\n`;
    f += `    init,\n`;
    f += `    defs,\n`;
    f += `    types,\n`;
    f += `    buildGeometry,\n`;
    f += `    getParams,\n`;
    f += `    getAnim,\n`;
    f += `    randomType\n`;
    f += `  };\n`;
    f += `})();\n`;

    return f;
}

// ================================================================
//  RAYCASTING (click to select parts in viewport)
// ================================================================
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

renderer.domElement.addEventListener('click', (e) => {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const meshes = [];
    for (const [, entry] of partMeshes) meshes.push(entry.mesh);
    const intersects = raycaster.intersectObjects(meshes, false);

    if (intersects.length > 0) {
        const hit = intersects[0].object;
        const partId = hit.userData.partId;
        if (partId !== undefined) {
            selectPart(partId);
            // Switch to design tab
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector('.tab-btn[data-tab="design"]').classList.add('active');
            document.getElementById('tab-design').classList.add('active');
        }
    }
});

// ================================================================
//  RESIZE
// ================================================================
function onResize() {
    const w = vpEl.clientWidth;
    const h = vpEl.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
}
window.addEventListener('resize', onResize);

// ================================================================
//  RENDER LOOP
// ================================================================
let lastTime = performance.now();

function animate(now) {
    requestAnimationFrame(animate);
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;

    controls.update();
    animateCreature(dt);
    renderer.render(scene, camera);
}

// ================================================================
//  INIT
// ================================================================
onResize();
loadPreset('grunt');
updateSavedList();
requestAnimationFrame(animate);

</script>
</body>
</html>
