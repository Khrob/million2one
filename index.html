<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MILLION2ONE</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='4' fill='%23111'/%3E%3Ctext x='16' y='22' text-anchor='middle' font-family='monospace' font-weight='bold' font-size='12' fill='%23e8a030'%3EM2O%3C/text%3E%3C/svg%3E">
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'Share Tech Mono', 'Courier New', monospace; }
canvas { display: block; }
#blocker {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.75); display: flex; flex-direction: column;
    align-items: center; justify-content: center; z-index: 100; cursor: pointer;
}
#blocker h1 { color: #fff; font-size: 42px; margin-bottom: 12px; font-family: sans-serif; }
#blocker p { color: #999; font-size: 16px; font-family: sans-serif; }
#blocker .controls { color: #666; font-size: 13px; margin-top: 24px; line-height: 1.8; font-family: monospace; text-align: left; }
#hud { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
#crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; }
#crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255,255,255,0.8); }
#crosshair::before { width: 2px; height: 20px; left: 9px; top: 0; }
#crosshair::after { width: 20px; height: 2px; top: 9px; left: 0; }
#health-bar-container { position: absolute; bottom: 30px; left: 30px; width: 200px; height: 20px; background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.3); border-radius: 3px; }
#health-bar { height: 100%; background: linear-gradient(to right, #e44, #4e4); border-radius: 2px; transition: width 0.2s; }
#health-text { position: absolute; bottom: 54px; left: 30px; color: #fff; font-size: 13px; text-shadow: 0 0 4px #000; }
#ammo { position: absolute; bottom: 30px; right: 30px; color: #fff; font-size: 28px; text-shadow: 0 0 6px #000; }
#ammo span { font-size: 16px; color: #aaa; }
#alive-count { position: absolute; bottom: 60px; right: 30px; color: #ccc; font-size: 14px; text-shadow: 0 0 4px #000; text-align: right; transform-origin: right bottom; will-change: transform; }
#kill-count { position: absolute; top: 25%; left: 50%; transform: translateX(-50%); color: #fff; font-size: 64px; font-weight: 900; text-shadow: 0 0 10px rgba(0,0,0,0.9), 0 2px 20px rgba(0,0,0,0.5), 0 0 40px rgba(136,170,255,0.15); text-align: center; letter-spacing: 4px; white-space: nowrap; will-change: transform; transform-origin: center center; -webkit-mask-image: linear-gradient(to bottom, white 40%, transparent 100%); mask-image: linear-gradient(to bottom, white 40%, transparent 100%); }
#timer { position: absolute; bottom: 60px; left: 30px; color: #ccc; font-size: 18px; text-shadow: 0 0 4px #000; letter-spacing: 2px; }
#info { position: absolute; top: 16px; right: 16px; color: #fff; font-size: 13px; text-shadow: 0 0 4px #000; text-align: right; line-height: 1.6; }
/* Weapon parameter sliders */
/* Weapon parameter bars — 4 vertical bars stacked down left side */
#weapon-sliders { position: absolute; left: 12px; top: 5%; height: 85%; display: flex; flex-direction: column; gap: 4px; }
.wpn-slider { flex: 1; display: flex; flex-direction: column; align-items: center; }
.wpn-slider .label { font-size: 9px; color: #aaa; text-shadow: 0 0 4px #000; letter-spacing: 1px; text-transform: uppercase; margin-bottom: 3px; }
.wpn-slider .track { flex: 1; width: 50px; background: rgba(255,255,255,0.06); border-radius: 3px; position: relative; border: 1px solid rgba(255,255,255,0.06); overflow: hidden; }
.wpn-slider .fill { position: absolute; bottom: 0; width: 100%; border-radius: 2px; transition: height 0.1s; }
.wpn-slider .val { font-size: 10px; color: #888; text-shadow: 0 0 4px #000; margin-top: 3px; }
.wpn-slider.active .label { color: #fff; }
.wpn-slider.active .track { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.15); }
/* Heat bar — vertical, right side */
#heat-bar-container { position: absolute; right: 12px; top: 5%; width: 50px; height: 85%; background: rgba(255,255,255,0.06); border-radius: 4px; border: 1px solid rgba(255,255,255,0.08); }
#heat-bar { position: absolute; bottom: 0; width: 100%; border-radius: 3px; transition: height 0.1s, background 0.15s; }
#heat-label { position: absolute; right: 12px; top: calc(5% + 85% + 4px); font-size: 9px; color: #555; text-shadow: 0 0 4px #000; letter-spacing: 1px; text-align: center; width: 50px; }
#hit-flash { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,0,0,0.3); pointer-events: none; z-index: 9; opacity: 0; transition: opacity 0.1s; }
#damage-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 8; }
#debug {
    position: fixed; top: 0; left: 0; width: 380px; height: 100%;
    background: rgba(10,10,15,0.92); color: #ddd; font-size: 12px;
    overflow-y: auto; z-index: 95; display: none; padding: 0;
    border-right: 1px solid rgba(255,255,255,0.1);
}
#debug::-webkit-scrollbar { width: 6px; }
#debug::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
.debug-header { padding: 14px 16px; font-size: 15px; font-weight: bold; color: #fff; border-bottom: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.03); display: flex; justify-content: space-between; }
.debug-section { border-bottom: 1px solid rgba(255,255,255,0.05); }
.debug-section-title { padding: 10px 16px; font-size: 12px; font-weight: bold; color: #8af; cursor: pointer; display: flex; justify-content: space-between; text-transform: uppercase; letter-spacing: 1px; background: rgba(255,255,255,0.02); }
.debug-section-title:hover { background: rgba(255,255,255,0.05); }
.debug-section-content { padding: 4px 16px 12px; }
.debug-row { display: flex; align-items: center; gap: 8px; margin: 5px 0; }
.debug-row label { flex: 0 0 120px; color: #aaa; font-size: 11px; }
.debug-row input[type="range"] { flex: 1; height: 4px; -webkit-appearance: none; background: rgba(255,255,255,0.15); border-radius: 2px; outline: none; }
.debug-row input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%; background: #8af; cursor: pointer; }
.debug-row .val { flex: 0 0 55px; text-align: right; color: #8af; font-size: 11px; }
.debug-btn { padding: 6px 12px; margin: 4px 2px; background: rgba(136,170,255,0.15); color: #8af; border: 1px solid rgba(136,170,255,0.3); border-radius: 4px; cursor: pointer; font-family: monospace; font-size: 11px; }
.debug-btn:hover { background: rgba(136,170,255,0.25); }
.debug-stats { padding: 8px 16px; color: #888; font-size: 11px; line-height: 1.8; }
/* === Overlays (menu, pregame, gameover) === */
.overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 90; }
#menu-overlay { background: rgba(0,0,0,0.65); }
#menu-overlay .menu-title { color: #fff; font-size: 72px; font-weight: bold; letter-spacing: 8px; text-shadow: 0 0 30px rgba(136,170,255,0.4), 0 4px 8px rgba(0,0,0,0.8); margin-bottom: 8px; }
#menu-overlay .menu-subtitle { color: #8af; font-size: 13px; letter-spacing: 4px; margin-bottom: 50px; text-transform: uppercase; opacity: 0.7; }
.menu-btn { display: block; width: 260px; padding: 14px 0; margin: 6px auto; background: rgba(136,170,255,0.08); color: #8af; border: 1px solid rgba(136,170,255,0.25); border-radius: 4px; cursor: pointer; font-family: 'Share Tech Mono', monospace; font-size: 15px; letter-spacing: 2px; text-align: center; transition: all 0.15s; }
.menu-btn:hover { background: rgba(136,170,255,0.2); border-color: rgba(136,170,255,0.5); color: #fff; transform: scale(1.02); }
.menu-panel { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(10,10,20,0.95); border: 1px solid rgba(136,170,255,0.2); border-radius: 8px; padding: 30px 36px; min-width: 420px; max-height: 80vh; overflow-y: auto; }
.menu-panel h2 { color: #8af; font-size: 16px; margin-bottom: 16px; letter-spacing: 2px; text-transform: uppercase; }
.menu-panel .back-btn { margin-top: 20px; }
.menu-panel p { color: #aaa; font-size: 13px; line-height: 1.8; margin: 6px 0; }
.menu-panel .score-row { color: #ccc; } .menu-panel .score-row span { color: #8af; }
#pregame-overlay { background: rgba(0,0,0,0.25); }
.drop-text { color: #fff; font-size: 36px; letter-spacing: 4px; animation: pulse 1.5s ease-in-out infinite; }
.drop-sub { color: #8af; font-size: 13px; margin-top: 16px; letter-spacing: 2px; opacity: 0.7; }
@keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
#gameover-overlay { background: rgba(0,0,0,0.82); }
.go-title { color: #f44; font-size: 52px; letter-spacing: 4px; margin-bottom: 30px; text-shadow: 0 0 20px rgba(255,68,68,0.4); }
.go-remain { font-size: 44px; color: #fff; letter-spacing: 3px; margin-bottom: 6px; text-shadow: 0 0 24px rgba(136,170,255,0.3); text-align: center; }
.go-remain span { display: block; font-size: 14px; color: #8af; letter-spacing: 4px; margin-top: 4px; text-shadow: none; }
.go-bar { width: 280px; height: 6px; background: rgba(255,255,255,0.08); border-radius: 3px; margin: 16px auto; overflow: hidden; }
.go-bar-fill { height: 100%; background: linear-gradient(90deg, #8af, #68f); border-radius: 3px; transition: width 1.5s ease-out; }
.go-stats { color: #ccc; font-size: 15px; line-height: 2.4; margin-bottom: 20px; text-align: center; }
.go-stats span { color: #8af; }
.go-stat-line { color: #888; font-size: 13px; letter-spacing: 1px; margin-bottom: 28px; text-align: center; }
.go-stat-line span { color: #aaa; }
.go-share-btn { display: block; width: 280px; padding: 14px 0; margin: 0 auto 20px; background: rgba(68,220,170,0.1); color: #4da; border: 1px solid rgba(68,220,170,0.3); border-radius: 4px; cursor: pointer; font-family: 'Share Tech Mono', monospace; font-size: 14px; letter-spacing: 2px; text-align: center; transition: all 0.15s; }
.go-share-btn:hover { background: rgba(68,220,170,0.25); border-color: rgba(68,220,170,0.6); color: #fff; }
.go-share-btn.copied { background: rgba(68,220,170,0.2); color: #6fc; border-color: rgba(68,220,170,0.5); }
.go-buttons { display: flex; gap: 16px; }
.go-highscore { color: #fa4; font-size: 18px; letter-spacing: 3px; margin-bottom: 20px; text-align: center; text-shadow: 0 0 12px rgba(255,170,68,0.4); animation: go-wibble 0.8s ease-in-out infinite; display: none; }
@keyframes go-wibble { 0%,100% { transform: rotate(-2deg) scale(1); } 25% { transform: rotate(1.5deg) scale(1.05); } 50% { transform: rotate(-1deg) scale(1.02); } 75% { transform: rotate(2deg) scale(1.04); } }
/* "What is this?" panel (now a menu-panel) */
#whatis-panel p { color: #aaa; font-size: 12px; line-height: 1.8; margin: 8px 0; }
#whatis-panel .tag { display: inline-block; background: rgba(136,170,255,0.12); color: #8af; padding: 2px 8px; border-radius: 3px; font-size: 11px; margin: 0 2px; }
#whatis-panel .warn { color: #fa4; }
/* Death cause */
.go-death-cause { color: #f88; font-size: 14px; letter-spacing: 1px; margin-bottom: 16px; text-align: center; }
.go-death-cause span { color: #faa; }
/* Help tooltips */
.help-row { display: flex; align-items: flex-start; gap: 12px; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.04); }
.help-key { min-width: 110px; color: #8af; font-size: 13px; white-space: nowrap; }
.help-desc { color: #ccc; font-size: 13px; }
.help-detail { color: #777; font-size: 11px; margin-top: 2px; }
.help-section-title { color: #fa4; font-size: 12px; letter-spacing: 2px; margin: 16px 0 8px; text-transform: uppercase; }
/* Gun loadout line in share */
.go-loadout { color: #666; font-size: 12px; letter-spacing: 1px; margin-bottom: 8px; text-align: center; }
.go-loadout span { color: #fa4; }
/* === Loading Screen === */
#loading-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: #0a0a0f; display: flex; flex-direction: column;
    align-items: center; justify-content: center; z-index: 200;
    transition: opacity 0.8s ease-out;
}
#loading-screen.fade-out { opacity: 0; pointer-events: none; }
.load-title { color: #fff; font-size: 56px; font-weight: bold; letter-spacing: 6px; text-shadow: 0 0 30px rgba(136,170,255,0.3); margin-bottom: 6px; font-family: sans-serif; }
.load-version { color: rgba(136,170,255,0.3); font-size: 11px; letter-spacing: 3px; text-transform: uppercase; margin-bottom: 40px; }
.load-bar-outer { width: 240px; height: 2px; background: rgba(255,255,255,0.06); border-radius: 1px; overflow: hidden; margin-bottom: 14px; }
.load-bar-inner { height: 100%; width: 0%; background: #8af; border-radius: 1px; transition: width 0.4s ease-out; box-shadow: 0 0 6px rgba(136,170,255,0.3); }
.load-status { color: #444; font-size: 11px; letter-spacing: 1px; }
/* Capability check result on loading screen */
#capability-result { display: none; text-align: center; margin-top: 18px; max-width: 400px; }
.cap-gpu-name { color: #555; font-size: 10px; letter-spacing: 1px; margin-bottom: 6px; }
.cap-verdict { font-size: 13px; letter-spacing: 1px; margin-bottom: 8px; }
.cap-verdict.good { color: #4e4; }
.cap-verdict.caution { color: #fa4; }
.cap-verdict.unsupported { color: #f44; }
.cap-message { color: #666; font-size: 11px; line-height: 1.6; margin-bottom: 10px; }
.cap-continue-btn { padding: 8px 24px; background: rgba(255,170,68,0.12); color: #fa4; border: 1px solid rgba(255,170,68,0.3); border-radius: 4px; cursor: pointer; font-family: 'Share Tech Mono', monospace; font-size: 11px; letter-spacing: 1px; transition: all 0.15s; }
.cap-continue-btn:hover { background: rgba(255,170,68,0.25); color: #fff; }
/* === Version label === */
.version-label { color: rgba(136,170,255,0.3); font-size: 11px; letter-spacing: 3px; text-transform: uppercase; margin-top: -40px; margin-bottom: 50px; }
/* === Support === */
.support-banner { position: absolute; top: 20px; right: 20px; pointer-events: auto; }
.support-btn { background: rgba(255,170,68,0.15); color: #fa4; border: 1px solid rgba(255,170,68,0.35); border-radius: 4px; padding: 10px 18px; cursor: pointer; font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 2px; transition: all 0.15s; text-shadow: 0 0 8px rgba(255,170,68,0.3); }
.support-btn:hover { background: rgba(255,170,68,0.3); border-color: rgba(255,170,68,0.6); color: #fff; text-shadow: 0 0 12px rgba(255,170,68,0.5); }
#support-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 300; }
.modal-box { background: rgba(10,10,20,0.98); border: 1px solid rgba(136,170,255,0.2); border-radius: 8px; padding: 28px 32px; width: 500px; max-height: 80vh; overflow-y: auto; position: relative; }
.modal-box .close-x { position: absolute; top: 10px; right: 14px; background: none; border: none; color: #555; font-size: 22px; cursor: pointer; font-family: monospace; line-height: 1; }
.modal-box .close-x:hover { color: #fff; }
.modal-box h2 { color: #8af; font-size: 15px; margin-bottom: 18px; letter-spacing: 2px; text-transform: uppercase; }
.modal-tabs { display: flex; gap: 6px; margin-bottom: 18px; }
.modal-tab { flex: 1; padding: 9px; background: rgba(136,170,255,0.05); border: 1px solid rgba(136,170,255,0.12); border-radius: 4px; color: #8af; cursor: pointer; font-family: 'Share Tech Mono', monospace; font-size: 12px; text-align: center; letter-spacing: 1px; transition: all 0.15s; }
.modal-tab:hover { background: rgba(136,170,255,0.1); }
.modal-tab.active { background: rgba(136,170,255,0.12); border-color: rgba(136,170,255,0.35); color: #fff; }
.modal-panel { display: none; }
.modal-panel.active { display: block; }
.modal-panel textarea { width: 100%; height: 100px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.08); border-radius: 4px; color: #ccc; padding: 10px; font-family: 'Share Tech Mono', monospace; font-size: 12px; resize: vertical; margin-bottom: 10px; box-sizing: border-box; }
.modal-panel textarea:focus { outline: none; border-color: rgba(136,170,255,0.3); }
.modal-panel p { color: #888; font-size: 12px; line-height: 1.8; margin: 6px 0; }
.modal-panel a { color: #fa4; text-decoration: none; }
.modal-panel a:hover { color: #fff; text-decoration: underline; }
.modal-panel .kofi-frame { width: 100%; height: 55vh; border: none; border-radius: 4px; background: #0a0a0f; }
.modal-btn { padding: 8px 16px; background: rgba(136,170,255,0.08); color: #8af; border: 1px solid rgba(136,170,255,0.2); border-radius: 4px; cursor: pointer; font-family: 'Share Tech Mono', monospace; font-size: 11px; letter-spacing: 1px; transition: all 0.15s; margin-right: 6px; }
.modal-btn:hover { background: rgba(136,170,255,0.18); color: #fff; }
.feedback-sent { color: #4e4; font-size: 12px; display: none; margin-top: 8px; }
</style>
</head>
<body>
<div id="loading-screen">
    <div class="load-title">MILLION2ONE</div>
    <div class="load-version" id="load-version"></div>
    <div class="load-bar-outer"><div class="load-bar-inner" id="load-progress"></div></div>
    <div class="load-status" id="load-status-text">Initializing...</div>
    <div id="capability-result">
        <div class="cap-gpu-name" id="cap-gpu-name"></div>
        <div class="cap-verdict" id="cap-verdict"></div>
        <div class="cap-message" id="cap-message"></div>
        <button class="cap-continue-btn" id="cap-continue-btn" style="display:none">CONTINUE ANYWAY</button>
    </div>
</div>
<div id="blocker" style="display:none">
    <h1>PAUSED</h1>
    <p>Click to resume</p>
    <button id="exit-to-menu-btn" class="menu-btn" style="margin-top:24px;width:200px;pointer-events:auto">END RUN</button>
    <div class="controls">
        WASD - Move | SHIFT - Sprint | SPACE - Jump<br>
        MOUSE - Look | CLICK - Shoot | R - Vent heat<br>
        Hold 1/2/3/4 + Mouse - Tune gun | 7/8/9 - Presets<br>
        ~ - Debug | ESC - Pause
    </div>
    <button id="fullscreen-btn" class="menu-btn" style="margin-top:20px;width:200px;z-index:101;pointer-events:auto" onclick="event.stopPropagation();if(document.fullscreenElement)document.exitFullscreen();else document.documentElement.requestFullscreen()">FULLSCREEN</button>
</div>
<div id="hud">
    <div id="crosshair"></div>
    <div id="health-text">HEALTH</div>
    <div id="health-bar-container"><div id="health-bar" style="width:100%"></div></div>
    <div id="ammo" style="display:none"></div>
    <div id="alive-count"></div>
    <div id="kill-count">0</div>
    <div id="timer">00:00</div>
    <div id="info"></div>
    <div id="weapon-sliders">
        <div class="wpn-slider" data-param="spread"><span class="label">Spread</span><div class="track"><div class="fill" style="height:6%;background:#5599ff"></div></div><span class="val">0</span></div>
        <div class="wpn-slider" data-param="rate"><span class="label">Rate</span><div class="track"><div class="fill" style="height:50%;background:#44ddaa"></div></div><span class="val">0</span></div>
        <div class="wpn-slider" data-param="power"><span class="label">Power</span><div class="track"><div class="fill" style="height:50%;background:#ff8844"></div></div><span class="val">0</span></div>
        <div class="wpn-slider" data-param="speed"><span class="label">Speed</span><div class="track"><div class="fill" style="height:50%;background:#cc66ff"></div></div><span class="val">0</span></div>
    </div>
    <div id="heat-bar-container"><div id="heat-bar"></div></div>
    <div id="heat-label">HEAT</div>
</div>
<div id="hit-flash"></div>
<div id="damage-overlay"></div>
<div id="debug"></div>
<div id="menu-overlay" class="overlay"></div>
<div id="pregame-overlay" class="overlay"></div>
<div id="gameover-overlay" class="overlay"></div>
<div id="support-modal">
    <div class="modal-box">
        <button class="close-x" id="support-close">&times;</button>
        <h2>SUPPORT THIS GAME</h2>
        <div class="modal-tabs">
            <div class="modal-tab active" data-tab="donate">DONATE</div>
            <div class="modal-tab" data-tab="feedback">FEEDBACK</div>
        </div>
        <div class="modal-panel active" id="panel-donate">
            <p>MILLION2ONE is a passion project built for the love of the craft.</p>
            <p>If you enjoy it, consider fuelling development!</p>
            <div id="kofi-container" style="margin-top:16px">
                <iframe id="kofi-frame" class="kofi-frame" src="" title="Support on Ko-fi" style="display:none"></iframe>
                <div id="kofi-fallback">
                    <a href="#" id="kofi-link" target="_blank">Support on Ko-fi</a>
                    <p style="color:#555;font-size:11px;margin-top:6px">Configure KOFI_USERNAME in the source to enable embedded donations</p>
                </div>
            </div>
        </div>
        <div class="modal-panel" id="panel-feedback">
            <textarea id="feedback-text" placeholder="Tell us what you think, report bugs, suggest features..."></textarea>
            <div>
                <button class="modal-btn" id="btn-copy-feedback">COPY TO CLIPBOARD</button>
                <button class="modal-btn" id="btn-email-feedback">SEND VIA EMAIL</button>
            </div>
            <div class="feedback-sent" id="feedback-sent">Copied!</div>
        </div>
    </div>
</div>

<script type="importmap">
{
    "imports": {
        "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.webgpu.js",
        "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.tsl.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three/webgpu';
import {
    Fn, If, uniform, float, uint, int, vec2, vec3, vec4,
    instancedArray, instanceIndex, positionLocal,
    mix, step, clamp, floor, fract, hash, texture, time, pow,
    smoothstep, abs, sin, cos, dot, normalize, max, min, add, mul,
    uv
} from 'three/tsl';

// ============================================================
//  GAME CONFIG
// ============================================================
const VERSION = 'alpha 0.1';
const KOFI_USERNAME = 'million2one';  // Set your Ko-fi username (e.g. 'yourname')
const ANALYTICS_ID = 'G-4V75RP96FF'; // GA4 measurement ID
const FEEDBACK_EMAIL = 'khrob@tangoedit.com';
// Base64 terrain config from #terrain editor
const TERRAIN_CONFIG = 'eyJ0ZXJyYWluIjp7InNlZWQiOjkyMCwib2N0YXZlcyI6OCwiZnJlcXVlbmN5IjowLjAwMTksImFtcGxpdHVkZSI6MTIwLCJsYWN1bmFyaXR5Ijo0LCJwZXJzaXN0ZW5jZSI6MC4xLCJvZmZzZXQiOjksInJlc29sdXRpb24iOjUxMn0sIndvcmxkIjp7InNpemUiOjMwMDB9fQ==';

// ============================================================
//  ANALYTICS (Google Analytics 4)
// ============================================================
class Analytics {
    constructor() {
        this.enabled = !!(ANALYTICS_ID && ANALYTICS_ID.startsWith('G-'));
        if (this.enabled) {
            const s = document.createElement('script');
            s.async = true;
            s.src = `https://www.googletagmanager.com/gtag/js?id=${ANALYTICS_ID}`;
            document.head.appendChild(s);
            window.dataLayer = window.dataLayer || [];
            window.gtag = function() { dataLayer.push(arguments); };
            gtag('js', new Date());
            gtag('config', ANALYTICS_ID);
        }
    }
    event(name, params = {}) {
        if (!this.enabled) return;
        try { gtag('event', name, params); } catch(e) {}
    }
}
const analytics = new Analytics();

// ============================================================
//  LOADING SCREEN
// ============================================================
function updateLoadProgress(pct, text) {
    const bar = document.getElementById('load-progress');
    const status = document.getElementById('load-status-text');
    if (bar) bar.style.width = pct + '%';
    if (status) status.textContent = text;
}
document.getElementById('load-version').textContent = VERSION;

// ============================================================
//  SUPPORT MODAL
// ============================================================
function initSupportModal() {
    const modal = document.getElementById('support-modal');
    document.getElementById('support-close').onclick = () => modal.style.display = 'none';
    modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
    // Tabs
    document.querySelectorAll('.modal-tab').forEach(tab => {
        tab.onclick = () => {
            document.querySelectorAll('.modal-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.modal-panel').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById('panel-' + tab.dataset.tab).classList.add('active');
        };
    });
    // Ko-fi link
    if (KOFI_USERNAME) {
        document.getElementById('kofi-link').href = `https://ko-fi.com/${KOFI_USERNAME}`;
        document.getElementById('kofi-fallback').innerHTML =
            `<a href="https://ko-fi.com/${KOFI_USERNAME}" target="_blank">Open Ko-fi in a new tab</a>`;
    }
    // Feedback
    document.getElementById('btn-copy-feedback').onclick = () => {
        const text = document.getElementById('feedback-text').value;
        if (!text) return;
        navigator.clipboard.writeText(text).then(() => {
            const el = document.getElementById('feedback-sent');
            el.style.display = 'block';
            setTimeout(() => el.style.display = 'none', 2000);
        });
    };
    document.getElementById('btn-email-feedback').onclick = () => {
        const text = document.getElementById('feedback-text').value;
        const subject = encodeURIComponent('MILLION2ONE Feedback');
        const body = encodeURIComponent(text || '');
        window.open(`mailto:${FEEDBACK_EMAIL}?subject=${subject}&body=${body}`);
    };
}
function openSupportModal() {
    const modal = document.getElementById('support-modal');
    modal.style.display = 'flex';
    analytics.event('support_modal_opened');
    // Load Ko-fi iframe on first open
    if (KOFI_USERNAME) {
        const frame = document.getElementById('kofi-frame');
        if (frame && !frame.src.includes('ko-fi')) {
            frame.src = `https://ko-fi.com/${KOFI_USERNAME}?hidefeed=true&widget=true&embed=true`;
            frame.style.display = 'block';
            document.getElementById('kofi-fallback').style.display = 'none';
        }
    }
}
initSupportModal();

// ============================================================
//  SIMPLEX NOISE
// ============================================================
class SimplexNoise {
    constructor(seed = 42) {
        const p = new Uint8Array(256);
        for (let i = 0; i < 256; i++) p[i] = i;
        let s = seed;
        for (let i = 255; i > 0; i--) {
            s = (s * 16807 + 1) % 2147483647;
            const j = s % (i + 1);
            [p[i], p[j]] = [p[j], p[i]];
        }
        this.perm = new Uint8Array(512);
        this.perm12 = new Uint8Array(512);
        for (let i = 0; i < 512; i++) {
            this.perm[i] = p[i & 255];
            this.perm12[i] = this.perm[i] % 12;
        }
    }
    noise2D(x, y) {
        const G = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
        const F2 = 0.36602540378, G2 = 0.21132486540;
        const s = (x + y) * F2;
        const i = Math.floor(x + s), j = Math.floor(y + s);
        const t = (i + j) * G2;
        const x0 = x - (i - t), y0 = y - (j - t);
        const i1 = x0 > y0 ? 1 : 0, j1 = x0 > y0 ? 0 : 1;
        const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
        const x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
        const ii = i & 255, jj = j & 255;
        let n0 = 0, n1 = 0, n2 = 0;
        let t0 = 0.5 - x0*x0 - y0*y0;
        if (t0 > 0) { t0 *= t0; const g = G[this.perm12[ii + this.perm[jj]]]; n0 = t0*t0*(g[0]*x0+g[1]*y0); }
        let t1 = 0.5 - x1*x1 - y1*y1;
        if (t1 > 0) { t1 *= t1; const g = G[this.perm12[ii+i1+this.perm[jj+j1]]]; n1 = t1*t1*(g[0]*x1+g[1]*y1); }
        let t2 = 0.5 - x2*x2 - y2*y2;
        if (t2 > 0) { t2 *= t2; const g = G[this.perm12[ii+1+this.perm[jj+1]]]; n2 = t2*t2*(g[0]*x2+g[1]*y2); }
        return 70 * (n0 + n1 + n2);
    }
}

// ============================================================
//  CONFIG
// ============================================================
const ENEMY_COUNT_OPTIONS = [10000, 100000, 250000, 500000, 750000, 1048576];
const ENEMY_COUNT_LABELS = ['10K', '100K', '250K', '500K', '750K', '1M'];
let ENEMY_COUNT = (() => {
    try {
        const stored = parseInt(localStorage.getItem('m2o_enemyCount'));
        if (ENEMY_COUNT_OPTIONS.includes(stored)) return stored;
    } catch(e) {}
    return 1048576; // default ~1 million
})();
function fmtEnemyCount(n) {
    if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
    if (n >= 1000) return Math.round(n / 1000) + 'K';
    return n.toString();
}

// Weapon sandbox mode: #weapon in URL → small smooth world, no enemies, tuning UI
const WEAPON_SANDBOX = window.location.hash.includes('weapon');
if (WEAPON_SANDBOX) ENEMY_COUNT = 1; // minimal GPU allocation, no real enemies

const CFG = {
    terrain: WEAPON_SANDBOX
        ? { seed: 42, octaves: 2, frequency: 0.0015, amplitude: 12, lacunarity: 2.0, persistence: 0.35, offset: 4, resolution: 256 }
        : { seed: 1135, octaves: 6, frequency: 0.003, amplitude: 50, lacunarity: 2.1, persistence: 0.48, offset: 25, resolution: 2048 },
    player: { walkSpeed: 8, sprintMult: 1.8, jumpForce: 12, gravity: 28, height: 3.6, slopeEffect: 0.7, maxHealth: 100 },
    enemies: { speed: 1.75, health: 33, damage: 8, attackRange: 3, attackRate: 1.0, size: 1.2, cullDistance: 1500, flowInfluence: 0.3 },
    weapon: { damage: 200, fireRate: 5, range: 500, maxAmmo: 30, spread: 0.015, hitRadius: 1.8, convergeDist: 60, barrelX: 0.2, barrelY: -0.14, barrelZ: -0.65 },
    heat: { maxHeat: 100, coolRate: 5, spreadCost: 0.3, rateCost: 1.5, powerCost: 1.2, speedCost: 0.8, ventRate: 33.3, thrustMult: 1.5, warningThreshold: 80 },
    handedness: 'left',  // 'left' = gun on left side (southpaw), 'right' = gun on right side
    pickups: { healthAmount: 50, ammoAmount: 15, bobSpeed: 2, bobHeight: 0.3, dropChance: 0.006, dropLifetime: 20 },
    lighting: { sunIntensity: 1.8, sunX: 0.5, sunY: 1.0, sunZ: 0.3, ambientIntensity: 0.45,
               fogNear: WEAPON_SANDBOX ? 200 : 400, fogFar: WEAPON_SANDBOX ? 500 : 1200, fogColor: '#adb8c7' },
    world: { size: WEAPON_SANDBOX ? 800 : 10000 },
    flowMap: { resolution: 64, updateInterval: 0.25 },
    particles: { poolSize: 2097152, muzzleCount: 12, trailCount: 20, bloodCount: 25, sparkCount: 15, explosionCount: 50, explosionSparkCount: 30 },
    projectile: { speed: 120, gravity: 30, size: 0.15, maxLife: 5, poolSize: 64, trailInterval: 0.05, explosionRadius: 25, explosionForce: 40, explosionDamage: 60 },
    audio: { masterVolume: 0.7, sfxVolume: 0.8, musicVolume: 0.3, maxSounds: 24, spatialRefDist: 10, spatialMaxDist: 500, spatialRolloff: 1 },
    debug: { damageFlash: true, godMode: false }
};

// Apply base64 terrain config if set
if (TERRAIN_CONFIG) {
    try {
        const tc = JSON.parse(atob(TERRAIN_CONFIG));
        if (tc.terrain) Object.assign(CFG.terrain, tc.terrain);
        if (tc.world) Object.assign(CFG.world, tc.world);
    } catch(e) { console.warn('Bad TERRAIN_CONFIG:', e); }
}

// --- Config sharing: encode/decode full CFG as base64 URL param ---
function encodeCFG() {
    // Snapshot all tunable config (exclude non-tunable like poolSize, resolution)
    const snap = {};
    for (const cat in CFG) {
        if (typeof CFG[cat] === 'object') {
            snap[cat] = Object.assign({}, CFG[cat]);
        } else {
            snap[cat] = CFG[cat];
        }
    }
    return btoa(JSON.stringify(snap));
}
function applyCFG(b64) {
    try {
        const incoming = JSON.parse(atob(b64));
        for (const cat in incoming) {
            if (typeof incoming[cat] === 'object' && typeof CFG[cat] === 'object') {
                Object.assign(CFG[cat], incoming[cat]);
            } else if (cat in CFG) {
                CFG[cat] = incoming[cat];
            }
        }
        return true;
    } catch(e) { console.warn('Bad config string:', e); return false; }
}
function getShareURL() {
    const url = new URL(window.location.href);
    url.searchParams.set('cfg', encodeCFG());
    return url.toString();
}
// Apply URL config on load (overrides TERRAIN_CONFIG + defaults)
(function() {
    const params = new URLSearchParams(window.location.search);
    const cfgParam = params.get('cfg');
    if (cfgParam) {
        if (applyCFG(cfgParam)) console.log('Config loaded from URL');
    }
})();

// ============================================================
//  TERRAIN (CPU mesh + GPU height texture)
// ============================================================
class Terrain {
    constructor(scene) {
        this.scene = scene;
        this.size = CFG.world.size;
        this.res = CFG.terrain.resolution;
        this.data = null;
        this.mesh = null;
        this.heightTexture = null;
        this.generate();
    }

    generate() {
        this.size = CFG.world.size;
        this.res = CFG.terrain.resolution;
        if (this.mesh) { this.scene.remove(this.mesh); this.mesh.geometry.dispose(); this.mesh.material.dispose(); }
        const noise = new SimplexNoise(CFG.terrain.seed);
        const { octaves, frequency, amplitude, lacunarity, persistence, offset } = CFG.terrain;
        // Seed-dependent offset so origin doesn't always land on noise lattice vertex
        let rs = CFG.terrain.seed;
        const srng = () => { rs = (rs * 16807 + 1) % 2147483647; return rs / 2147483647; };
        const noiseOffX = srng() * 10000 - 5000, noiseOffZ = srng() * 10000 - 5000;
        const res = this.res, size = this.size, r1 = res + 1;
        this.data = new Float32Array(r1 * r1);
        for (let z = 0; z < r1; z++) {
            for (let x = 0; x < r1; x++) {
                const wx = (x / res - 0.5) * size, wz = (z / res - 0.5) * size;
                let h = 0, amp = 1, freq = frequency;
                for (let o = 0; o < octaves; o++) { h += noise.noise2D((wx + noiseOffX) * freq, (wz + noiseOffZ) * freq) * amp; amp *= persistence; freq *= lacunarity; }
                const ex = Math.abs(x / res - 0.5) * 2, ez = Math.abs(z / res - 0.5) * 2;
                const edge = Math.max(0, 1 - Math.pow(Math.max(ex, ez), 3) * 1.5);
                this.data[z * r1 + x] = h * amplitude * edge + offset;
            }
        }
        this.buildMesh();
        this.buildHeightTexture();
    }

    buildNoiseTexture() {
        const texSize = 512;
        const noise = new SimplexNoise(CFG.terrain.seed + 1337);
        const data = new Uint8Array(texSize * texSize * 4);
        for (let y = 0; y < texSize; y++) {
            for (let x = 0; x < texSize; x++) {
                const nx = x / texSize * 8, ny = y / texSize * 8;
                let v = 0;
                v += noise.noise2D(nx, ny) * 0.55;
                v += noise.noise2D(nx * 2.5, ny * 2.5) * 0.3;
                v += noise.noise2D(nx * 7, ny * 7) * 0.15;
                v = v * 0.5 + 0.5;
                const c = Math.floor((0.62 + v * 0.38) * 255);
                const i = (y * texSize + x) * 4;
                data[i] = c; data[i+1] = c; data[i+2] = c; data[i+3] = 255;
            }
        }
        const tex = new THREE.DataTexture(data, texSize, texSize, THREE.RGBAFormat);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.minFilter = THREE.LinearMipmapLinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.generateMipmaps = true;
        tex.needsUpdate = true;
        return tex;
    }

    buildMesh() {
        const res = this.res, size = this.size, r1 = res + 1;
        const geo = new THREE.BufferGeometry();
        const verts = new Float32Array(r1 * r1 * 3);
        const colors = new Float32Array(r1 * r1 * 3);
        const uvs = new Float32Array(r1 * r1 * 2);
        const indices = [];
        const tileScale = 30;
        for (let z = 0; z < r1; z++) {
            for (let x = 0; x < r1; x++) {
                const i = z * r1 + x;
                const wx = (x / res - 0.5) * size, wz = (z / res - 0.5) * size, h = this.data[i];
                verts[i*3] = wx; verts[i*3+1] = h; verts[i*3+2] = wz;
                uvs[i*2] = wx / tileScale; uvs[i*2+1] = wz / tileScale;
                const slope = this.getSlopeAt(x, z);
                let r, g, b;
                if (h < 10) { r=0.22; g=0.42; b=0.18; } else if (h < 35) { r=0.32; g=0.52; b=0.22; }
                else if (h < 60) { r=0.45; g=0.42; b=0.28; } else if (h < 85) { r=0.55; g=0.5; b=0.4; }
                else { r=0.85; g=0.88; b=0.92; }
                if (slope > 0.5) { const t = Math.min(1,(slope-0.5)*2); r=r*(1-t)+0.45*t; g=g*(1-t)+0.43*t; b=b*(1-t)+0.4*t; }
                colors[i*3]=r; colors[i*3+1]=g; colors[i*3+2]=b;
            }
        }
        for (let z = 0; z < res; z++) for (let x = 0; x < res; x++) {
            const a = z*r1+x, b = a+1, c = (z+1)*r1+x, d = c+1;
            indices.push(a,c,b,b,c,d);
        }
        geo.setIndex(indices);
        geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geo.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        geo.computeVertexNormals();
        if (!this._noiseTex) this._noiseTex = this.buildNoiseTexture();
        const mat = new THREE.MeshLambertMaterial({ vertexColors: true, map: this._noiseTex });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.receiveShadow = true;
        this.scene.add(this.mesh);
    }

    buildHeightTexture() {
        // Reuse the same texture object so GPU compute shader references stay valid
        const r1 = this.res + 1;
        if (!this.heightTexture || this.heightTexture.image.width !== r1) {
            const texData = new Float32Array(r1 * r1 * 4);
            this.heightTexture = new THREE.DataTexture(texData, r1, r1, THREE.RGBAFormat, THREE.FloatType);
            this.heightTexture.minFilter = THREE.LinearFilter;
            this.heightTexture.magFilter = THREE.LinearFilter;
            this.heightTexture.wrapS = THREE.ClampToEdgeWrapping;
            this.heightTexture.wrapT = THREE.ClampToEdgeWrapping;
        }
        const texData = this.heightTexture.image.data;
        for (let i = 0; i < r1 * r1; i++) {
            texData[i * 4] = this.data[i];
            texData[i * 4 + 1] = 0;
            texData[i * 4 + 2] = 0;
            texData[i * 4 + 3] = 1;
        }
        this.heightTexture.needsUpdate = true;
    }

    getSlopeAt(gx, gz) {
        const r1 = this.res + 1;
        const x0 = Math.max(0, gx-1), x1 = Math.min(this.res, gx+1);
        const z0 = Math.max(0, gz-1), z1 = Math.min(this.res, gz+1);
        const dx = this.data[gz*r1+x1] - this.data[gz*r1+x0];
        const dz = this.data[z1*r1+gx] - this.data[z0*r1+gx];
        const cs = this.size / this.res;
        return Math.sqrt(dx*dx + dz*dz) / (cs * 2);
    }

    getHeight(wx, wz) {
        const res = this.res, size = this.size, r1 = res + 1;
        const gx = (wx / size + 0.5) * res, gz = (wz / size + 0.5) * res;
        const ix = Math.floor(gx), iz = Math.floor(gz), fx = gx - ix, fz = gz - iz;
        const x0 = Math.max(0, Math.min(res, ix)), x1 = Math.max(0, Math.min(res, ix+1));
        const z0 = Math.max(0, Math.min(res, iz)), z1 = Math.max(0, Math.min(res, iz+1));
        const h00 = this.data[z0*r1+x0], h10 = this.data[z0*r1+x1];
        const h01 = this.data[z1*r1+x0], h11 = this.data[z1*r1+x1];
        return (h00*(1-fx)+h10*fx)*(1-fz) + (h01*(1-fx)+h11*fx)*fz;
    }

    getNormal(wx, wz) {
        const eps = this.size / this.res;
        const hL = this.getHeight(wx-eps, wz), hR = this.getHeight(wx+eps, wz);
        const hD = this.getHeight(wx, wz-eps), hU = this.getHeight(wx, wz+eps);
        return new THREE.Vector3(hL - hR, eps * 2, hD - hU).normalize();
    }
}

// ============================================================
//  GPU ENEMY SYSTEM
// ============================================================
class GPUEnemySystem {
    constructor(scene, terrain) {
        this.scene = scene;
        this.terrain = terrain;

        // --- Storage arrays ---
        this.positions = instancedArray(ENEMY_COUNT, 'vec3');
        this.velocities = instancedArray(ENEMY_COUNT, 'vec3');
        this.states = instancedArray(ENEMY_COUNT, 'vec4'); // x=health, y=type, z=maxHealth, w=flashTimer
        this.traits = instancedArray(ENEMY_COUNT, 'vec4'); // x=size(0.25-3.5), y=speed(0.3-3), z=toughness(0.3-3.5), w=aggression(0-1)
        this.facings = instancedArray(ENEMY_COUNT, 'vec2'); // x=cosA, y=sinA (unit direction on XZ plane)

        // --- Uniforms (updated per frame) ---
        this.playerPosU = uniform(new THREE.Vector3());
        this.dtU = uniform(0.016);
        this.cameraPosU = uniform(new THREE.Vector3());

        // --- Uniforms (from config, updated via debug) ---
        this.enemySpeedU = uniform(CFG.enemies.speed);
        this.enemySizeU = uniform(CFG.enemies.size);
        this.enemyMaxHealthU = uniform(CFG.enemies.health);
        this.enemyAttackRangeU = uniform(CFG.enemies.attackRange);
        this.worldSizeU = uniform(CFG.world.size);
        this.cullDistU = uniform(CFG.enemies.cullDistance);
        this.flowInfluenceU = uniform(CFG.enemies.flowInfluence);

        // --- Weapon uniforms ---
        this.rayOriginU = uniform(new THREE.Vector3());
        this.rayDirU = uniform(new THREE.Vector3());
        this.weaponDamageU = uniform(CFG.weapon.damage);
        this.weaponRangeU = uniform(CFG.weapon.range);
        this.hitRadiusU = uniform(CFG.weapon.hitRadius);

        // --- Explosion uniforms ---
        this.explosionPosU = uniform(new THREE.Vector3());
        this.explosionRadiusU = uniform(CFG.projectile.explosionRadius);
        this.explosionForceU = uniform(CFG.projectile.explosionForce);
        this.explosionDamageU = uniform(CFG.projectile.explosionDamage);

        // --- Flow map ---
        this.flowMapSize = CFG.flowMap.resolution;
        this.flowMapData = new Float32Array(this.flowMapSize * this.flowMapSize * 4);
        this.flowMapTexture = new THREE.DataTexture(
            this.flowMapData, this.flowMapSize, this.flowMapSize,
            THREE.RGBAFormat, THREE.FloatType
        );
        this.flowMapTexture.minFilter = THREE.LinearFilter;
        this.flowMapTexture.magFilter = THREE.LinearFilter;
        this.flowMapTexture.wrapS = THREE.ClampToEdgeWrapping;
        this.flowMapTexture.wrapT = THREE.ClampToEdgeWrapping;
        this.flowMapTimer = 0;

        // --- Density grid (128x128, uint) --- approximate counts, race conditions OK
        this.DENSITY_RES = 128;
        this.densityGrid = instancedArray(this.DENSITY_RES * this.DENSITY_RES, 'uint');

        // --- Projectile collision (GPU-side hit detection) ---
        this.PROJ_POOL = CFG.projectile.poolSize;
        // N×2 texture: row 0 = current pos, row 1 = previous pos (for swept collision)
        this.projPositionsData = new Float32Array(this.PROJ_POOL * 4 * 2);
        this.projPositionsTexture = new THREE.DataTexture(
            this.projPositionsData, this.PROJ_POOL, 2,
            THREE.RGBAFormat, THREE.FloatType
        );
        this.projPositionsTexture.minFilter = THREE.NearestFilter;
        this.projPositionsTexture.magFilter = THREE.NearestFilter;
        this.projPositionsTexture.wrapS = THREE.ClampToEdgeWrapping;
        this.projPositionsTexture.wrapT = THREE.ClampToEdgeWrapping;
        this.projHitFlags = instancedArray(this.PROJ_POOL, 'uint');
        this.projHitFlagsAttr = this.projHitFlags.value; // raw attribute for readback
        this.projCollisionRadiusU = uniform(CFG.enemies.size * 0.75 + CFG.projectile.size); // generous: 75% enemy size + projectile
        this._pendingHitPromise = null;
        this._hitResults = null;

        // --- Kill counter (256 bins to avoid GPU write contention) ---
        const KILL_BINS = 256;
        this.KILL_BINS = KILL_BINS;
        this.killBins = instancedArray(KILL_BINS, 'uint');
        this.killBinsAttr = this.killBins.value;
        this._pendingKillPromise = null;
        this._lastKillCount = 0;

        // --- Nearby enemy count (for proximity damage) ---
        this.nearbyCount = instancedArray(1, 'uint');
        this.nearbyCountAttr = this.nearbyCount.value;
        this._pendingNearbyPromise = null;
        this._lastNearbyCount = 0;

        // --- Build compute shaders ---
        const heightTex = texture(terrain.heightTexture);
        this.heightTexNode = heightTex;
        const flowTex = texture(this.flowMapTexture);
        const positions = this.positions;
        const velocities = this.velocities;
        const states = this.states;
        const traits = this.traits;
        const playerPos = this.playerPosU;
        const dt = this.dtU;
        const spd = this.enemySpeedU;
        const sz = this.enemySizeU;
        const maxHp = this.enemyMaxHealthU;
        const ws = this.worldSizeU;
        const flowInf = this.flowInfluenceU;
        const killBins = this.killBins;
        const nearbyCount = this.nearbyCount;

        // INIT: scatter enemies randomly and assign traits
        this.computeInit = Fn(() => {
            const pos = positions.element(instanceIndex);
            const state = states.element(instanceIndex);
            const vel = velocities.element(instanceIndex);
            const trait = traits.element(instanceIndex);

            // --- Traits: size, speed, toughness, aggression ---
            // Size: wide range (0.25–3.5) peaked at 1.0
            // Two hashes averaged → triangular distribution peaked at 0.5
            // Then pow(4, x*2-1): maps 0→0.25, 0.5→1.0, 1.0→4.0
            const sizeH1 = hash(instanceIndex.add(11));
            const sizeH2 = hash(instanceIndex.add(15));
            const sizeMid = sizeH1.add(sizeH2).mul(0.5); // 0–1 peaked at 0.5
            const sizeTrait = pow(float(4.0), sizeMid.mul(2).sub(1)); // 0.25 → 1.0 → 4.0
            trait.x.assign(sizeTrait.clamp(0.25, 3.5));
            // Speed: strongly inverse of size + noise (tiny = blazing, huge = lumbering)
            const speedTrait = float(3.5).sub(sizeTrait.mul(0.85)).add(hash(instanceIndex.add(12)).mul(0.8).sub(0.4));
            trait.y.assign(speedTrait.clamp(0.3, 3.0));
            // Toughness: correlated with size + wider noise (big = very tough)
            const toughTrait = sizeTrait.mul(0.8).add(hash(instanceIndex.add(13)).mul(0.8).sub(0.4));
            trait.z.assign(toughTrait.clamp(0.3, 3.5));
            // Aggression: independent (0–1)
            trait.w.assign(hash(instanceIndex.add(14)));

            // --- Position: scatter radially with feathered exclusion zone around spawn ---
            const angle = hash(instanceIndex).mul(Math.PI * 2);
            // Feathered min radius: 120–280 per-enemy (organic edge, not a perfect circle)
            const minRadius = float(120).add(hash(instanceIndex.add(16)).mul(160));
            const maxRadius = ws.mul(0.45);
            const radius = minRadius.add(hash(instanceIndex.add(7)).mul(maxRadius.sub(minRadius)));
            pos.x.assign(angle.cos().mul(radius));
            pos.z.assign(angle.sin().mul(radius));
            const tu = pos.x.div(ws).add(0.5).clamp(0.001, 0.999);
            const tv = pos.z.div(ws).add(0.5).clamp(0.001, 0.999);
            pos.y.assign(heightTex.sample(vec2(tu, tv)).x.add(0.5).add(sz.mul(trait.x).mul(0.6)));
            vel.assign(vec3(0, 0, 0));

            // --- Facing: random initial direction (unit vec2) ---
            const facing = this.facings.element(instanceIndex);
            const fAngle = hash(instanceIndex.add(50)).mul(Math.PI * 2);
            facing.x.assign(fAngle.cos());
            facing.y.assign(fAngle.sin());

            // --- State: health scales with toughness ---
            const enemyMaxHp = maxHp.mul(trait.z);
            state.x.assign(enemyMaxHp);       // current health
            state.y.assign(hash(instanceIndex.add(2)).mul(4).floor()); // type 0-3
            state.z.assign(enemyMaxHp);        // max health (for color shader)
            state.w.assign(float(0));           // flash timer
        })().compute(ENEMY_COUNT);

        // UPDATE: move toward player (alive), physics for all (alive + dead)
        this.computeUpdate = Fn(() => {
            const pos = positions.element(instanceIndex);
            const vel = velocities.element(instanceIndex);
            const state = states.element(instanceIndex);
            const trait = traits.element(instanceIndex);
            // Flash timer decay
            state.w.assign(state.w.sub(dt).max(0));

            // Alive: swarm toward player with ring separation
            If(state.x.greaterThan(0), () => {
                const aggression = trait.w; // 0 = passive orbit, 1 = direct charge

                // Distance to player
                const rawDx = playerPos.x.sub(pos.x);
                const rawDz = playerPos.z.sub(pos.z);
                const distToPlayer = rawDx.mul(rawDx).add(rawDz.mul(rawDz)).sqrt().max(0.01);

                // Ring separation: aggressive enemies have tighter rings, slower orbit
                const ringAngle = hash(instanceIndex.add(50)).mul(Math.PI * 2)
                    .add(time.mul(hash(instanceIndex.add(70)).mul(0.4).add(0.1).mul(float(1).sub(aggression.mul(0.5)))));
                const baseRingDist = float(3.0).add(hash(instanceIndex.add(60)).mul(5.0));
                const ringDist = baseRingDist.mul(float(1).sub(aggression.mul(0.6))); // aggressive = tighter ring

                // Blend: aggressive enemies charge from further away
                const chargeRange = float(15).add(aggression.mul(25)); // passive=15, aggressive=40
                const ringBlend = float(1).sub(distToPlayer.sub(chargeRange).div(float(30)).clamp(0, 1));
                const targetX = mix(playerPos.x, playerPos.x.add(ringAngle.cos().mul(ringDist)), ringBlend);
                const targetZ = mix(playerPos.z, playerPos.z.add(ringAngle.sin().mul(ringDist)), ringBlend);

                const dx = targetX.sub(pos.x);
                const dz = targetZ.sub(pos.z);
                const distXZ = dx.mul(dx).add(dz.mul(dz)).sqrt().max(0.01);
                const dirX = dx.div(distXZ);
                const dirZ = dz.div(distXZ);

                // Flow map
                const fu = pos.x.div(ws).add(0.5).clamp(0.001, 0.999);
                const fv = pos.z.div(ws).add(0.5).clamp(0.001, 0.999);
                const flowSample = flowTex.sample(vec2(fu, fv));
                const moveX = mix(dirX, flowSample.x, flowInf);
                const moveZ = mix(dirZ, flowSample.y, flowInf);
                const moveLen = moveX.mul(moveX).add(moveZ.mul(moveZ)).sqrt().max(0.01);

                // Slow down near player to prevent pile-up
                const closeSlowdown = distToPlayer.div(float(8)).clamp(0.15, 1.0);

                // Density-based slowdown: sample the grid cell ahead and here
                const dgx = pos.x.div(ws).add(0.5).mul(float(DRES)).clamp(0, DRES - 1).toInt();
                const dgz = pos.z.div(ws).add(0.5).mul(float(DRES)).clamp(0, DRES - 1).toInt();
                const cellDensity = densityGrid.element(dgz.mul(int(DRES)).add(dgx)).toFloat();
                // Formula: 1 / (density/200 + 1) — at 200 enemies/cell speed halves, at 600 it's 25%
                const densitySlowdown = float(1).div(cellDensity.div(float(200)).add(1));

                const speedVar = trait.y; // per-enemy speed trait (0.3–3.0)

                // Slope-based speed: sample terrain height here and ahead
                const slopeProbe = float(8); // look-ahead distance
                const aheadX = pos.x.add(moveX.div(moveLen).mul(slopeProbe));
                const aheadZ = pos.z.add(moveZ.div(moveLen).mul(slopeProbe));
                const hereU = pos.x.div(ws).add(0.5).clamp(0.001, 0.999);
                const hereV = pos.z.div(ws).add(0.5).clamp(0.001, 0.999);
                const aheadU = aheadX.div(ws).add(0.5).clamp(0.001, 0.999);
                const aheadV = aheadZ.div(ws).add(0.5).clamp(0.001, 0.999);
                const hHere = heightTex.sample(vec2(hereU, hereV)).x;
                const hAhead = heightTex.sample(vec2(aheadU, aheadV)).x;
                const slopeDelta = hAhead.sub(hHere).div(slopeProbe); // positive = uphill
                // Uphill: slow to 0.25x at steep inclines. Downhill: speed up to 2x
                const slopeSpeed = clamp(float(1).sub(slopeDelta.mul(3)), 0.25, 2.0);

                const totalSlow = closeSlowdown.mul(densitySlowdown).mul(slopeSpeed);
                pos.x.addAssign(moveX.div(moveLen).mul(spd).mul(speedVar).mul(totalSlow).mul(dt));
                pos.z.addAssign(moveZ.div(moveLen).mul(spd).mul(speedVar).mul(totalSlow).mul(dt));

                // Smooth facing update: lerp toward movement direction
                const facing = this.facings.element(instanceIndex);
                const targetCos = moveX.div(moveLen);
                const targetSin = moveZ.div(moveLen);
                const turnRate = dt.mul(8).clamp(0, 1); // smooth turning (~8 rad/s)
                facing.x.assign(mix(facing.x, targetCos, turnRate));
                facing.y.assign(mix(facing.y, targetSin, turnRate));
                // Renormalize to prevent drift
                const fLen = facing.x.mul(facing.x).add(facing.y.mul(facing.y)).sqrt().max(float(0.001));
                facing.x.divAssign(fLen);
                facing.y.divAssign(fLen);
            });
        })().compute(ENEMY_COUNT);

        // PHYSICS: separate shader — no If blocks, runs for ALL enemies (alive + dead)
        this.computePhysics = Fn(() => {
            const pos = positions.element(instanceIndex);
            const vel = velocities.element(instanceIndex);
            const state = states.element(instanceIndex);
            const trait = traits.element(instanceIndex);

            vel.y.subAssign(float(40).mul(dt));
            pos.addAssign(vel.mul(dt));
            vel.x.mulAssign(pow(float(0.4), dt));
            vel.z.mulAssign(pow(float(0.4), dt));
            vel.y.mulAssign(pow(float(0.8), dt));

            const half = ws.mul(0.48);
            pos.x.assign(pos.x.clamp(half.negate(), half));
            pos.z.assign(pos.z.clamp(half.negate(), half));

            // Terrain collision — dead enemies sit lower (small stumps on ground)
            const tu2 = pos.x.div(ws).add(0.5).clamp(0.001, 0.999);
            const tv2 = pos.z.div(ws).add(0.5).clamp(0.001, 0.999);
            const terrainH = heightTex.sample(vec2(tu2, tv2)).x.add(0.5);
            const isAlive = step(float(0.01), state.x);
            const enemySize = sz.mul(trait.x);
            const targetY = terrainH.add(mix(enemySize.mul(0.12), enemySize.mul(0.6), isAlive));

            const belowGround = step(pos.y, targetY);
            pos.y.assign(mix(pos.y, targetY, belowGround));
            vel.y.assign(mix(vel.y, vel.y.max(0), belowGround));
            vel.x.assign(mix(vel.x, vel.x.mul(0.7), belowGround));
            vel.z.assign(mix(vel.z, vel.z.mul(0.7), belowGround));
        })().compute(ENEMY_COUNT);

        // DAMAGE: ray intersection test when player shoots
        this.computeDamage = Fn(() => {
            const pos = positions.element(instanceIndex);
            const state = states.element(instanceIndex);
            If(state.x.greaterThan(0), () => {
                const toEnemy = pos.sub(this.rayOriginU);
                const proj = toEnemy.dot(this.rayDirU);
                If(proj.greaterThan(0), () => {
                    If(proj.lessThan(this.weaponRangeU), () => {
                        const closest = this.rayOriginU.add(this.rayDirU.mul(proj));
                        const dist = closest.sub(pos).length();
                        If(dist.lessThan(this.hitRadiusU), () => {
                            state.x.subAssign(this.weaponDamageU);
                            state.w.assign(float(0.15));
                            If(state.x.lessThanEqual(0), () => {
                                const bin = float(instanceIndex).mod(float(KILL_BINS)).toInt();
                                killBins.element(bin).addAssign(uint(1));
                            });
                        });
                    });
                });
            });
        })().compute(ENEMY_COUNT);

        // EXPLOSION: apply force to ALL nearby enemies (alive + dead), damage only to alive
        this.computeExplosion = Fn(() => {
            const pos = positions.element(instanceIndex);
            const vel = velocities.element(instanceIndex);
            const state = states.element(instanceIndex);
            const toEnemy = pos.sub(this.explosionPosU);
            const dist = toEnemy.length();
            If(dist.lessThan(this.explosionRadiusU), () => {
                const normDir = toEnemy.div(dist.max(float(0.5)));
                const falloff = float(1).sub(dist.div(this.explosionRadiusU));
                // Force: ALL enemies (corpses fly from blasts!)
                vel.x.addAssign(normDir.x.mul(this.explosionForceU).mul(falloff));
                vel.z.addAssign(normDir.z.mul(this.explosionForceU).mul(falloff));
                vel.y.addAssign(this.explosionForceU.mul(falloff).mul(0.7));
                // Damage: only alive
                If(state.x.greaterThan(0), () => {
                    state.x.subAssign(this.explosionDamageU.mul(falloff));
                    state.w.assign(float(0.15));
                    If(state.x.lessThanEqual(0), () => {
                        const bin = float(instanceIndex).mod(float(KILL_BINS)).toInt();
                        killBins.element(bin).addAssign(uint(1));
                    });
                });
            });
        })().compute(ENEMY_COUNT);

        // DENSITY CLEAR: zero out the entire density grid
        const densityGrid = this.densityGrid;
        const DRES = this.DENSITY_RES;
        this.computeDensityClear = Fn(() => {
            densityGrid.element(instanceIndex).assign(uint(0));
        })().compute(DRES * DRES);

        // DENSITY ACCUMULATE: each alive enemy increments its grid cell
        this.computeDensityAccum = Fn(() => {
            const state = states.element(instanceIndex);
            If(state.x.greaterThan(0), () => {
                const pos = positions.element(instanceIndex);
                // Map world pos to grid cell
                const gx = pos.x.div(ws).add(0.5).mul(float(DRES)).clamp(0, DRES - 1).toInt();
                const gz = pos.z.div(ws).add(0.5).mul(float(DRES)).clamp(0, DRES - 1).toInt();
                const cellIdx = gz.mul(int(DRES)).add(gx);
                densityGrid.element(cellIdx).addAssign(uint(1));
            });
        })().compute(ENEMY_COUNT);

        // PROJECTILE CLEAR: zero hit flags
        const projHitFlags = this.projHitFlags;
        const PPOOL = this.PROJ_POOL;
        this.computeProjClear = Fn(() => {
            projHitFlags.element(instanceIndex).assign(uint(0));
        })().compute(PPOOL);

        // PROJECTILE COLLISION: swept line-segment vs enemy sphere
        // Texture is 32×2: row 0 (v=0.25) = current pos, row 1 (v=0.75) = previous pos
        const projTex = texture(this.projPositionsTexture);
        const projColR = this.projCollisionRadiusU;
        this.computeProjCollision = Fn(() => {
            const state = states.element(instanceIndex);
            If(state.x.greaterThan(0), () => {
                const pos = positions.element(instanceIndex);
                for (let pi = 0; pi < PPOOL; pi++) {
                    const pu = float(pi + 0.5).div(float(PPOOL));
                    // Sample current and previous positions
                    const currData = projTex.sample(vec2(pu, 0.25));
                    const prevData = projTex.sample(vec2(pu, 0.75));
                    If(currData.w.greaterThan(0.5), () => {
                        // Line segment A→B (prev→curr), point P (enemy)
                        const ax = prevData.x; const ay = prevData.y; const az = prevData.z;
                        const bx = currData.x; const by = currData.y; const bz = currData.z;
                        const abx = bx.sub(ax); const aby = by.sub(ay); const abz = bz.sub(az);
                        const apx = pos.x.sub(ax); const apy = pos.y.sub(ay); const apz = pos.z.sub(az);
                        const abDotAb = abx.mul(abx).add(aby.mul(aby)).add(abz.mul(abz));
                        const apDotAb = apx.mul(abx).add(apy.mul(aby)).add(apz.mul(abz));
                        // t = clamp(dot(AP,AB)/dot(AB,AB), 0, 1) — closest point parameter
                        const t = apDotAb.div(abDotAb.max(0.0001)).clamp(0, 1);
                        // Closest point on segment
                        const cx = ax.add(abx.mul(t));
                        const cy = ay.add(aby.mul(t));
                        const cz = az.add(abz.mul(t));
                        // Distance from closest point to enemy
                        const dx = cx.sub(pos.x); const dy = cy.sub(pos.y); const dz = cz.sub(pos.z);
                        const dist = dx.mul(dx).add(dy.mul(dy)).add(dz.mul(dz)).sqrt();
                        If(dist.lessThan(projColR), () => {
                            projHitFlags.element(pi).assign(uint(1));
                        });
                    });
                }
            });
        })().compute(ENEMY_COUNT);

        // KILL BINS CLEAR
        this.computeKillBinsClear = Fn(() => {
            killBins.element(instanceIndex).assign(uint(0));
        })().compute(KILL_BINS);

        // NEARBY ENEMY COUNT (proximity damage)
        const atkRange = this.enemyAttackRangeU;
        this.computeNearbyClear = Fn(() => {
            nearbyCount.element(instanceIndex).assign(uint(0));
        })().compute(1);

        this.computeNearbyCount = Fn(() => {
            const state = states.element(instanceIndex);
            If(state.x.greaterThan(0), () => {
                const pos = positions.element(instanceIndex);
                const trait = traits.element(instanceIndex);
                const dx = pos.x.sub(playerPos.x);
                const dy = pos.y.sub(playerPos.y);
                const dz = pos.z.sub(playerPos.z);
                const distSq = dx.mul(dx).add(dy.mul(dy)).add(dz.mul(dz));
                const sizedRange = atkRange.mul(trait.x); // bigger enemies reach further
                If(distSq.lessThan(sizedRange.mul(sizedRange)), () => {
                    nearbyCount.element(int(0)).addAssign(uint(1));
                });
            });
        })().compute(ENEMY_COUNT);

        // --- Build instanced mesh ---
        this.buildMesh(scene);
    }

    buildMesh(scene) {
        const baseGeo = new THREE.BoxGeometry(1, 1.2, 1);
        const instancedGeo = new THREE.InstancedBufferGeometry();
        instancedGeo.index = baseGeo.index;
        for (const key in baseGeo.attributes) {
            instancedGeo.setAttribute(key, baseGeo.attributes[key]);
        }
        instancedGeo.instanceCount = ENEMY_COUNT;

        const material = new THREE.MeshLambertMaterial();
        const instPos = this.positions.element(instanceIndex);
        const instState = this.states.element(instanceIndex);
        const instTrait = this.traits.element(instanceIndex);
        const isAlive = step(float(0.01), instState.x);

        // Distance cull: scale to 0 if beyond cull distance
        const toCam = instPos.sub(this.cameraPosU);
        const distSq = toCam.dot(toCam);
        const inRange = step(distSq, this.cullDistU.mul(this.cullDistU));

        // Non-uniform scaling: per-enemy size trait (0.25–3.5) + wild hash-derived proportions
        const sizeTrait = instTrait.x;
        const scaleW = sizeTrait.mul(float(0.3).add(hash(instanceIndex.add(40)).mul(0.6))); // tangent (thinner: 30–90%)
        const scaleH = sizeTrait.mul(float(0.4).add(hash(instanceIndex.add(41)).mul(1.4))); // 40–180% height (lanky vs squat)
        const scaleD = sizeTrait.mul(float(0.5).add(hash(instanceIndex.add(42)).mul(1.0))); // 50–150% facing depth
        const aliveScaleVec = vec3(
            this.enemySizeU.mul(scaleW),
            this.enemySizeU.mul(scaleH),
            this.enemySizeU.mul(scaleD)
        );
        // Dead: 1/5 size. Scalar mix avoids vec3 mix issues in TSL.
        const lifeScale = mix(float(0.2), float(1.0), isAlive).mul(inRange);

        // Scale in local space first — taper X toward the front for a wedge silhouette
        // positionLocal.z: -0.5 (back) → +0.5 (front). Taper: back=full width, front=30%
        const taper = mix(float(1.0), float(0.3), positionLocal.z.add(0.5));
        const scaledX = positionLocal.x.mul(aliveScaleVec.x).mul(lifeScale).mul(taper);
        const scaledY = positionLocal.y.mul(aliveScaleVec.y).mul(lifeScale);
        const scaledZ = positionLocal.z.mul(aliveScaleVec.z).mul(lifeScale);

        // Face stored direction: read pre-computed facing (cosA, sinA) from GPU array
        const instFacing = this.facings.element(instanceIndex);
        const cosA = instFacing.x;
        const sinA = instFacing.y;
        // Rotate scaled local position around Y axis
        const rotX = scaledX.mul(cosA).add(scaledZ.mul(sinA));
        const rotZ = scaledZ.mul(cosA).sub(scaledX.mul(sinA));

        material.positionNode = vec3(rotX, scaledY, rotZ).add(instPos);

        // Trait-driven base color: speed→purple, toughness→green, aggression→red
        const tSpeed = instTrait.y.div(3.0).clamp(0, 1);  // normalize 0–3 → 0–1
        const tTough = instTrait.z.div(3.5).clamp(0, 1);  // normalize 0–3.5 → 0–1
        const tAggro = instTrait.w;
        const colSpeed = mix(vec3(0.25, 0.45, 0.65), vec3(0.7, 0.15, 0.9), tSpeed);  // steel blue → vivid purple
        const colTough = mix(vec3(0.6, 0.5, 0.3), vec3(0.1, 0.75, 0.2), tTough);     // tan → bright green
        const colAggro = mix(vec3(0.5, 0.5, 0.5), vec3(0.95, 0.15, 0.1), tAggro);    // gray → angry red
        const traitBase = colSpeed.mul(0.4).add(colTough.mul(0.4)).add(colAggro.mul(0.2));

        // Health overlay: modulate trait color by damage (white at full → red at low)
        const healthPct = instState.x.div(instState.z.max(1)).clamp(0, 1); // state.z = max health
        const healthTint = mix(vec3(0.9, 0.15, 0.1), vec3(1, 1, 1), healthPct);
        const aliveColor = traitBase.mul(healthTint);

        // Hit flash
        const flashAmt = clamp(instState.w.mul(10), 0, 1);
        const aliveColorFlashed = mix(aliveColor, vec3(1, 1, 1), flashAmt);
        // Corpse color: very dark gray
        const deadColor = vec3(0.15, 0.15, 0.15);
        material.colorNode = mix(deadColor, aliveColorFlashed, isAlive);

        this.mesh = new THREE.Mesh(instancedGeo, material);
        this.mesh.frustumCulled = false;
        this.mesh.renderOrder = 1;
        scene.add(this.mesh);

        // Shadow blob under each enemy
        const shadowGeo = new THREE.CircleGeometry(1, 8);
        shadowGeo.rotateX(-Math.PI / 2);
        const shadowInstGeo = new THREE.InstancedBufferGeometry();
        shadowInstGeo.index = shadowGeo.index;
        for (const sk in shadowGeo.attributes) {
            shadowInstGeo.setAttribute(sk, shadowGeo.attributes[sk]);
        }
        shadowInstGeo.instanceCount = ENEMY_COUNT;

        const shadowMat = new THREE.MeshBasicMaterial({ transparent: true, depthWrite: false });
        const sInstPos = this.positions.element(instanceIndex);
        const sInstState = this.states.element(instanceIndex);
        const sIsAlive = step(float(0.01), sInstState.x);
        const sToCam = sInstPos.sub(this.cameraPosU);
        const sDistSq = sToCam.dot(sToCam);
        const sInRange = step(sDistSq, this.cullDistU.mul(this.cullDistU));
        // Alive: full shadow scaled by per-enemy size trait. Dead: 1/3 shadow (matches corpse)
        const sSizeTrait = this.traits.element(instanceIndex).x;
        const sDeadShadow = this.enemySizeU.mul(sSizeTrait).mul(0.33).max(0.4);
        const sScale = sInRange.mul(mix(sDeadShadow, this.enemySizeU.mul(sSizeTrait).mul(0.9), sIsAlive));

        // Sample terrain height for shadow Y position
        const sTU = sInstPos.x.div(this.worldSizeU).add(0.5).clamp(0.001, 0.999);
        const sTV = sInstPos.z.div(this.worldSizeU).add(0.5).clamp(0.001, 0.999);
        const sTerrainH = this.heightTexNode.sample(vec2(sTU, sTV)).x;

        shadowMat.positionNode = positionLocal.mul(sScale).add(vec3(sInstPos.x, sTerrainH.add(0.15), sInstPos.z));
        shadowMat.colorNode = vec3(0, 0, 0);
        shadowMat.opacityNode = float(0.3).mul(sInRange);

        this.shadowMesh = new THREE.Mesh(shadowInstGeo, shadowMat);
        this.shadowMesh.frustumCulled = false;
        this.shadowMesh.renderOrder = 0;
        scene.add(this.shadowMesh);
    }

    updateFlowMap(playerPos) {
        const s = this.flowMapSize;
        const ws = CFG.world.size;
        for (let z = 0; z < s; z++) {
            for (let x = 0; x < s; x++) {
                const wx = (x / s - 0.5) * ws;
                const wz = (z / s - 0.5) * ws;
                const dx = playerPos.x - wx;
                const dz = playerPos.z - wz;
                const len = Math.sqrt(dx * dx + dz * dz) || 1;
                const idx = (z * s + x) * 4;
                this.flowMapData[idx] = dx / len;
                this.flowMapData[idx + 1] = dz / len;
                this.flowMapData[idx + 2] = 1;
                this.flowMapData[idx + 3] = 1;
            }
        }
        this.flowMapTexture.needsUpdate = true;
    }

    syncUniforms(dt, playerPos, cameraPos) {
        this.dtU.value = dt;
        this.playerPosU.value.copy(playerPos);
        this.cameraPosU.value.copy(cameraPos);
        this.enemySpeedU.value = CFG.enemies.speed;
        this.enemySizeU.value = CFG.enemies.size;
        this.enemyMaxHealthU.value = CFG.enemies.health;
        this.enemyAttackRangeU.value = CFG.enemies.attackRange;
        this.cullDistU.value = CFG.enemies.cullDistance;
        this.flowInfluenceU.value = CFG.enemies.flowInfluence;
        this.worldSizeU.value = CFG.world.size;
        this.weaponDamageU.value = CFG.weapon.damage;
        this.weaponRangeU.value = CFG.weapon.range;
        this.hitRadiusU.value = CFG.weapon.hitRadius;
        this.projCollisionRadiusU.value = CFG.enemies.size * 0.75 + CFG.projectile.size;

        // Flow map update
        this.flowMapTimer -= dt;
        if (this.flowMapTimer <= 0) {
            this.flowMapTimer = CFG.flowMap.updateInterval;
            this.updateFlowMap(playerPos);
        }
    }

    updateDensity(dt, renderer) {
        // Must clear + accumulate every frame — density values are read in computeUpdate
        // and would compound across frames if not cleared
        renderer.compute(this.computeDensityClear);
        renderer.compute(this.computeDensityAccum);
    }

    uploadProjectilePositions(pool) {
        const stride = this.PROJ_POOL * 4; // offset to row 1 (previous positions)
        for (let i = 0; i < this.PROJ_POOL; i++) {
            const p = pool[i];
            const off = i * 4;
            if (p.active) {
                // Row 0: current position
                this.projPositionsData[off] = p.pos.x;
                this.projPositionsData[off + 1] = p.pos.y;
                this.projPositionsData[off + 2] = p.pos.z;
                this.projPositionsData[off + 3] = 1.0;
                // Row 1: previous position
                this.projPositionsData[stride + off] = p.prevPos.x;
                this.projPositionsData[stride + off + 1] = p.prevPos.y;
                this.projPositionsData[stride + off + 2] = p.prevPos.z;
                this.projPositionsData[stride + off + 3] = 1.0;
            } else {
                this.projPositionsData[off + 3] = 0.0;
                this.projPositionsData[stride + off + 3] = 0.0;
            }
        }
        this.projPositionsTexture.needsUpdate = true;
    }

    runProjectileCollision(renderer) {
        renderer.compute(this.computeProjClear);
        renderer.compute(this.computeProjCollision);
    }

    checkProjectileHits(renderer) {
        if (this._pendingHitPromise) return;
        try {
            this._pendingHitPromise = renderer.getArrayBufferAsync(this.projHitFlagsAttr);
            this._pendingHitPromise.then(buffer => {
                this._hitResults = new Uint32Array(buffer.slice(0));
                this._pendingHitPromise = null;
            }).catch(e => {
                console.warn('[ProjCollision] readback failed:', e);
                this._pendingHitPromise = null;
            });
        } catch (e) {
            console.warn('[ProjCollision] getArrayBufferAsync threw:', e);
            this._pendingHitPromise = null;
        }
    }

    consumeHits() {
        if (!this._hitResults) return [];
        const hits = [];
        for (let i = 0; i < this.PROJ_POOL; i++) {
            if (this._hitResults[i] > 0) hits.push(i);
        }
        this._hitResults = null;
        return hits;
    }

    setRay(origin, direction) {
        this.rayOriginU.value.copy(origin);
        this.rayDirU.value.copy(direction);
    }

    // --- Kill count ---
    clearKillCount(renderer) {
        renderer.compute(this.computeKillBinsClear);
        this._lastKillCount = 0;
    }

    runKillCountReadback(renderer) {
        if (this._pendingKillPromise) return;
        try {
            this._pendingKillPromise = renderer.getArrayBufferAsync(this.killBinsAttr);
            this._pendingKillPromise.then(buffer => {
                const data = new Uint32Array(buffer.slice(0));
                let total = 0;
                for (let i = 0; i < this.KILL_BINS; i++) total += data[i];
                this._lastKillCount = total;
                this._pendingKillPromise = null;
            }).catch(e => { this._pendingKillPromise = null; });
        } catch (e) { this._pendingKillPromise = null; }
    }

    getKillCount() { return this._lastKillCount; }

    // --- Nearby enemy count ---
    runNearbyCount(renderer) {
        renderer.compute(this.computeNearbyClear);
        renderer.compute(this.computeNearbyCount);
    }

    checkNearbyCount(renderer) {
        if (this._pendingNearbyPromise) return;
        try {
            this._pendingNearbyPromise = renderer.getArrayBufferAsync(this.nearbyCountAttr);
            this._pendingNearbyPromise.then(buffer => {
                const data = new Uint32Array(buffer.slice(0));
                this._lastNearbyCount = data[0];
                this._pendingNearbyPromise = null;
            }).catch(e => { this._pendingNearbyPromise = null; });
        } catch (e) { this._pendingNearbyPromise = null; }
    }

    getNearbyCount() { return this._lastNearbyCount; }
}

// ============================================================
//  GPU PARTICLE SYSTEM (pooled)
// ============================================================
class GPUParticleSystem {
    constructor(scene) {
        this.POOL_SIZE = CFG.particles.poolSize;
        this.MAX_SPAWN = 2048;   // max per dispatch
        this.writeHead = 0;
        this.overflowCount = 0;
        this.scene = scene;

        // Storage buffers
        this.positions = instancedArray(this.POOL_SIZE, 'vec3');
        this.velocities = instancedArray(this.POOL_SIZE, 'vec3');
        this.life = instancedArray(this.POOL_SIZE, 'vec4'); // life, maxLife, size, gravityScale
        this.colors = instancedArray(this.POOL_SIZE, 'vec3');

        // Update uniforms
        this.dtU = uniform(0.016);

        // Spawn uniforms
        this.spawnBaseU = uniform(0);
        this.spawnCountU = uniform(0);
        this.spawnPosU = uniform(new THREE.Vector3());
        this.spawnDirU = uniform(new THREE.Vector3());
        this.spawnSpeedU = uniform(5);
        this.spawnSpreadU = uniform(1);
        this.spawnLifeU = uniform(1);
        this.spawnSizeU = uniform(0.3);
        this.spawnColorU = uniform(new THREE.Vector3(1, 0.2, 0.1));
        this.spawnSeedU = uniform(0);
        this.spawnGravityU = uniform(1);

        this.buildComputes();
        this.buildRenderer(scene);
    }

    buildComputes() {
        const POOL = this.POOL_SIZE;
        const positions = this.positions, velocities = this.velocities;
        const life = this.life, colors = this.colors;
        const dt = this.dtU;

        // Init: zero all
        this.computeInit = Fn(() => {
            positions.element(instanceIndex).assign(vec3(0, -99999, 0));
            velocities.element(instanceIndex).assign(vec3(0, 0, 0));
            life.element(instanceIndex).assign(vec4(0, 0, 0, 0));
            colors.element(instanceIndex).assign(vec3(0, 0, 0));
        })().compute(POOL);

        // Spawn: write [spawnBase..spawnBase+spawnCount) with new particles
        this.computeSpawn = Fn(() => {
            If(float(instanceIndex).lessThan(this.spawnCountU), () => {
                const idx = float(instanceIndex).add(this.spawnBaseU).mod(float(POOL));
                const p = positions.element(idx);
                const v = velocities.element(idx);
                const l = life.element(idx);
                const c = colors.element(idx);

                const seed = this.spawnSeedU.add(float(instanceIndex));
                const r1 = hash(seed), r2 = hash(seed.add(1)), r3 = hash(seed.add(2));
                const r4 = hash(seed.add(3)), r5 = hash(seed.add(4)), r6 = hash(seed.add(5));

                // Position = origin + random spread
                p.x.assign(this.spawnPosU.x.add(r1.sub(0.5).mul(this.spawnSpreadU)));
                p.y.assign(this.spawnPosU.y.add(r2.sub(0.5).mul(this.spawnSpreadU)));
                p.z.assign(this.spawnPosU.z.add(r3.sub(0.5).mul(this.spawnSpreadU)));

                // Velocity = dir * speed + random spread
                v.x.assign(this.spawnDirU.x.add(r4.sub(0.5).mul(this.spawnSpreadU)).mul(this.spawnSpeedU));
                v.y.assign(this.spawnDirU.y.add(r5.sub(0.5).mul(this.spawnSpreadU)).mul(this.spawnSpeedU));
                v.z.assign(this.spawnDirU.z.add(r6.sub(0.5).mul(this.spawnSpreadU)).mul(this.spawnSpeedU));

                // Life
                const lifeVar = float(0.8).add(r1.mul(0.4));
                l.x.assign(this.spawnLifeU.mul(lifeVar)); // life
                l.y.assign(this.spawnLifeU.mul(lifeVar)); // maxLife
                l.z.assign(this.spawnSizeU.mul(float(0.7).add(r2.mul(0.6)))); // size
                l.w.assign(this.spawnGravityU); // gravity scale

                // Color with slight variation
                c.x.assign(this.spawnColorU.x.mul(float(0.8).add(r3.mul(0.4))));
                c.y.assign(this.spawnColorU.y.mul(float(0.8).add(r4.mul(0.4))));
                c.z.assign(this.spawnColorU.z.mul(float(0.8).add(r5.mul(0.4))));
            });
        })().compute(this.MAX_SPAWN);

        // Update: physics + life decay
        this.computeUpdate = Fn(() => {
            const l = life.element(instanceIndex);
            If(l.x.greaterThan(0), () => {
                const p = positions.element(instanceIndex);
                const v = velocities.element(instanceIndex);
                p.addAssign(v.mul(dt));
                v.y.subAssign(float(20).mul(l.w).mul(dt)); // gravity
                v.mulAssign(float(0.97)); // drag
                l.x.subAssign(dt); // decay
            });
        })().compute(POOL);
    }

    buildRenderer(scene) {
        const material = new THREE.SpriteNodeMaterial();
        material.transparent = true;
        material.blending = THREE.AdditiveBlending;
        material.depthWrite = false;

        const instLife = this.life.element(instanceIndex);
        const instColor = this.colors.element(instanceIndex);
        const fadeT = instLife.x.div(instLife.y.max(0.001)).clamp(0, 1);
        const alive = step(float(0.001), instLife.x);

        material.positionNode = this.positions.toAttribute();
        material.scaleNode = instLife.z.mul(alive).mul(fadeT);
        material.colorNode = instColor;
        material.opacityNode = fadeT.mul(fadeT).mul(alive).mul(0.8);

        // Random rotation per particle — breaks up the uniform square look cheaply
        material.rotationNode = hash(instanceIndex).mul(Math.PI * 2);

        const sprite = new THREE.Sprite(material);
        sprite.count = this.POOL_SIZE;
        sprite.frustumCulled = false;
        scene.add(sprite);
    }

    // Queue a spawn and return true. Caller must dispatch computeSpawn after.
    // overrides: optional object to override preset values (color, size, life, etc.)
    emit(pos, dir, count, type, overrides) {
        const presets = {
            blood:     { speed: 8,  spread: 1.5, life: 0.8,  size: 0.5, color: [0.8, 0.05, 0.02], gravity: 1.2 },
            muzzle:    { speed: 4,  spread: 0.4, life: 0.08, size: 0.08,color: [1.0, 0.9, 0.3],   gravity: 0 },
            exhaust:   { speed: 18, spread: 0.6, life: 0.2,  size: 0.12,color: [1.0, 0.8, 0.3],   gravity: 0.2 },
            trail:     { speed: 0.3,spread: 0.08,life: 2.0,  size: 0.08,color: [1.0, 0.7, 0.2],   gravity: 0.0 },
            explosion: { speed: 14, spread: 2.0, life: 1.2,  size: 0.7, color: [1.0, 0.5, 0.1],   gravity: 0.8 },
            spark:     { speed: 20, spread: 0.8, life: 0.5,  size: 0.1, color: [1.0, 0.95, 0.6],  gravity: 0.3 },
        };
        const cfg = overrides ? Object.assign({}, presets[type] || presets.muzzle, overrides) : (presets[type] || presets.muzzle);
        count = Math.min(count, this.MAX_SPAWN);

        // Pool overflow check
        this.writeHead = this.writeHead % this.POOL_SIZE;
        if (this.writeHead + count > this.POOL_SIZE) {
            this.overflowCount++;
            if (this.overflowCount % 100 === 1) {
                console.info(`[Particles] Pool wraparound #${this.overflowCount} at writeHead=${this.writeHead}, pool=${this.POOL_SIZE}. Consider increasing pool size.`);
            }
        }

        this.spawnBaseU.value = this.writeHead;
        this.spawnCountU.value = count;
        this.spawnPosU.value.copy(pos);
        this.spawnDirU.value.copy(dir);
        this.spawnSpeedU.value = cfg.speed;
        this.spawnSpreadU.value = cfg.spread;
        this.spawnLifeU.value = cfg.life;
        this.spawnSizeU.value = cfg.size;
        this.spawnColorU.value.set(cfg.color[0], cfg.color[1], cfg.color[2]);
        this.spawnSeedU.value = performance.now() * 100 + this.writeHead;
        this.spawnGravityU.value = cfg.gravity;

        this.writeHead += count;
    }
}

// ============================================================
//  EXPLOSION SPHERE POOL (visual blast radius feedback)
// ============================================================
class ExplosionSpherePool {
    constructor(scene, poolSize = 16) {
        this.pool = [];
        const geo = new THREE.SphereGeometry(1, 16, 12);
        for (let i = 0; i < poolSize; i++) {
            const mat = new THREE.MeshBasicMaterial({
                color: 0xff8822,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.visible = false;
            scene.add(mesh);
            this.pool.push({ mesh, mat, active: false, age: 0, duration: 0.35, maxRadius: 1 });
        }
        this.nextIdx = 0;
    }
    spawn(position, radius, damageNorm) {
        const s = this.pool[this.nextIdx];
        this.nextIdx = (this.nextIdx + 1) % this.pool.length;
        s.mesh.position.copy(position);
        s.maxRadius = radius;
        s.age = 0;
        s.active = true;
        s.mesh.visible = true;
        s.mesh.scale.setScalar(0.1);
        s.mat.opacity = 0.35;
        // Color shifts with damage: orange (low) → bright pink-white (high)
        const dn = damageNorm || 0.5;
        s.mat.color.setRGB(1.0, 0.55 - dn * 0.25, 0.13 + dn * 0.25);
    }
    update(dt) {
        for (const s of this.pool) {
            if (!s.active) continue;
            s.age += dt;
            const t = Math.min(1, s.age / s.duration);
            const ease = 1 - Math.pow(1 - t, 3); // ease-out cubic
            s.mesh.scale.setScalar(s.maxRadius * ease);
            s.mat.opacity = 0.35 * (1 - t);
            if (t >= 1) { s.active = false; s.mesh.visible = false; }
        }
    }
}

// ============================================================
//  PROJECTILE SYSTEM (CPU - small pool)
// ============================================================
class ProjectileSystem {
    constructor(scene, terrain) {
        this.scene = scene;
        this.terrain = terrain;
        this.POOL_SIZE = CFG.projectile.poolSize;
        this.pool = [];
        const geo = new THREE.SphereGeometry(CFG.projectile.size, 6, 6);
        for (let i = 0; i < this.POOL_SIZE; i++) {
            const mat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.visible = false;
            scene.add(mesh);
            this.pool.push({ mesh, mat, pos: new THREE.Vector3(), prevPos: new THREE.Vector3(), vel: new THREE.Vector3(), active: false, life: 0, trailTimer: 0, powerNorm: 0.5, speedNorm: 0.5, explosionRadius: CFG.projectile.explosionRadius, explosionForce: CFG.projectile.explosionForce });
        }
        this.nextIdx = 0;
    }

    fire(origin, direction, speed, damage, wpnParams, life, explosionRadius, explosionForce) {
        const p = this.pool[this.nextIdx];
        this.nextIdx = (this.nextIdx + 1) % this.POOL_SIZE;
        p.pos.copy(origin);
        p.prevPos.copy(origin);
        p.vel.copy(direction).multiplyScalar(speed || CFG.projectile.speed);
        p.damage = damage || CFG.projectile.explosionDamage;
        p.active = true;
        p.life = life || CFG.projectile.maxLife;
        p.explosionRadius = explosionRadius || CFG.projectile.explosionRadius;
        p.explosionForce = explosionForce || CFG.projectile.explosionForce;
        p.trailTimer = 0;
        p.mesh.visible = true;
        p.mesh.position.copy(origin);

        // Visual differentiation based on weapon params
        const pw = wpnParams ? wpnParams.power / 255 : 0.5;
        const sp = wpnParams ? wpnParams.speed / 255 : 0.5;
        p.powerNorm = pw;
        p.speedNorm = sp;
        // Color: yellow (low power) → orange → red/magenta (high power)
        p.mat.color.setRGB(1.0, 0.9 - pw * 0.7, 0.3 - pw * 0.15 + (pw > 0.7 ? (pw - 0.7) * 1.0 : 0));
        // Size: 0.6x (low power) → 2.5x (high power) relative to base
        p.mesh.scale.setScalar(0.6 + pw * 1.9);
    }

    update(dt, particles, renderer) {
        const impacts = [];
        const half = CFG.world.size * 0.48;
        for (const p of this.pool) {
            if (!p.active) continue;
            // Save previous position for swept collision
            p.prevPos.copy(p.pos);
            // Physics — gravity scales down with speed so fast shots fly flat,
            // slow shots arc gently (not like grenades)
            const spd = Math.sqrt(p.vel.x * p.vel.x + p.vel.y * p.vel.y + p.vel.z * p.vel.z);
            const gravScale = Math.min(1, spd / 200); // full gravity at 200+ m/s, reduced below
            p.vel.y -= CFG.projectile.gravity * gravScale * dt;
            p.pos.addScaledVector(p.vel, dt);
            p.mesh.position.copy(p.pos);
            // Trail particles — vary with weapon params
            p.trailTimer -= dt;
            if (p.trailTimer <= 0) {
                p.trailTimer = CFG.projectile.trailInterval;
                const pw = p.powerNorm, sp = p.speedNorm;
                const trailOvr = {
                    life: 0.5 + sp * 2.5,                             // 0.5s (slow) → 3.0s (fast)
                    size: 0.04 + pw * 0.12,                           // tiny → chunky with power
                    color: [1.0, 0.7 - pw * 0.5, 0.2 - pw * 0.12],  // yellow → red with power
                };
                particles.emit(p.pos, new THREE.Vector3(0, 0, 0), CFG.particles.trailCount, 'trail', trailOvr);
                renderer.compute(particles.computeSpawn);
            }
            // Life timeout
            p.life -= dt;
            if (p.life <= 0) { p.active = false; p.mesh.visible = false; continue; }
            // Terrain collision
            const th = this.terrain.getHeight(p.pos.x, p.pos.z);
            if (p.pos.y <= th) {
                p.active = false; p.mesh.visible = false;
                impacts.push({ pos: new THREE.Vector3(p.pos.x, th, p.pos.z), damage: p.damage || CFG.projectile.explosionDamage, explosionRadius: p.explosionRadius, explosionForce: p.explosionForce });
                continue;
            }
            // Out of bounds
            if (Math.abs(p.pos.x) > half || Math.abs(p.pos.z) > half) { p.active = false; p.mesh.visible = false; }
        }
        return impacts;
    }
}

// ============================================================
//  PLAYER
// ============================================================
class Player {
    constructor(camera, terrain) {
        this.camera = camera;
        this.terrain = terrain;
        this.position = new THREE.Vector3(0, 0, 0);
        this.velocity = new THREE.Vector3();
        this.yaw = 0; this.pitch = 0;
        this.grounded = false;
        this.health = CFG.player.maxHealth;
        this.keys = {};
        this.mouseDX = 0; this.mouseDY = 0;
        this.locked = false;
        this.ammo = CFG.weapon.maxAmmo;
        this.fireTimer = 0;
        this.shooting = false;
        // Weapon parameters (0–255 each)
        this.wpnParams = { spread: 230, rate: 50, power: 160, speed: 60 };
        this.wpnPresets = [
            { spread: 230, rate: 50, power: 160, speed: 60 },   // 7: Shotgun — wall of pellets, close-range devastation
            { spread: 5, rate: 20, power: 255, speed: 255 },    // 8: Sniper — single massive boom at long range
            { spread: 255, rate: 255, power: 255, speed: 255 }, // 9: GIVE IT ALL YOU'VE GOT
        ];
        this.heat = 0;
        this.barrelGlow = 0; // 0–1: barrel emissive glow from high rate firing
        this.adjustingParam = null; // which param key 1-4 is held
        this.adjustMouseAccum = 0;
        this.position.set(0, this.terrain.getHeight(0, 0) + CFG.player.height, 0);
        this.setupInput();
        this.buildWeaponModel();
    }

    setupInput() {
        const paramKeys = { 'Digit1': 'spread', 'Digit2': 'rate', 'Digit3': 'power', 'Digit4': 'speed' };
        document.addEventListener('keydown', e => {
            this.keys[e.code] = true;
            // 1-4: start adjusting weapon parameter
            if (paramKeys[e.code] && this.locked) {
                this.adjustingParam = paramKeys[e.code];
                this.adjustMouseAccum = 0;
            }
            // 7/8/9: load preset
            if (e.code === 'Digit7' && this.locked) Object.assign(this.wpnParams, this.wpnPresets[0]);
            if (e.code === 'Digit8' && this.locked) Object.assign(this.wpnParams, this.wpnPresets[1]);
            if (e.code === 'Digit9' && this.locked) Object.assign(this.wpnParams, this.wpnPresets[2]);
        });
        document.addEventListener('keyup', e => {
            this.keys[e.code] = false;
            if (paramKeys[e.code]) {
                // Find if any other param key is still held — that one takes over
                const stillHeld = Object.keys(paramKeys).find(k => this.keys[k]);
                this.adjustingParam = stillHeld ? paramKeys[stillHeld] : null;
            }
        });
        document.addEventListener('mousemove', e => {
            if (!this.locked) return;
            // Suppress mouselook while adjusting weapon params
            if (!this.adjustingParam) {
                this.mouseDX += e.movementX; this.mouseDY += e.movementY;
            }
            // If adjusting a weapon param, horizontal mouse movement changes it
            if (this.adjustingParam) {
                this.adjustMouseAccum += e.movementX;
                const sens = 0.5; // pixels per unit
                const delta = Math.trunc(this.adjustMouseAccum * sens);
                if (delta !== 0) {
                    this.wpnParams[this.adjustingParam] = Math.max(0, Math.min(255, this.wpnParams[this.adjustingParam] + delta));
                    this.adjustMouseAccum -= delta / sens;
                }
            }
        });
        document.addEventListener('mousedown', e => { if (e.button === 0 && this.locked) this.shooting = true; });
        document.addEventListener('mouseup', e => { if (e.button === 0) this.shooting = false; });
    }

    buildWeaponModel() {
        this.weaponGroup = new THREE.Group();
        this.gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.35), new THREE.MeshLambertMaterial({ color: 0x333333 }));
        this.weaponGroup.add(this.gunBody);
        this.gunBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.2), new THREE.MeshLambertMaterial({ color: 0x222222 }));
        this.weaponGroup.add(this.gunBarrel);
        this.muzzleFlash = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 6), new THREE.MeshBasicMaterial({ color: 0xffff44, transparent: true, opacity: 0 }));
        this.weaponGroup.add(this.muzzleFlash);
        this.camera.add(this.weaponGroup);
        this.applyHandedness();
    }

    applyHandedness() {
        // Flip gun to the correct side: left-handed = gun on left (negative X), right-handed = gun on right (positive X)
        const side = CFG.handedness === 'left' ? -1 : 1;
        this.weaponGroup.scale.x = side;
        this.handSide = side;
        this.syncWeaponPositions();
    }

    syncWeaponPositions() {
        const bx = CFG.weapon.barrelX, by = CFG.weapon.barrelY, bz = CFG.weapon.barrelZ;
        this.gunBody.position.set(bx, by - 0.04, bz + 0.30);
        this.gunBarrel.position.set(bx, by, bz + 0.13);
        this.muzzleFlash.position.set(bx, by, bz);
    }

    update(dt) {
        const sens = 0.002;
        this.yaw -= this.mouseDX * sens;
        this.pitch -= this.mouseDY * sens;
        this.pitch = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, this.pitch));
        this.mouseDX = 0; this.mouseDY = 0;

        const forward = new THREE.Vector3(-Math.sin(this.yaw), 0, -Math.cos(this.yaw));
        const right = new THREE.Vector3(Math.cos(this.yaw), 0, -Math.sin(this.yaw));
        const move = new THREE.Vector3();
        if (this.keys['KeyW']) move.add(forward);
        if (this.keys['KeyS']) move.sub(forward);
        if (this.keys['KeyA']) move.sub(right);
        if (this.keys['KeyD']) move.add(right);
        if (move.lengthSq() > 0) move.normalize();

        let speed = CFG.player.walkSpeed;
        if (this.keys['ShiftLeft'] || this.keys['ShiftRight']) speed *= CFG.player.sprintMult;

        if (this.grounded && move.lengthSq() > 0) {
            const normal = this.terrain.getNormal(this.position.x, this.position.z);
            const slopeAngle = Math.acos(Math.min(1, normal.y));
            const slopeDir = new THREE.Vector3(normal.x, 0, normal.z);
            if (slopeDir.lengthSq() > 0.001) {
                slopeDir.normalize();
                const factor = 1 + move.dot(slopeDir) * Math.sin(slopeAngle) * CFG.player.slopeEffect;
                speed *= Math.max(0.2, factor);
            }
        }

        this.velocity.x = move.x * speed;
        this.velocity.z = move.z * speed;
        if (this.keys['Space'] && this.grounded) { this.velocity.y = CFG.player.jumpForce; this.grounded = false; }
        this.velocity.y -= CFG.player.gravity * dt;
        this.position.x += this.velocity.x * dt;
        this.position.z += this.velocity.z * dt;
        this.position.y += this.velocity.y * dt;

        const groundH = this.terrain.getHeight(this.position.x, this.position.z) + CFG.player.height;
        if (this.position.y <= groundH) { this.position.y = groundH; this.velocity.y = 0; this.grounded = true; }

        const half = CFG.world.size * 0.48;
        this.position.x = Math.max(-half, Math.min(half, this.position.x));
        this.position.z = Math.max(-half, Math.min(half, this.position.z));

        this.camera.position.copy(this.position);
        this.camera.rotation.order = 'YXZ';
        this.camera.rotation.set(this.pitch, this.yaw, 0);

        if (this.grounded && move.lengthSq() > 0) {
            const t = performance.now() / 1000;
            this.weaponGroup.position.y = Math.sin(t * speed * 0.8) * 0.015;
            this.weaponGroup.position.x = Math.cos(t * speed * 0.4) * 0.008;
        } else { this.weaponGroup.position.y *= 0.9; this.weaponGroup.position.x *= 0.9; }

        if (this.fireTimer > 0) this.fireTimer -= dt;
        this.muzzleFlash.material.opacity *= 0.85;
        if (this.muzzleFlash.material.opacity < 0.01) this.muzzleFlash.material.opacity = 0;

        // Barrel glow: accumulates when shooting at high rate, decays when idle
        const rateNorm = this.wpnParams.rate / 255;
        if (this.shooting && rateNorm > 0.2) {
            this.barrelGlow = Math.min(1, this.barrelGlow + rateNorm * dt * 4);
        } else {
            this.barrelGlow = Math.max(0, this.barrelGlow - dt * 2.5);
        }
        if (this.gunBarrel && this.barrelGlow > 0.01) {
            const g = this.barrelGlow;
            this.gunBarrel.material.emissive.setRGB(g * 0.9, g * 0.15, 0);
        } else if (this.gunBarrel) {
            this.gunBarrel.material.emissive.setRGB(0, 0, 0);
        }

        // Passive heat cooling
        if (this.heat > 0) {
            this.heat = Math.max(0, this.heat - CFG.heat.coolRate * dt);
        }
    }

    // Heat cost for current weapon config
    getHeatPerShot() {
        const s = this.wpnParams.spread / 255;
        const r = this.wpnParams.rate / 255;
        const p = this.wpnParams.power / 255;
        const f = this.wpnParams.speed / 255;
        return CFG.heat.spreadCost * s + CFG.heat.rateCost * r + CFG.heat.powerCost * p + CFG.heat.speedCost * f;
    }

    // Raw weapon stats (kept for backward compat / UI display)
    getFireRate() { return 2 + (this.wpnParams.rate / 255) * 18; } // 2–20 shots/sec
    getSpread() { return (this.wpnParams.spread / 255) * 1.047; } // 0–60° in radians
    getProjectileSpeed() { return 30 + (this.wpnParams.speed / 255) * 270; } // 30–300 m/s
    getDamage() { return 1 + (this.wpnParams.power / 255) * 99; } // 1–100

    // Soft-coupled derived weapon stats: raw params cross-influence each other
    // to make archetypes emerge naturally (shotgun = close-range wall of pellets,
    // sniper = single devastating long-range shot, flamethrower = rapid weak stream)
    getDerivedWeaponStats() {
        const s = this.wpnParams.spread / 255;
        const r = this.wpnParams.rate / 255;
        const p = this.wpnParams.power / 255;
        const f = this.wpnParams.speed / 255;

        // 1. Spread → more pellets (1–12)
        const pelletCount = 1 + Math.floor(s * 11);

        // 2. Fire rate (unchanged)
        const fireRate = 2 + r * 18;

        // 3. Spread → speed penalty (-50% at max spread)
        const baseSpeed = 30 + f * 270;
        const effectiveSpeed = baseSpeed * (1 - s * 0.5);

        // 4. Spread → shorter life, Speed → longer life
        const effectiveLife = (1.5 + f * 5) * (1 - s * 0.5);

        // 5. Rate → per-hit damage penalty (-35% at max rate), split across pellets
        const baseDamage = 1 + p * 99;
        const damagePerPellet = (baseDamage * (1 - r * 0.35)) / pelletCount;

        // 6. Spread angle (unchanged)
        const spreadAngle = s * 1.047;

        // 7. Spread → smaller explosion radius per pellet
        const baseRadius = CFG.projectile.explosionRadius * (0.3 + p * 0.85);
        const effectiveRadius = (baseRadius / Math.sqrt(pelletCount)) * (1 - s * 0.3);
        const effectiveForce = CFG.projectile.explosionForce * (effectiveRadius / CFG.projectile.explosionRadius);

        // Heat (unchanged formula)
        const heatPerShot = CFG.heat.spreadCost * s + CFG.heat.rateCost * r + CFG.heat.powerCost * p + CFG.heat.speedCost * f;

        return { pelletCount, fireRate, effectiveSpeed, effectiveLife,
                 damagePerPellet, spreadAngle, effectiveRadius, effectiveForce, heatPerShot };
    }

    tryShoot() {
        if (!this.shooting || this.fireTimer > 0) return null;

        // Get all soft-coupled derived stats
        const stats = this.getDerivedWeaponStats();

        // Add heat — asymptotic curve: heat gain slows dramatically near max
        // so 90→95% takes noticeably longer than 85→90%, and 95→100% longer still.
        // Minimum multiplier of 0.08 ensures you WILL still blow up eventually.
        const heatNorm = this.heat / CFG.heat.maxHeat;
        const resistance = 1 - heatNorm * heatNorm * heatNorm; // cubic falloff
        const effectiveHeat = stats.heatPerShot * Math.max(0.08, resistance);
        this.heat += effectiveHeat;
        if (this.heat >= CFG.heat.maxHeat) {
            this.heat = CFG.heat.maxHeat;
            return 'overheat'; // caller handles explosion/death
        }

        this.fireTimer = 1 / stats.fireRate;
        this.pitch += 0.01;
        this.weaponGroup.position.z = 0.04;

        const spreadNorm = this.wpnParams.spread / 255;

        // Muzzle flash: size scales with spread, color with power
        const pw = this.wpnParams.power / 255;
        this.muzzleFlash.scale.setScalar(1 + spreadNorm * 2.5); // 1x → 3.5x
        this.muzzleFlash.material.color.setRGB(1.0, 0.95 - pw * 0.55, 0.4 - pw * 0.3);
        this.muzzleFlash.material.opacity = 1;

        const side = this.handSide || (CFG.handedness === 'left' ? -1 : 1);
        // Compute barrel world position ONCE for all pellets
        const barrelLocal = new THREE.Vector3(CFG.weapon.barrelX * side, CFG.weapon.barrelY, CFG.weapon.barrelZ);
        const barrelWorldPos = barrelLocal.applyQuaternion(this.camera.quaternion).add(this.camera.position);
        // Base aim direction (camera forward)
        const baseAim = new THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.quaternion);
        // Camera-local axes for cone spread (right and up in view space)
        const camRight = new THREE.Vector3(1, 0, 0).applyQuaternion(this.camera.quaternion);
        const camUp = new THREE.Vector3(0, 1, 0).applyQuaternion(this.camera.quaternion);

        const shots = [];
        for (let i = 0; i < stats.pelletCount; i++) {
            // Cone spread: random angle + random radius (sqrt for uniform disk)
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.sqrt(Math.random()) * stats.spreadAngle;
            const offR = Math.cos(angle) * radius;
            const offU = Math.sin(angle) * radius;
            // Offset the aim direction in camera-local space
            const pelletDir = baseAim.clone()
                .addScaledVector(camRight, offR)
                .addScaledVector(camUp, offU)
                .normalize();
            // All pellets share the same barrel origin, direction varies
            const convergePoint = barrelWorldPos.clone().addScaledVector(pelletDir, CFG.weapon.convergeDist);
            const barrelDir = convergePoint.sub(barrelWorldPos).normalize();

            shots.push({
                origin: barrelWorldPos.clone(),
                direction: barrelDir,
                speed: stats.effectiveSpeed,
                damage: stats.damagePerPellet,
                life: stats.effectiveLife,
                explosionRadius: stats.effectiveRadius,
                explosionForce: stats.effectiveForce,
            });
        }
        return shots; // Array of pellet shots
    }

    reload() { this.ammo = CFG.weapon.maxAmmo; }

    takeDamage(amount) {
        this.health = Math.max(0, this.health - amount);
        if (CFG.debug.damageFlash) {
            document.getElementById('hit-flash').style.opacity = '1';
            setTimeout(() => document.getElementById('hit-flash').style.opacity = '0', 100);
        }
    }
}

// ============================================================
//  PICKUPS (CPU - small count)
// ============================================================
class Pickup {
    constructor(scene, terrain, type, position) {
        this.terrain = terrain; this.type = type; this.active = true;
        this.lifetime = CFG.pickups.dropLifetime || 20;
        this.age = 0;
        const size = 0.7;
        const color = type === 'health' ? 0x00ff44 : 0xff8800;
        const geo = new THREE.TetrahedronGeometry(size);
        this.mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color }));
        this.mesh.scale.set(1, 6.6, 1);  // tall and pointy — 3x previous
        // Spawn at hit position, then arc outward
        this.mesh.position.copy(position);
        this.mesh.position.y = position.y || terrain.getHeight(position.x, position.z) + 1;
        const hoverY = terrain.getHeight(position.x, position.z) + CFG.player.height * 0.85;
        this.targetY = hoverY;  // chest height
        // Launch arc: random horizontal direction + upward
        const angle = Math.random() * Math.PI * 2;
        const hSpeed = 6 + Math.random() * 6;
        this.vel = new THREE.Vector3(Math.cos(angle) * hSpeed, 12 + Math.random() * 6, Math.sin(angle) * hSpeed);
        this.launched = true;  // in arc phase
        this.mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
        scene.add(this.mesh);
    }
    update(dt, playerPos) {
        if (!this.active) return null;
        this.age += dt;
        if (this.age > this.lifetime) { this.active = false; this.mesh.visible = false; return null; }
        // Fade out in last 3 seconds
        const fadeStart = this.lifetime - 3;
        if (this.age > fadeStart) {
            const fade = 1 - (this.age - fadeStart) / 3;
            this.mesh.material.opacity = fade;
            this.mesh.material.transparent = true;
        }
        if (this.launched) {
            // Arc phase: physics sim
            this.vel.y -= 28 * dt;  // gravity
            this.mesh.position.addScaledVector(this.vel, dt);
            // Tumble during flight
            this.mesh.rotation.x += dt * 8;
            this.mesh.rotation.z += dt * 5;
            // Land when falling and at/below hover height
            const groundY = this.terrain.getHeight(this.mesh.position.x, this.mesh.position.z);
            this.targetY = groundY + CFG.player.height * 0.85;
            if (this.vel.y < 0 && this.mesh.position.y <= this.targetY) {
                this.mesh.position.y = this.targetY;
                this.launched = false;
                // Snap rotation to upright for clean spin
                this.mesh.rotation.set(0, this.mesh.rotation.y, 0);
            }
            // Don't go below ground
            if (this.mesh.position.y < groundY + 0.5) {
                this.mesh.position.y = groundY + 0.5;
                this.launched = false;
                this.mesh.rotation.set(0, this.mesh.rotation.y, 0);
            }
        } else {
            // Idle: bob gently + spin on Y axis
            const t = performance.now() / 1000;
            const groundY = this.terrain.getHeight(this.mesh.position.x, this.mesh.position.z);
            this.targetY = groundY + CFG.player.height * 0.85;
            this.mesh.position.y = this.targetY + Math.sin(t * CFG.pickups.bobSpeed + this.age) * CFG.pickups.bobHeight;
            this.mesh.rotation.y += dt * 3;
        }
        // Collection check
        const dx = playerPos.x - this.mesh.position.x, dz = playerPos.z - this.mesh.position.z;
        if (Math.sqrt(dx*dx + dz*dz) < 3.5) { this.active = false; this.mesh.visible = false; return this.type; }
        return null;
    }
    dispose(scene) { scene.remove(this.mesh); this.mesh.geometry.dispose(); this.mesh.material.dispose(); }
}

class PickupManager {
    constructor(scene, terrain) {
        this.scene = scene; this.terrain = terrain; this.pickups = [];
        this.recentHitPositions = [];  // ring buffer of recent hit/explosion positions
        this.MAX_DROPS = 60;           // max active pickups on the ground
    }
    spawnAll() {
        // Clear any existing pickups (called on round start / terrain regen)
        this.pickups.forEach(p => p.dispose(this.scene));
        this.pickups = [];
        this.recentHitPositions = [];
    }
    recordHitPosition(pos) {
        this.recentHitPositions.push(pos.clone());
        if (this.recentHitPositions.length > 20) this.recentHitPositions.shift();
    }
    spawnDrops(newKills) {
        // For each kill, chance to drop a pickup at a recent hit position
        const dropChance = CFG.pickups.dropChance || 0.12;
        for (let i = 0; i < newKills; i++) {
            if (Math.random() > dropChance) continue;
            if (this.pickups.filter(p => p.active).length >= this.MAX_DROPS) break;
            // Pick a position: use recent hit pos if available, else skip
            const pos = this.recentHitPositions.length > 0
                ? this.recentHitPositions[Math.floor(Math.random() * this.recentHitPositions.length)]
                : null;
            if (!pos) continue;
            // Add some random scatter so drops aren't all stacked
            const dropPos = pos.clone();
            dropPos.x += (Math.random() - 0.5) * 4;
            dropPos.z += (Math.random() - 0.5) * 4;
            const type = Math.random() < 0.5 ? 'health' : 'ammo';
            this.pickups.push(new Pickup(this.scene, this.terrain, type, dropPos));
        }
    }
    update(dt, player) {
        for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            const r = p.update(dt, player.position);
            if (r === 'health') player.health = Math.min(CFG.player.maxHealth, player.health + CFG.pickups.healthAmount);
            else if (r === 'ammo') player.ammo = Math.min(CFG.weapon.maxAmmo, player.ammo + CFG.pickups.ammoAmount);
            // Remove inactive pickups to free memory
            if (!p.active) { p.dispose(this.scene); this.pickups.splice(i, 1); }
        }
    }
}

// ============================================================
//  AUDIO ENGINE (Web Audio API + Three.js spatial)
// ============================================================
class AudioEngine {
    constructor(camera) {
        this.listener = new THREE.AudioListener();
        camera.add(this.listener);
        this.ctx = this.listener.context;

        // Mixer chain: sources → category gain → master gain → destination
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = CFG.audio.masterVolume;
        this.masterGain.connect(this.ctx.destination);

        this.sfxGain = this.ctx.createGain();
        this.sfxGain.gain.value = CFG.audio.sfxVolume;
        this.sfxGain.connect(this.masterGain);

        this.musicGain = this.ctx.createGain();
        this.musicGain.gain.value = CFG.audio.musicVolume;
        this.musicGain.connect(this.masterGain);

        // Pre-generate reusable noise buffers
        this._noiseBufs = {};
        [0.05, 0.1, 0.3, 1.0].forEach(d => {
            const len = Math.floor(this.ctx.sampleRate * d);
            const buf = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;
            this._noiseBufs[d] = buf;
        });

        // Distortion curve (shared)
        this._distCurve = new Float32Array(256);
        for (let i = 0; i < 256; i++) this._distCurve[i] = Math.tanh(((i / 128) - 1) * 3);

        this.samples = {};
        this.activeSounds = 0;
        this.currentMusic = null;

        // Resume on first interaction
        const resume = () => { if (this.ctx.state === 'suspended') this.ctx.resume(); };
        document.addEventListener('click', resume);
        document.addEventListener('keydown', resume);
    }

    syncVolumes() {
        this.masterGain.gain.value = CFG.audio.masterVolume;
        this.sfxGain.gain.value = CFG.audio.sfxVolume;
        this.musicGain.gain.value = CFG.audio.musicVolume;
    }

    // Create a 3D panner at a world position
    _panner(pos) {
        const p = this.ctx.createPanner();
        p.panningModel = 'HRTF';
        p.distanceModel = 'inverse';
        p.refDistance = CFG.audio.spatialRefDist;
        p.maxDistance = CFG.audio.spatialMaxDist;
        p.rolloffFactor = CFG.audio.spatialRolloff;
        p.setPosition(pos.x, pos.y, pos.z);
        p.connect(this.sfxGain);
        return p;
    }

    // Get a pre-generated noise buffer (closest match)
    _noise(dur) {
        const keys = Object.keys(this._noiseBufs).map(Number).sort((a,b) => a - b);
        const best = keys.find(k => k >= dur) || keys[keys.length - 1];
        return this._noiseBufs[best];
    }

    // Play a synth preset. pos=null → non-positional (player's own gun etc.)
    // params: optional extra data passed to the synth (e.g. wpnParams for gunshot)
    play(preset, pos = null, params = null) {
        if (this.activeSounds >= CFG.audio.maxSounds) return;
        if (this.ctx.state === 'suspended') return;

        const dest = pos ? this._panner(pos) : this.sfxGain;
        const v = Math.random();
        this.activeSounds++;

        const done = (nodes, sec) => {
            setTimeout(() => {
                nodes.forEach(n => { try { n.disconnect(); } catch(e) {} });
                if (pos) try { dest.disconnect(); } catch(e) {}
                this.activeSounds--;
            }, sec * 1000 + 50);
        };

        const synth = this['_' + preset];
        if (synth) synth.call(this, dest, v, done, params);
    }

    // === SYNTH PRESETS ===

    // Gunshot: noise crack + sawtooth thump + snap — parameterized by weapon state
    // Power → deeper bass, longer decay, more distortion
    // Speed → sharper crack/snap transient
    // Spread → wider noise band (lower Q), broader character
    // Rate → shorter envelope (staccato at high rate)
    _gunshot(dest, v, done, wpnParams) {
        const ctx = this.ctx, now = ctx.currentTime;
        const pw = wpnParams ? wpnParams.power / 255 : 0.5;
        const sp = wpnParams ? wpnParams.speed / 255 : 0.5;
        const sd = wpnParams ? wpnParams.spread / 255 : 0.5;
        const rt = wpnParams ? wpnParams.rate / 255 : 0.5;

        // Envelope shortens at high rate (staccato bursts)
        const envScale = 1.0 - rt * 0.4; // 1.0 → 0.6

        // Noise crack — spread widens band, power adds volume
        const noise = ctx.createBufferSource();
        noise.buffer = this._noise(0.1);
        const filter = ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(2000 + v * 2000 + sp * 2000, now);
        filter.frequency.exponentialRampToValueAtTime(200 + pw * 400, now + 0.06 * envScale);
        filter.Q.value = 0.8 + (1 - sd) * 3; // wide spread = low Q (broad), tight = high Q (focused)
        const dist = ctx.createWaveShaper();
        dist.curve = this._distCurve;
        const nGain = ctx.createGain();
        nGain.gain.setValueAtTime(0.3 + pw * 0.4 + sd * 0.1, now);
        nGain.gain.exponentialRampToValueAtTime(0.001, now + 0.07 * envScale);
        noise.connect(filter); filter.connect(dist); dist.connect(nGain); nGain.connect(dest);

        // Thump body — power deepens pitch and adds weight
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';
        const baseFreq = 180 - pw * 120; // 180Hz (plinky) → 60Hz (deep boom)
        osc.frequency.setValueAtTime(baseFreq + v * 20, now);
        osc.frequency.exponentialRampToValueAtTime(20 + (1 - pw) * 25, now + 0.06 * envScale);
        const oGain = ctx.createGain();
        oGain.gain.setValueAtTime(0.2 + pw * 0.35, now);
        oGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05 * envScale);
        osc.connect(oGain); oGain.connect(dest);

        // Snap transient — speed sharpens and brightens
        const snap = ctx.createOscillator();
        snap.type = 'sine';
        const snapFreq = 3000 + sp * 4000; // 3kHz (slow) → 7kHz (supersonic crack)
        snap.frequency.setValueAtTime(snapFreq + v * 1000, now);
        snap.frequency.exponentialRampToValueAtTime(800, now + 0.015 * envScale);
        const sGain = ctx.createGain();
        sGain.gain.setValueAtTime(0.08 + sp * 0.2, now);
        sGain.gain.exponentialRampToValueAtTime(0.001, now + 0.02 * envScale);
        snap.connect(sGain); sGain.connect(dest);

        const dur = (0.1 + pw * 0.05) * envScale;
        noise.start(now); noise.stop(now + dur + 0.02);
        osc.start(now); osc.stop(now + dur);
        snap.start(now); snap.stop(now + 0.03 * envScale);
        done([noise, filter, dist, nGain, osc, oGain, snap, sGain], dur + 0.05);
    }

    // Explosion: layered noise + deep bass + sub rumble
    _explosion(dest, v, done) {
        const ctx = this.ctx, now = ctx.currentTime;

        // Noise body
        const noise = ctx.createBufferSource();
        noise.buffer = this._noise(1.0);
        const filt = ctx.createBiquadFilter();
        filt.type = 'lowpass';
        filt.frequency.setValueAtTime(2500 + v * 1500, now);
        filt.frequency.exponentialRampToValueAtTime(80, now + 0.7);
        filt.Q.value = 3;
        const nGain = ctx.createGain();
        nGain.gain.setValueAtTime(0.0, now);
        nGain.gain.linearRampToValueAtTime(0.5, now + 0.01);
        nGain.gain.exponentialRampToValueAtTime(0.001, now + 0.9);
        noise.connect(filt); filt.connect(nGain); nGain.connect(dest);

        // Deep bass oscillator
        const bass = ctx.createOscillator();
        bass.type = 'sine';
        bass.frequency.setValueAtTime(55 + v * 25, now);
        bass.frequency.exponentialRampToValueAtTime(18, now + 0.5);
        const bGain = ctx.createGain();
        bGain.gain.setValueAtTime(0.6, now);
        bGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
        bass.connect(bGain); bGain.connect(dest);

        // Sub rumble
        const sub = ctx.createOscillator();
        sub.type = 'sine';
        sub.frequency.setValueAtTime(28 + v * 8, now);
        sub.frequency.exponentialRampToValueAtTime(12, now + 0.35);
        const sGain = ctx.createGain();
        sGain.gain.setValueAtTime(0.5, now);
        sGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        sub.connect(sGain); sGain.connect(dest);

        // Mid crackle (distorted noise)
        const crackle = ctx.createBufferSource();
        crackle.buffer = this._noise(0.3);
        const cDist = ctx.createWaveShaper();
        cDist.curve = this._distCurve;
        const cFilt = ctx.createBiquadFilter();
        cFilt.type = 'bandpass';
        cFilt.frequency.setValueAtTime(800 + v * 600, now);
        cFilt.Q.value = 2;
        const cGain = ctx.createGain();
        cGain.gain.setValueAtTime(0.2, now);
        cGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        crackle.connect(cDist); cDist.connect(cFilt); cFilt.connect(cGain); cGain.connect(dest);

        noise.start(now); noise.stop(now + 1.0);
        bass.start(now); bass.stop(now + 0.6);
        sub.start(now); sub.stop(now + 0.4);
        crackle.start(now); crackle.stop(now + 0.3);
        done([noise, filt, nGain, bass, bGain, sub, sGain, crackle, cDist, cFilt, cGain], 1.1);
    }

    // Impact: short thud for projectile landing
    _impact(dest, v, done) {
        const ctx = this.ctx, now = ctx.currentTime;

        const noise = ctx.createBufferSource();
        noise.buffer = this._noise(0.05);
        const nGain = ctx.createGain();
        nGain.gain.setValueAtTime(0.25, now);
        nGain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
        noise.connect(nGain); nGain.connect(dest);

        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(180 + v * 120, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);
        const oGain = ctx.createGain();
        oGain.gain.setValueAtTime(0.35, now);
        oGain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
        osc.connect(oGain); oGain.connect(dest);

        noise.start(now); noise.stop(now + 0.05);
        osc.start(now); osc.stop(now + 0.08);
        done([noise, nGain, osc, oGain], 0.1);
    }

    // Pickup: cheerful ascending tone
    _pickup(dest, v, done) {
        const ctx = this.ctx, now = ctx.currentTime;

        const o1 = ctx.createOscillator();
        o1.type = 'sine';
        o1.frequency.setValueAtTime(600 + v * 100, now);
        o1.frequency.linearRampToValueAtTime(900 + v * 100, now + 0.08);
        const g1 = ctx.createGain();
        g1.gain.setValueAtTime(0.2, now);
        g1.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        o1.connect(g1); g1.connect(dest);

        const o2 = ctx.createOscillator();
        o2.type = 'sine';
        o2.frequency.setValueAtTime(900 + v * 100, now + 0.08);
        o2.frequency.linearRampToValueAtTime(1200 + v * 100, now + 0.16);
        const g2 = ctx.createGain();
        g2.gain.setValueAtTime(0.0, now);
        g2.gain.linearRampToValueAtTime(0.15, now + 0.08);
        g2.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        o2.connect(g2); g2.connect(dest);

        o1.start(now); o1.stop(now + 0.15);
        o2.start(now + 0.07); o2.stop(now + 0.2);
        done([o1, g1, o2, g2], 0.25);
    }

    // Empty clip: dull thunk
    _dryfire(dest, v, done) {
        const ctx = this.ctx, now = ctx.currentTime;
        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(80 + v * 20, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.04);
        const g = ctx.createGain();
        g.gain.setValueAtTime(0.08, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
        osc.connect(g); g.connect(dest);
        osc.start(now); osc.stop(now + 0.06);
        done([osc, g], 0.1);
    }

    // Reload: two-stage chk-chunk
    _reload(dest, v, done) {
        const ctx = this.ctx, now = ctx.currentTime;
        // Stage 1: "chk" — short metallic click (slide back)
        const n1 = ctx.createBufferSource();
        n1.buffer = this._noise(0.04);
        const f1 = ctx.createBiquadFilter();
        f1.type = 'bandpass'; f1.frequency.value = 3000 + v * 1000; f1.Q.value = 2;
        const g1 = ctx.createGain();
        g1.gain.setValueAtTime(0.15, now);
        g1.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
        n1.connect(f1); f1.connect(g1); g1.connect(dest);
        // Metal resonance
        const o1 = ctx.createOscillator();
        o1.type = 'sine';
        o1.frequency.setValueAtTime(400 + v * 100, now);
        o1.frequency.exponentialRampToValueAtTime(200, now + 0.04);
        const og1 = ctx.createGain();
        og1.gain.setValueAtTime(0.08, now);
        og1.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
        o1.connect(og1); og1.connect(dest);
        // Stage 2: "chunk" — heavier snap (slide forward, magazine seats)
        const t2 = now + 0.12;
        const n2 = ctx.createBufferSource();
        n2.buffer = this._noise(0.06);
        const f2 = ctx.createBiquadFilter();
        f2.type = 'bandpass'; f2.frequency.value = 2000 + v * 800; f2.Q.value = 1.5;
        const g2 = ctx.createGain();
        g2.gain.setValueAtTime(0.0, now);
        g2.gain.setValueAtTime(0.18, t2);
        g2.gain.exponentialRampToValueAtTime(0.001, t2 + 0.07);
        n2.connect(f2); f2.connect(g2); g2.connect(dest);
        const o2 = ctx.createOscillator();
        o2.type = 'sine';
        o2.frequency.setValueAtTime(300 + v * 80, t2);
        o2.frequency.exponentialRampToValueAtTime(120, t2 + 0.06);
        const og2 = ctx.createGain();
        og2.gain.setValueAtTime(0.0, now);
        og2.gain.setValueAtTime(0.1, t2);
        og2.gain.exponentialRampToValueAtTime(0.001, t2 + 0.07);
        o2.connect(og2); og2.connect(dest);
        n1.start(now); n1.stop(now + 0.05);
        o1.start(now); o1.stop(now + 0.06);
        n2.start(now); n2.stop(t2 + 0.07);
        o2.start(now); o2.stop(t2 + 0.08);
        done([n1, f1, g1, o1, og1, n2, f2, g2, o2, og2], 0.25);
    }

    // 100-kill milestone: bright single ding
    _ding100(dest, v, done) {
        const ctx = this.ctx, now = ctx.currentTime;
        const o1 = ctx.createOscillator();
        o1.type = 'sine';
        o1.frequency.setValueAtTime(1200, now);
        o1.frequency.exponentialRampToValueAtTime(1100, now + 0.3);
        const g1 = ctx.createGain();
        g1.gain.setValueAtTime(0.18, now);
        g1.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
        o1.connect(g1); g1.connect(dest);
        // Shimmer harmonic
        const o2 = ctx.createOscillator();
        o2.type = 'sine';
        o2.frequency.setValueAtTime(2400, now);
        const g2 = ctx.createGain();
        g2.gain.setValueAtTime(0.06, now);
        g2.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
        o2.connect(g2); g2.connect(dest);
        o1.start(now); o1.stop(now + 0.35);
        o2.start(now); o2.stop(now + 0.25);
        done([o1, g1, o2, g2], 0.4);
    }

    // 1000-kill milestone: double ding, richer
    _ding1000(dest, v, done) {
        const ctx = this.ctx, now = ctx.currentTime;
        // First ding
        const o1 = ctx.createOscillator();
        o1.type = 'sine';
        o1.frequency.setValueAtTime(1100, now);
        const g1 = ctx.createGain();
        g1.gain.setValueAtTime(0.2, now);
        g1.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        o1.connect(g1); g1.connect(dest);
        // Second ding (higher, delayed)
        const o2 = ctx.createOscillator();
        o2.type = 'sine';
        o2.frequency.setValueAtTime(1500, now + 0.15);
        o2.frequency.exponentialRampToValueAtTime(1400, now + 0.5);
        const g2 = ctx.createGain();
        g2.gain.setValueAtTime(0.0, now);
        g2.gain.linearRampToValueAtTime(0.22, now + 0.15);
        g2.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        o2.connect(g2); g2.connect(dest);
        // Shimmer
        const o3 = ctx.createOscillator();
        o3.type = 'sine';
        o3.frequency.setValueAtTime(3000, now + 0.15);
        const g3 = ctx.createGain();
        g3.gain.setValueAtTime(0.0, now);
        g3.gain.linearRampToValueAtTime(0.07, now + 0.15);
        g3.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        o3.connect(g3); g3.connect(dest);
        o1.start(now); o1.stop(now + 0.25);
        o2.start(now); o2.stop(now + 0.5);
        o3.start(now); o3.stop(now + 0.45);
        done([o1, g1, o2, g2, o3, g3], 0.55);
    }

    // === SAMPLE PLAYBACK ===

    async loadSample(name, url) {
        try {
            const resp = await fetch(url);
            const ab = await resp.arrayBuffer();
            this.samples[name] = await this.ctx.decodeAudioData(ab);
            console.info(`[Audio] Loaded sample "${name}" (${(this.samples[name].duration).toFixed(1)}s)`);
        } catch (e) {
            console.warn(`[Audio] Failed to load "${name}":`, e);
        }
    }

    playSample(name, pos = null, opts = {}) {
        const buffer = this.samples[name];
        if (!buffer || this.activeSounds >= CFG.audio.maxSounds) return null;
        if (this.ctx.state === 'suspended') return null;

        const dest = pos ? this._panner(pos) : this.sfxGain;
        const src = this.ctx.createBufferSource();
        src.buffer = buffer;
        if (opts.loop) src.loop = true;
        if (opts.rate) src.playbackRate.value = opts.rate;

        const gain = this.ctx.createGain();
        gain.gain.value = opts.volume || 1;
        src.connect(gain); gain.connect(dest);
        src.start();

        this.activeSounds++;
        src.onended = () => {
            try { src.disconnect(); gain.disconnect(); if (pos) dest.disconnect(); } catch(e) {}
            this.activeSounds--;
        };
        return { source: src, gain };
    }

    playMusic(name, opts = {}) {
        if (this.currentMusic) {
            try { this.currentMusic.source.stop(); } catch(e) {}
        }
        const buffer = this.samples[name];
        if (!buffer) return null;

        const src = this.ctx.createBufferSource();
        src.buffer = buffer;
        src.loop = opts.loop !== false;
        const gain = this.ctx.createGain();
        gain.gain.value = opts.volume || 1;
        src.connect(gain); gain.connect(this.musicGain);
        src.start();

        this.currentMusic = { source: src, gain };
        src.onended = () => { if (this.currentMusic?.source === src) this.currentMusic = null; };
        return this.currentMusic;
    }

    stopMusic(fadeTime = 1) {
        if (!this.currentMusic) return;
        const g = this.currentMusic.gain;
        g.gain.setValueAtTime(g.gain.value, this.ctx.currentTime);
        g.gain.linearRampToValueAtTime(0, this.ctx.currentTime + fadeTime);
        const src = this.currentMusic.source;
        setTimeout(() => { try { src.stop(); } catch(e) {} }, fadeTime * 1000 + 50);
        this.currentMusic = null;
    }

    // Continuous heat whine — call every frame with current heat 0–100
    updateHeatWhine(heat) {
        const threshold = 0.5; // starts at 50% heat
        const norm = heat / CFG.heat.maxHeat;
        if (norm < threshold) {
            // Below threshold: silence
            if (this._heatWhine) {
                this._heatWhine.gain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
            }
            return;
        }
        // Intensity 0→1 mapped from threshold→1.0
        const intensity = (norm - threshold) / (1 - threshold);
        if (!this._heatWhine) {
            // Create persistent oscillator + filter chain
            const ctx = this.ctx;
            const osc = ctx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.value = 800;
            const osc2 = ctx.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = 2400;
            const filter = ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.Q.value = 8;
            filter.frequency.value = 1200;
            const gain = ctx.createGain();
            gain.gain.value = 0;
            osc.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(this.sfxGain);
            osc.start();
            osc2.start();
            this._heatWhine = { osc, osc2, filter, gain };
        }
        const hw = this._heatWhine;
        const now = this.ctx.currentTime;
        // Pitch rises with heat: 800→3000 Hz base, 2400→6000 Hz harmonic
        hw.osc.frequency.setTargetAtTime(800 + intensity * 2200, now, 0.05);
        hw.osc2.frequency.setTargetAtTime(2400 + intensity * 3600, now, 0.05);
        hw.filter.frequency.setTargetAtTime(1200 + intensity * 4000, now, 0.05);
        // Volume: quiet at threshold, screaming near max
        const vol = intensity * intensity * 0.18;
        hw.gain.gain.setTargetAtTime(vol, now, 0.05);
    }

    // Danger siren — warbling two-tone alarm above 90% heat
    updateHeatSiren(heat) {
        const threshold = 0.90;
        const norm = heat / CFG.heat.maxHeat;
        if (norm < threshold) {
            if (this._heatSiren) {
                this._heatSiren.gain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.06);
            }
            return;
        }
        // Intensity 0→1 mapped from 90%→100%
        const intensity = (norm - threshold) / (1 - threshold);
        if (!this._heatSiren) {
            const ctx = this.ctx;
            // Two oscillators for the classic wee-woo: square wave for bite
            const osc1 = ctx.createOscillator();
            osc1.type = 'square';
            osc1.frequency.value = 600;
            const osc2 = ctx.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = 800;
            // LFO to modulate between high/low tones (the "wee-woo" warble)
            const lfo = ctx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 3.5; // warble speed: 3.5 Hz
            const lfoGain = ctx.createGain();
            lfoGain.gain.value = 200; // modulation depth in Hz
            lfo.connect(lfoGain);
            lfoGain.connect(osc1.frequency);
            lfoGain.connect(osc2.frequency);
            // Filter to soften the square wave a bit
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 2000;
            filter.Q.value = 1;
            const gain = ctx.createGain();
            gain.gain.value = 0;
            osc1.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(this.sfxGain);
            osc1.start();
            osc2.start();
            lfo.start();
            this._heatSiren = { osc1, osc2, lfo, lfoGain, filter, gain };
        }
        const hs = this._heatSiren;
        const now = this.ctx.currentTime;
        // Warble speeds up as heat rises: 3.5 → 7 Hz
        hs.lfo.frequency.setTargetAtTime(3.5 + intensity * 3.5, now, 0.05);
        // Pitch rises with intensity: 600/800 → 900/1100
        hs.osc1.frequency.setTargetAtTime(600 + intensity * 300, now, 0.05);
        hs.osc2.frequency.setTargetAtTime(800 + intensity * 300, now, 0.05);
        // Modulation depth increases: ±200 → ±350 Hz
        hs.lfoGain.gain.setTargetAtTime(200 + intensity * 150, now, 0.05);
        // Volume: fades in gently then gets loud — intensity² curve, max 0.15
        const vol = intensity * intensity * 0.15;
        hs.gain.gain.setTargetAtTime(vol, now, 0.04);
    }

    // Continuous rate buzz — gatling "BRRRT" undertone at high fire rates
    // Call every frame with current weapon params and shooting state
    updateRateBuzz(wpnParams, isShooting) {
        const rateNorm = wpnParams ? wpnParams.rate / 255 : 0;
        const threshold = 0.45; // kicks in around 45% rate

        if (!isShooting || rateNorm < threshold) {
            if (this._rateBuzz) {
                this._rateBuzz.gain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.08);
            }
            return;
        }
        const intensity = (rateNorm - threshold) / (1 - threshold);

        if (!this._rateBuzz) {
            const ctx = this.ctx;
            // Dual oscillator buzz: sawtooth + square through lowpass + distortion
            const osc = ctx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.value = 70;
            const osc2 = ctx.createOscillator();
            osc2.type = 'square';
            osc2.frequency.value = 105;
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 500;
            filter.Q.value = 2;
            const dist = ctx.createWaveShaper();
            dist.curve = this._distCurve;
            const gain = ctx.createGain();
            gain.gain.value = 0;
            osc.connect(filter);
            osc2.connect(filter);
            filter.connect(dist);
            dist.connect(gain);
            gain.connect(this.sfxGain);
            osc.start();
            osc2.start();
            this._rateBuzz = { osc, osc2, filter, dist, gain };
        }
        const rb = this._rateBuzz;
        const now = this.ctx.currentTime;
        // Buzz pitch rises with rate
        rb.osc.frequency.setTargetAtTime(60 + intensity * 50, now, 0.05);
        rb.osc2.frequency.setTargetAtTime(90 + intensity * 70, now, 0.05);
        rb.filter.frequency.setTargetAtTime(400 + intensity * 800, now, 0.05);
        // Volume: subtle undertone, gets louder near max rate
        const vol = intensity * intensity * 0.12;
        rb.gain.gain.setTargetAtTime(vol, now, 0.05);
    }

    // Continuous vent sound — hissing/rocket roar while venting heat
    // Call every frame: isVenting = true when R held + heat > 0, heatNorm = heat / maxHeat
    updateVentSound(isVenting, heatNorm) {
        if (!isVenting || heatNorm <= 0) {
            if (this._ventSound) {
                this._ventSound.gain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.06);
            }
            return;
        }

        if (!this._ventSound) {
            const ctx = this.ctx;
            // White noise source (looping buffer) — the hiss
            const noiseBuf = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
            const data = noiseBuf.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
            const noise = ctx.createBufferSource();
            noise.buffer = noiseBuf;
            noise.loop = true;

            // Bandpass filter: shapes the hiss character
            const hissFilter = ctx.createBiquadFilter();
            hissFilter.type = 'bandpass';
            hissFilter.frequency.value = 2000;
            hissFilter.Q.value = 0.8;

            // Low rumble oscillator — the rocket roar
            const roar = ctx.createOscillator();
            roar.type = 'sawtooth';
            roar.frequency.value = 45;
            const roarFilter = ctx.createBiquadFilter();
            roarFilter.type = 'lowpass';
            roarFilter.frequency.value = 200;
            roarFilter.Q.value = 3;

            // Mid crackle — distorted noise for fire texture
            const crackleNoise = ctx.createBufferSource();
            const crackleBuf = ctx.createBuffer(1, ctx.sampleRate, ctx.sampleRate);
            const cd = crackleBuf.getChannelData(0);
            for (let i = 0; i < cd.length; i++) cd[i] = Math.random() * 2 - 1;
            crackleNoise.buffer = crackleBuf;
            crackleNoise.loop = true;
            const crackleFilter = ctx.createBiquadFilter();
            crackleFilter.type = 'bandpass';
            crackleFilter.frequency.value = 600;
            crackleFilter.Q.value = 2;
            const crackleDist = ctx.createWaveShaper();
            crackleDist.curve = this._distCurve;

            // Master gain for the vent sound
            const gain = ctx.createGain();
            gain.gain.value = 0;

            // Wire up
            noise.connect(hissFilter);
            hissFilter.connect(gain);
            roar.connect(roarFilter);
            roarFilter.connect(gain);
            crackleNoise.connect(crackleDist);
            crackleDist.connect(crackleFilter);
            crackleFilter.connect(gain);
            gain.connect(this.sfxGain);

            noise.start();
            roar.start();
            crackleNoise.start();

            this._ventSound = { noise, hissFilter, roar, roarFilter, crackleNoise, crackleFilter, crackleDist, gain };
        }

        const vs = this._ventSound;
        const now = this.ctx.currentTime;
        const h = Math.min(1, heatNorm);

        // More heat = louder, deeper roar, brighter hiss
        vs.hissFilter.frequency.setTargetAtTime(1500 + h * 3000, now, 0.04);
        vs.roar.frequency.setTargetAtTime(35 + h * 30, now, 0.04);
        vs.roarFilter.frequency.setTargetAtTime(150 + h * 200, now, 0.04);
        vs.crackleFilter.frequency.setTargetAtTime(400 + h * 600, now, 0.04);

        // Volume: louder when more heat is being vented
        const vol = 0.08 + h * 0.2;
        vs.gain.gain.setTargetAtTime(vol, now, 0.03);
    }
}

// ============================================================
//  PERFORMANCE PROFILER (frame time breakdown)
// ============================================================
class PerformanceProfiler {
    constructor() {
        this.HISTORY = 200;
        this.CHANNELS = ['enemyCompute', 'particleCompute', 'projCollision', 'renderTime', 'jsTime'];
        this.data = new Float32Array(this.CHANNELS.length * this.HISTORY);
        this.totals = new Float32Array(this.HISTORY); // total frame time
        this.idx = 0;
        this.frameStart = 0;
        this._marks = {};
        this._markStarts = {};
    }
    beginFrame() {
        this.frameStart = performance.now();
        this._marks = {};
        this._markStarts = {};
    }
    mark(name) {
        this._markStarts[name] = performance.now();
    }
    markEnd(name) {
        if (this._markStarts[name] !== undefined) {
            const elapsed = performance.now() - this._markStarts[name];
            this._marks[name] = (this._marks[name] || 0) + elapsed; // accumulate if called multiple times
        }
    }
    endFrame() {
        const totalMs = performance.now() - this.frameStart;
        const i = this.idx % this.HISTORY;

        // Store each channel
        let knownTime = 0;
        for (let c = 0; c < this.CHANNELS.length; c++) {
            const name = this.CHANNELS[c];
            const ms = this._marks[name] || 0;
            this.data[c * this.HISTORY + i] = ms;
            if (name !== 'jsTime') knownTime += ms;
        }
        // JS time = total - all measured GPU/render time
        const jsIdx = this.CHANNELS.indexOf('jsTime');
        this.data[jsIdx * this.HISTORY + i] = Math.max(0, totalMs - knownTime);
        this.totals[i] = totalMs;

        this.idx++;
    }
    getFrame(offset) {
        // offset: 0 = most recent, 1 = previous, etc.
        const i = ((this.idx - 1 - offset) % this.HISTORY + this.HISTORY) % this.HISTORY;
        const frame = {};
        for (let c = 0; c < this.CHANNELS.length; c++) {
            frame[this.CHANNELS[c]] = this.data[c * this.HISTORY + i];
        }
        frame.total = this.totals[i];
        return frame;
    }
    getChannelSlice(channelIdx) {
        // Returns a view of last HISTORY values for this channel, oldest first
        const out = new Float32Array(this.HISTORY);
        for (let j = 0; j < this.HISTORY; j++) {
            const i = ((this.idx - this.HISTORY + j) % this.HISTORY + this.HISTORY) % this.HISTORY;
            out[j] = this.data[channelIdx * this.HISTORY + i];
        }
        return out;
    }
}

// ============================================================
//  PERFORMANCE GRAPH OVERLAY (canvas stacked bar chart)
// ============================================================
class PerformanceGraphOverlay {
    constructor(game) {
        this.game = game;
        this.visible = false;
        this.W = 400;
        this.H = 120;

        // Create canvas
        this.canvas = document.createElement('canvas');
        this.canvas.width = this.W;
        this.canvas.height = this.H;
        this.canvas.style.cssText = 'position:fixed;top:8px;left:50%;transform:translateX(-50%);z-index:999;pointer-events:none;display:none;border-radius:4px;';
        document.body.appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');

        this.colors = ['#5599ff', '#44ddaa', '#ff8844', '#cc66ff', '#666'];
        this.labels = ['Enemy', 'Particle', 'ProjCol', 'Render', 'JS/CPU'];
        this.maxMs = 33.3; // Y-axis scale (30fps)

        // Toggle with backslash
        document.addEventListener('keydown', e => {
            if (e.code === 'Backslash') {
                e.preventDefault();
                this.visible = !this.visible;
                this.canvas.style.display = this.visible ? 'block' : 'none';
            }
        });
    }

    draw() {
        if (!this.visible) return;
        const prof = this.game.profiler;
        if (!prof || prof.idx < 2) return;

        const ctx = this.ctx;
        const W = this.W, H = this.H;
        const channels = prof.CHANNELS.length;
        const barW = W / prof.HISTORY;

        // Clear
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        ctx.fillRect(0, 0, W, H);

        // Draw reference lines
        const y60 = H - (16.67 / this.maxMs) * H;
        const y30 = H - (33.33 / this.maxMs) * H;
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(0, y60); ctx.lineTo(W, y60);
        ctx.moveTo(0, y30); ctx.lineTo(W, y30);
        ctx.stroke();
        ctx.setLineDash([]);

        // Labels for reference lines
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.font = '8px monospace';
        ctx.textAlign = 'right';
        ctx.fillText('60fps', W - 2, y60 - 2);
        ctx.fillText('30fps', W - 2, Math.max(y30 - 2, 8));

        // Draw stacked bars
        for (let j = 0; j < prof.HISTORY; j++) {
            const fi = ((prof.idx - prof.HISTORY + j) % prof.HISTORY + prof.HISTORY) % prof.HISTORY;
            const x = j * barW;
            let yBottom = H;

            for (let c = 0; c < channels; c++) {
                const ms = prof.data[c * prof.HISTORY + fi];
                const barH = (ms / this.maxMs) * H;
                if (barH < 0.3) continue;
                yBottom -= barH;
                ctx.fillStyle = this.colors[c];
                ctx.fillRect(x, yBottom, Math.max(barW - 0.5, 1), barH);
            }
        }

        // Current frame stats (top-right of graph)
        const latest = prof.getFrame(0);
        ctx.fillStyle = '#fff';
        ctx.font = '10px monospace';
        ctx.textAlign = 'right';
        const fps = latest.total > 0 ? Math.round(1000 / latest.total) : 0;
        ctx.fillText(`${fps} fps  ${latest.total.toFixed(1)}ms`, W - 4, 12);

        // Legend (bottom)
        ctx.font = '8px monospace';
        ctx.textAlign = 'left';
        let lx = 4;
        for (let c = 0; c < channels; c++) {
            ctx.fillStyle = this.colors[c];
            ctx.fillRect(lx, H - 10, 6, 6);
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.fillText(this.labels[c], lx + 8, H - 4);
            lx += ctx.measureText(this.labels[c]).width + 16;
        }
    }
}

// ============================================================
//  DEBUG OVERLAY
// ============================================================
class DebugOverlay {
    constructor(game) {
        this.game = game; this.visible = false;
        this.el = document.getElementById('debug');
        this.build();
        document.addEventListener('keydown', e => {
            if (e.code === 'Backquote') {
                e.preventDefault();
                this.visible = !this.visible;
                this.el.style.display = this.visible ? 'block' : 'none';
                const st = this.game.state;
                if (this.visible) {
                    if (document.pointerLockElement) document.exitPointerLock();
                } else {
                    // Only re-request pointer lock during states that use it
                    if (st === 'playing' || st === 'pregame' || st === 'drop') {
                        this.game.renderer.domElement.requestPointerLock();
                    }
                }
            }
        });
    }
    build() {
        this.el.innerHTML = '';
        const header = document.createElement('div'); header.className = 'debug-header';
        header.innerHTML = `<span>DEBUG (WebGPU) - ${fmtEnemyCount(ENEMY_COUNT)} enemies</span><span style="color:#666;font-size:11px">~</span>`;
        this.el.appendChild(header);

        this.statsEl = document.createElement('div'); this.statsEl.className = 'debug-stats'; this.el.appendChild(this.statsEl);

        const regenTerrain = () => this.game.regenerateTerrain();
        this.addSection('World', [
            { key: 'world.size', label: 'World Size', min: 1000, max: 50000, step: 1000 },
        ], regenTerrain);
        this.addSection('Terrain', [
            { key: 'terrain.seed', label: 'Seed', min: 1, max: 9999, step: 1, stepper: true },
            { key: 'terrain.octaves', label: 'Octaves', min: 1, max: 8, step: 1 },
            { key: 'terrain.frequency', label: 'Frequency', min: 0.0005, max: 0.01, step: 0.0001 },
            { key: 'terrain.amplitude', label: 'Amplitude', min: 10, max: 800, step: 10 },
            { key: 'terrain.persistence', label: 'Persistence', min: 0.1, max: 0.9, step: 0.01 },
            { key: 'terrain.offset', label: 'Offset', min: -50, max: 100, step: 1 },
        ], regenTerrain);
        this.addSection('Player', [
            { key: 'player.walkSpeed', label: 'Walk Speed', min: 1, max: 30, step: 0.5 },
            { key: 'player.sprintMult', label: 'Sprint Mult', min: 1, max: 4, step: 0.1 },
            { key: 'player.jumpForce', label: 'Jump Force', min: 1, max: 30, step: 0.5 },
            { key: 'player.gravity', label: 'Gravity', min: 5, max: 60, step: 0.5 },
            { key: 'player.slopeEffect', label: 'Slope Effect', min: 0, max: 2, step: 0.1 },
        ]);
        this.addSection('Enemies (GPU)', [
            { key: 'enemies.speed', label: 'Speed', min: 0.5, max: 20, step: 0.5 },
            { key: 'enemies.health', label: 'Health', min: 10, max: 500, step: 10 },
            { key: 'enemies.damage', label: 'Damage/sec', min: 1, max: 50, step: 1 },
            { key: 'enemies.attackRange', label: 'Atk Range', min: 1, max: 15, step: 0.5 },
            { key: 'enemies.size', label: 'Size', min: 0.3, max: 4, step: 0.1 },
            { key: 'enemies.cullDistance', label: 'Cull Dist', min: 50, max: 5000, step: 50 },
            { key: 'enemies.flowInfluence', label: 'Flow Influence', min: 0, max: 1, step: 0.05 },
        ]);
        const syncGun = () => { if (this.game.player) this.game.player.syncWeaponPositions(); };
        this.addSection('Weapon', [
            { key: 'weapon.damage', label: 'Damage', min: 1, max: 200, step: 1 },
            { key: 'weapon.fireRate', label: 'Fire Rate', min: 1, max: 20, step: 0.5 },
            { key: 'weapon.range', label: 'Range', min: 50, max: 1000, step: 10 },
            { key: 'weapon.maxAmmo', label: 'Max Ammo', min: 5, max: 200, step: 5 },
            { key: 'weapon.hitRadius', label: 'Hit Radius', min: 0.5, max: 5, step: 0.1 },
            { key: 'weapon.convergeDist', label: 'Converge Dist', min: 10, max: 200, step: 5 },
            { key: 'weapon.barrelX', label: 'Barrel X', min: 0.05, max: 0.5, step: 0.01 },
            { key: 'weapon.barrelY', label: 'Barrel Y', min: -0.4, max: 0.1, step: 0.01 },
            { key: 'weapon.barrelZ', label: 'Barrel Z', min: -1.0, max: -0.2, step: 0.01 },
        ], syncGun);
        this.addSection('Particles', [
            { key: 'particles.muzzleCount', label: 'Muzzle #', min: 0, max: 50, step: 1 },
            { key: 'particles.trailCount', label: 'Trail #', min: 0, max: 200, step: 1 },
            { key: 'particles.bloodCount', label: 'Blood #', min: 0, max: 100, step: 1 },
            { key: 'particles.sparkCount', label: 'Spark #', min: 0, max: 50, step: 1 },
        ]);
        this.addSection('Projectile', [
            { key: 'projectile.speed', label: 'Speed', min: 20, max: 300, step: 5 },
            { key: 'projectile.gravity', label: 'Gravity', min: 0, max: 80, step: 1 },
            { key: 'projectile.explosionRadius', label: 'Blast Radius', min: 5, max: 100, step: 1 },
            { key: 'projectile.explosionForce', label: 'Blast Force', min: 5, max: 150, step: 1 },
            { key: 'projectile.explosionDamage', label: 'Blast Damage', min: 0, max: 200, step: 5 },
        ]);
        this.addSection('Lighting', [
            { key: 'lighting.sunIntensity', label: 'Sun', min: 0, max: 5, step: 0.1 },
            { key: 'lighting.ambientIntensity', label: 'Ambient', min: 0, max: 2, step: 0.05 },
            { key: 'lighting.fogNear', label: 'Fog Near', min: 50, max: 5000, step: 50 },
            { key: 'lighting.fogFar', label: 'Fog Far', min: 100, max: 10000, step: 50 },
        ]);
        this.addSection('Flow Map', [
            { key: 'flowMap.updateInterval', label: 'Update (s)', min: 0.05, max: 2, step: 0.05 },
        ]);
        this.addSection('Audio', [
            { key: 'audio.masterVolume', label: 'Master', min: 0, max: 1, step: 0.05 },
            { key: 'audio.sfxVolume', label: 'SFX', min: 0, max: 1, step: 0.05 },
            { key: 'audio.musicVolume', label: 'Music', min: 0, max: 1, step: 0.05 },
            { key: 'audio.spatialRefDist', label: 'Ref Distance', min: 1, max: 50, step: 1 },
            { key: 'audio.spatialMaxDist', label: 'Max Distance', min: 50, max: 2000, step: 50 },
            { key: 'audio.spatialRolloff', label: 'Rolloff', min: 0.1, max: 5, step: 0.1 },
        ]);
        this.addSection('Debug', [
            { key: 'debug.godMode', label: 'God Mode', type: 'checkbox' },
            { key: 'debug.damageFlash', label: 'Damage Flash', type: 'checkbox' },
        ]);

        // Buttons
        const btns = document.createElement('div'); btns.style.padding = '12px 16px';
        const mkBtn = (text, fn) => { const b = document.createElement('button'); b.className = 'debug-btn'; b.textContent = text; b.onclick = fn; btns.appendChild(b); };
        mkBtn('Regen Terrain', () => this.game.regenerateTerrain());
        mkBtn('Respawn Enemies', () => this.game.respawnEnemies());
        mkBtn('Clear Pickups', () => this.game.pickupManager.spawnAll());
        mkBtn('Full Heal + Ammo', () => { this.game.player.health = CFG.player.maxHealth; this.game.player.ammo = CFG.weapon.maxAmmo; this.game.player.heat = 0; });
        mkBtn('Teleport Center', () => { const g = this.game; g.player.position.set(0, g.terrain.getHeight(0,0)+CFG.player.height, 0); });
        this.el.appendChild(btns);

        // Config sharing row
        const shareRow = document.createElement('div'); shareRow.style.padding = '8px 16px';
        const shareBtn = document.createElement('button'); shareBtn.className = 'debug-btn';
        shareBtn.textContent = '📋 COPY CONFIG URL';
        shareBtn.style.cssText = 'width:100%;padding:8px;font-size:12px;background:rgba(136,170,255,0.15);border:1px solid rgba(136,170,255,0.3)';
        shareBtn.onclick = () => {
            const url = getShareURL();
            navigator.clipboard.writeText(url).then(() => {
                shareBtn.textContent = '✓ COPIED!';
                setTimeout(() => { shareBtn.textContent = '📋 COPY CONFIG URL'; }, 2000);
            });
        };
        shareRow.appendChild(shareBtn);
        // Paste config input
        const pasteRow = document.createElement('div'); pasteRow.style.cssText = 'display:flex;gap:4px;margin-top:6px';
        const pasteInput = document.createElement('input'); pasteInput.type = 'text';
        pasteInput.placeholder = 'Paste config URL or base64...';
        pasteInput.style.cssText = 'flex:1;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.15);color:#fff;font-size:11px;padding:4px 8px;border-radius:3px;font-family:monospace';
        const applyBtn = document.createElement('button'); applyBtn.className = 'debug-btn';
        applyBtn.textContent = 'APPLY';
        applyBtn.style.cssText = 'padding:4px 10px;font-size:11px';
        applyBtn.onclick = () => {
            let val = pasteInput.value.trim();
            // Extract cfg param from URL if pasted as full URL
            try { const u = new URL(val); val = u.searchParams.get('cfg') || val; } catch(e) {}
            if (applyCFG(val)) {
                applyBtn.textContent = '✓ APPLIED';
                this.build();  // Rebuild debug panel with new values
                if (this.game.player) this.game.player.syncWeaponPositions();
                if (this.game.player) this.game.player.applyHandedness();
                if (this.game.audio) this.game.audio.syncVolumes();
                setTimeout(() => { applyBtn.textContent = 'APPLY'; }, 2000);
            } else {
                applyBtn.textContent = '✗ INVALID';
                setTimeout(() => { applyBtn.textContent = 'APPLY'; }, 2000);
            }
        };
        pasteRow.appendChild(pasteInput); pasteRow.appendChild(applyBtn);
        shareRow.appendChild(pasteRow);
        this.el.appendChild(shareRow);
    }
    addSection(title, params, onCommit) {
        const section = document.createElement('div'); section.className = 'debug-section';
        const titleEl = document.createElement('div'); titleEl.className = 'debug-section-title';
        titleEl.innerHTML = `<span>${title}</span><span>-</span>`;
        const content = document.createElement('div'); content.className = 'debug-section-content';
        let collapsed = false;
        titleEl.onclick = () => { collapsed = !collapsed; content.style.display = collapsed ? 'none' : 'block'; titleEl.querySelector('span:last-child').textContent = collapsed ? '+' : '-'; };
        for (const p of params) {
            const row = document.createElement('div'); row.className = 'debug-row';
            const label = document.createElement('label'); label.textContent = p.label; row.appendChild(label);
            const [cat, key] = p.key.split('.');
            if (p.type === 'checkbox') {
                const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = CFG[cat][key];
                cb.style.cssText = 'width:14px;height:14px;accent-color:#8af';
                cb.addEventListener('change', () => { CFG[cat][key] = cb.checked; if (onCommit) onCommit(cat, key); });
                row.appendChild(cb);
            } else {
                const slider = document.createElement('input'); slider.type = 'range'; slider.min = p.min; slider.max = p.max; slider.step = p.step; slider.value = CFG[cat][key];
                const decimals = p.step < 1 ? (p.step < 0.01 ? 4 : 2) : 0;
                const val = document.createElement('span'); val.className = 'val'; val.textContent = Number(CFG[cat][key]).toFixed(decimals);
                const updateVal = (v) => { CFG[cat][key] = v; slider.value = v; val.textContent = v.toFixed(decimals); };
                slider.addEventListener('input', () => updateVal(parseFloat(slider.value)));
                if (onCommit) slider.addEventListener('change', () => onCommit(cat, key));
                if (p.stepper) {
                    const mkStep = (label, delta) => { const b = document.createElement('button'); b.className = 'debug-btn'; b.style.cssText = 'padding:2px 7px;margin:0 1px;min-width:20px;font-size:13px;line-height:1;'; b.textContent = label; b.addEventListener('click', () => { const v = Math.min(parseFloat(slider.max), Math.max(parseFloat(slider.min), CFG[cat][key] + delta)); updateVal(v); if (onCommit) onCommit(cat, key); }); return b; };
                    row.appendChild(mkStep('-', -p.step));
                    row.appendChild(slider);
                    row.appendChild(mkStep('+', p.step));
                } else {
                    row.appendChild(slider);
                }
                row.appendChild(val);
            }
            content.appendChild(row);
        }
        section.appendChild(titleEl); section.appendChild(content); this.el.appendChild(section);
    }
    updateStats(fps, player) {
        this.statsEl.innerHTML =
            `FPS: ${fps} | Enemies: ${fmtEnemyCount(ENEMY_COUNT)} (GPU)<br>` +
            `Pos: ${player.position.x.toFixed(0)}, ${player.position.y.toFixed(0)}, ${player.position.z.toFixed(0)} | ` +
            `HP: ${player.health.toFixed(0)} | Ammo: ${player.ammo}`;
    }
}

// ============================================================
//  GAME STATES
// ============================================================
// Helper: populate gameover overlay stats (deferred until death cam finishes)
function populateGameoverStats(game) {
    const overlay = document.getElementById('gameover-overlay');
    const kills = game.roundStats.kills;
    const remain = Math.max(0, ENEMY_COUNT - kills);
    const mins = Math.floor(game.roundStats.survivalTime / 60);
    const secs = Math.floor(game.roundStats.survivalTime % 60);
    const timeStr = `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
    const accuracy = game.roundStats.shotsFired > 0
        ? Math.min(100, Math.round(kills / game.roundStats.shotsFired * 100)) + '%'
        : '\u2014';
    const maxStreak = game._kcJuice ? game._kcJuice.maxStreak : 0;
    game.roundStats.maxStreak = maxStreak;
    overlay.querySelector('.go-remain').innerHTML =
        `${remain.toLocaleString()}<span>REMAIN</span>`;
    const pct = (remain / ENEMY_COUNT) * 100;
    overlay.querySelector('.go-bar-fill').style.width = pct + '%';
    overlay.querySelector('.go-stat-line').innerHTML =
        `\u23F1 <span>${timeStr}</span> &nbsp;\u2502&nbsp; \uD83C\uDFAF <span>${accuracy}</span> &nbsp;\u2502&nbsp; \uD83D\uDC80 <span>${kills.toLocaleString()}</span> &nbsp;\u2502&nbsp; \uD83D\uDD25 <span>${maxStreak.toLocaleString()}</span> streak`;
    const deathMessages = {
        overheat: 'Your gun overheated and exploded.',
        enemies: 'Overwhelmed by the horde.',
    };
    const deathHints = {
        overheat: 'Press R to vent your excess heat.',
    };
    const causeEl = overlay.querySelector('.go-death-cause');
    const msg = deathMessages[game.deathCause] || deathMessages.enemies;
    const hint = deathHints[game.deathCause] || '';
    causeEl.innerHTML = msg + (hint ? '<br><span style="color:#8af;font-size:12px;opacity:0.8">' + hint + '</span>' : '');
    const wp = game.player.wpnParams;
    const hex = (v) => v.toString(16).padStart(2, '0').toUpperCase();
    const loadoutHex = `#${hex(wp.spread)}${hex(wp.rate)}${hex(wp.power)}${hex(wp.speed)}`;
    game.roundStats.loadoutHex = loadoutHex;
    overlay.querySelector('.go-loadout').innerHTML = `Loadout: <span>${loadoutHex}</span>`;
    const prevScores = game.getHighScores();
    const isNewHighScore = prevScores.length === 0 || game.roundStats.survivalTime > prevScores[0].time;
    game.saveHighScore(game.roundStats);
    overlay.querySelector('.go-highscore').style.display = isNewHighScore ? 'block' : 'none';
    analytics.event('game_over', {
        survival_time: Math.round(game.roundStats.survivalTime),
        kills: game.roundStats.kills,
        shots_fired: game.roundStats.shotsFired
    });
}

const STATES = {
    attract: {
        enter(game) {
            game.setActiveCamera(game.attractCamera);
            document.getElementById('menu-overlay').style.display = 'flex';
            document.getElementById('pregame-overlay').style.display = 'none';
            document.getElementById('gameover-overlay').style.display = 'none';
            document.getElementById('blocker').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            game.player.weaponGroup.visible = false;
            game.player.locked = false;
            game.player.shooting = false;
            if (document.pointerLockElement) document.exitPointerLock();
            game.attractTime = game.attractTime || 0;
            // Close any open menu panels
            document.querySelectorAll('.menu-panel').forEach(p => p.style.display = 'none');
        },
        update(dt, game) {
            game.attractAngle += dt * 0.05;
            game.attractTime += dt;
            const radius = 600;
            const x = Math.cos(game.attractAngle) * radius;
            const z = Math.sin(game.attractAngle) * radius;
            const baseY = game.terrain.getHeight(x, z);
            const y = Math.max(baseY + 60, 220) + Math.sin(game.attractTime * 0.15) * 30;
            game.attractCamera.position.set(x, y, z);
            const lookX = Math.sin(game.attractTime * 0.3) * 200;
            const lookZ = Math.cos(game.attractTime * 0.2) * 200;
            game.attractCamera.lookAt(lookX, 50, lookZ);
            // Keep enemies + particles alive in attract
            game.profiler.mark('enemyCompute');
            game.enemies.syncUniforms(dt, game.player.position, game.attractCamera.position);
            game.renderer.compute(game.enemies.computeUpdate);
            game.renderer.compute(game.enemies.computePhysics);
            game.profiler.markEnd('enemyCompute');
            game.profiler.mark('particleCompute');
            game.particles.dtU.value = dt;
            game.renderer.compute(game.particles.computeUpdate);
            game.profiler.markEnd('particleCompute');
            // Live-sync lighting from debug sliders
            game.sunLight.intensity = CFG.lighting.sunIntensity;
            game.sunLight.position.set(CFG.lighting.sunX, CFG.lighting.sunY, CFG.lighting.sunZ).normalize().multiplyScalar(400);
            game.ambientLight.intensity = CFG.lighting.ambientIntensity;
            game.scene.fog.near = CFG.lighting.fogNear;
            game.scene.fog.far = CFG.lighting.fogFar;
        },
        exit(game) {
            document.getElementById('menu-overlay').style.display = 'none';
        }
    },

    pregame: {
        enter(game) {
            game.setActiveCamera(game.camera);
            game.player.weaponGroup.visible = true;
            game.player.pitch = -Math.PI / 2;
            game.player.yaw = 0;
            game.player.velocity.set(0, 0, 0);
            game.player.grounded = false;
            game.player.health = CFG.player.maxHealth;
            game.player.ammo = CFG.weapon.maxAmmo;
            game.player.heat = 0;
            game.player.fireTimer = 0;
            game.player.shooting = false;
            game.player.muzzleFlash.material.opacity = 0;
            game.player.muzzleFlash.scale.setScalar(1);
            game.player.barrelGlow = 0;
            if (game.player.gunBarrel) game.player.gunBarrel.material.emissive.setRGB(0, 0, 0);
            game.deathCause = 'enemies';
            game.roundStats = { survivalTime: 0, kills: 0, shotsFired: 0 };
            game._kcJuice = null;  // Reset kill streak juice
            game.regenerateTerrain();
            game.enemies.clearKillCount(game.renderer);
            // Set spawn height AFTER regen (which resets player.position.y)
            const spawnH = game.terrain.getHeight(0, 0) + 400;
            game.player.position.set(0, spawnH, 0);
            document.getElementById('pregame-overlay').style.display = 'flex';
            document.getElementById('gameover-overlay').style.display = 'none';
            document.getElementById('blocker').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            game.camera.position.copy(game.player.position);
            game.camera.rotation.order = 'YXZ';
            game.camera.rotation.set(game.player.pitch, game.player.yaw, 0);
            game.renderer.domElement.requestPointerLock();
        },
        update(dt, game) {
            // Mouse look only
            if (game.player.locked) {
                const sens = 0.002;
                game.player.yaw -= game.player.mouseDX * sens;
                game.player.pitch -= game.player.mouseDY * sens;
                game.player.pitch = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, game.player.pitch));
            }
            game.player.mouseDX = 0;
            game.player.mouseDY = 0;
            game.camera.position.copy(game.player.position);
            game.camera.rotation.set(game.player.pitch, game.player.yaw, 0);
            // Particles keep updating
            game.particles.dtU.value = dt;
            game.renderer.compute(game.particles.computeUpdate);
            // Fire → drop
            if (game.player.shooting) {
                game.setState('drop');
            }
        },
        exit(game) {
            document.getElementById('pregame-overlay').style.display = 'none';
        }
    },

    drop: {
        enter(game) {
            game.dropStartY = game.player.position.y;
            game.player.shooting = false;
            document.getElementById('hud').style.display = 'block';
            // Warm up projectile collision GPU pipelines so the first
            // frame of playing state doesn't stall on shader compilation
            game.renderer.compute(game.enemies.computeProjClear);
            game.renderer.compute(game.enemies.computeProjCollision);
        },
        update(dt, game) {
            const dropSpeed = 150;
            game.player.position.y -= dropSpeed * dt;

            // Air control: WASD moves laterally during drop
            const airSpeed = 60;
            const forward = new THREE.Vector3(-Math.sin(game.player.yaw), 0, -Math.cos(game.player.yaw));
            const right = new THREE.Vector3(Math.cos(game.player.yaw), 0, -Math.sin(game.player.yaw));
            const move = new THREE.Vector3();
            if (game.player.keys['KeyW']) move.add(forward);
            if (game.player.keys['KeyS']) move.sub(forward);
            if (game.player.keys['KeyA']) move.sub(right);
            if (game.player.keys['KeyD']) move.add(right);
            if (move.lengthSq() > 0) move.normalize();
            game.player.position.x += move.x * airSpeed * dt;
            game.player.position.z += move.z * airSpeed * dt;
            // Clamp to world bounds
            const half = CFG.world.size * 0.48;
            game.player.position.x = Math.max(-half, Math.min(half, game.player.position.x));
            game.player.position.z = Math.max(-half, Math.min(half, game.player.position.z));

            // Mouse look during drop
            const sens = 0.002;
            game.player.yaw -= game.player.mouseDX * sens;
            game.player.mouseDX = 0; game.player.mouseDY = 0;

            // Trail particles
            game.particles.emit(game.player.position, new THREE.Vector3(0, 1, 0), 30, 'trail');
            game.renderer.compute(game.particles.computeSpawn);
            // Lerp pitch toward horizon
            const terrainH = game.terrain.getHeight(game.player.position.x, game.player.position.z);
            const groundY = terrainH + CFG.player.height;
            const totalDrop = game.dropStartY - groundY;
            const progress = totalDrop > 0 ? 1 - Math.max(0, (game.player.position.y - groundY) / totalDrop) : 1;
            game.player.pitch = -Math.PI / 2 * (1 - Math.pow(progress, 0.6));
            // Sync camera
            game.camera.position.copy(game.player.position);
            game.camera.rotation.set(game.player.pitch, game.player.yaw, 0);
            // Update enemies (they're moving below)
            game.profiler.mark('enemyCompute');
            game.enemies.syncUniforms(dt, game.player.position, game.camera.position);
            game.enemies.updateDensity(dt, game.renderer);
            game.renderer.compute(game.enemies.computeUpdate);
            game.renderer.compute(game.enemies.computePhysics);
            game.profiler.markEnd('enemyCompute');
            // Update particles + explosion spheres
            game.profiler.mark('particleCompute');
            game.particles.dtU.value = dt;
            game.renderer.compute(game.particles.computeUpdate);
            game.profiler.markEnd('particleCompute');
            game.explosionSpheres.update(dt);
            // Landing check
            if (game.player.position.y <= groundY) {
                game.player.position.y = groundY;
                game.player.grounded = true;
                game.player.velocity.set(0, 0, 0);
                game.player.pitch = 0;
                game.camera.position.copy(game.player.position);
                game.camera.rotation.set(0, game.player.yaw, 0);
                // Landing shockwave: send enemies flying, no explosion particles
                const landPos = game.player.position.clone();
                game.enemies.explosionPosU.value.copy(landPos);
                game.enemies.explosionRadiusU.value = 60;
                game.enemies.explosionForceU.value = 80;
                game.enemies.explosionDamageU.value = 30;
                game.renderer.compute(game.enemies.computeExplosion);
                // Screen shake
                game.shakeTimer = 0.4;
                game.audio.play('explosion');
                game.setState('playing');
                analytics.event('game_start');
            }
        },
        exit(game) {}
    },

    playing: {
        enter(game) {
            game.player.locked = true;
            game.player.shooting = false;
            document.getElementById('hud').style.display = 'block';
            document.getElementById('blocker').style.display = 'none';
            document.getElementById('gameover-overlay').style.display = 'none';
            game.pickupManager.spawnAll();
        },
        update(dt, game) {
            // Paused (pointer lock lost via Esc or debug panel)
            if (!game.player.locked) return;
            game.player.update(dt);
            // Screen shake
            if (game.shakeTimer > 0) {
                game.shakeTimer -= dt;
                const intensity = game.shakeTimer * 8;
                game.camera.rotation.x += (Math.random() - 0.5) * 0.02 * intensity;
                game.camera.rotation.y += (Math.random() - 0.5) * 0.02 * intensity;
            }
            // GPU enemies
            game.profiler.mark('enemyCompute');
            game.enemies.syncUniforms(dt, game.player.position, game.camera.position);
            game.enemies.updateDensity(dt, game.renderer);
            game.renderer.compute(game.enemies.computeUpdate);
            game.renderer.compute(game.enemies.computePhysics);
            game.enemies.runNearbyCount(game.renderer);
            game.profiler.markEnd('enemyCompute');
            // Shooting
            const shots = game.player.tryShoot();
            if (shots === 'overheat') {
                // Gun explodes — kill the player
                game.deathCause = 'overheat';
                game.player.health = 0;
                const pos = game.player.position.clone();
                const upDir = new THREE.Vector3(0, 1, 0);
                game.particles.emit(pos, upDir, 80, 'explosion');
                game.renderer.compute(game.particles.computeSpawn);
                game.particles.emit(pos, upDir, 50, 'spark');
                game.renderer.compute(game.particles.computeSpawn);
                game.audio.play('explosion');
                game.shakeTimer = 0.6;
            } else if (shots && shots.length) {
                game.roundStats.shotsFired++;
                // Muzzle + exhaust particles once per shot (not per pellet)
                const firstShot = shots[0];
                const pw = game.player.wpnParams.power / 255;
                const sd = game.player.wpnParams.spread / 255;
                const muzzleOvr = {
                    color: [1.0, 0.9 - pw * 0.6, 0.3 - pw * 0.2],
                    size: 0.06 + sd * 0.06,
                };
                game.particles.emit(firstShot.origin, firstShot.direction, CFG.particles.muzzleCount, 'muzzle', muzzleOvr);
                game.renderer.compute(game.particles.computeSpawn);
                const exhaustOvr = {
                    color: [1.0, 0.8 - pw * 0.5, 0.3 - pw * 0.2],
                    size: 0.08 + pw * 0.08,
                };
                game.particles.emit(firstShot.origin, firstShot.direction, 40, 'exhaust', exhaustOvr);
                game.renderer.compute(game.particles.computeSpawn);
                // Fire each pellet
                for (const shot of shots) {
                    game.projectiles.fire(shot.origin, shot.direction, shot.speed, shot.damage, game.player.wpnParams, shot.life, shot.explosionRadius, shot.explosionForce);
                }
                game.audio.play('gunshot', null, game.player.wpnParams);
            }
            // Venting: R key = vent heat as upward thrust
            if (game.player.keys['KeyR'] && game.player.heat > 0) {
                const ventAmount = CFG.heat.ventRate * dt;
                const actualVent = Math.min(game.player.heat, ventAmount);
                game.player.heat -= actualVent;
                // Thrust proportional to heat vented
                const thrust = actualVent * CFG.heat.thrustMult;
                // Liftoff kick: if grounded, give a minimum upward velocity so we
                // break free of the ground-snap zone (otherwise tiny per-frame thrust
                // gets eaten by terrain collision each frame on uneven ground)
                if (game.player.grounded) {
                    game.player.velocity.y = Math.max(game.player.velocity.y, 3);
                    game.player.position.y += 0.05; // nudge above ground
                }
                game.player.velocity.y += thrust;
                game.player.grounded = false;
                // Block shooting while venting
                game.player.shooting = false;
            }
            // Vent sound: hissing rocket roar while venting
            const isVenting = game.player.keys['KeyR'] && game.player.heat > 0;
            game.audio.updateVentSound(isVenting, game.player.heat / CFG.heat.maxHeat);
            // Heat whine audio
            game.audio.updateHeatWhine(game.player.heat);
            // Danger siren: wee-woo alarm above 90% heat
            game.audio.updateHeatSiren(game.player.heat);
            // Rate buzz: gatling undertone at high fire rates
            game.audio.updateRateBuzz(game.player.wpnParams, game.player.shooting);
            // --- Helper: trigger explosion at a point ---
            const triggerExplosion = (impactPos, damage, radius, force) => {
                game.pickupManager.recordHitPosition(impactPos);
                const upDir = new THREE.Vector3(0, 1, 0);
                // Use per-projectile radius/force if provided, else scale from damage
                const damageNorm = Math.min(1, damage / 100);
                const radiusScale = radius != null ? radius : CFG.projectile.explosionRadius * (0.4 + damageNorm * 0.8);
                const forceScale = force != null ? force : CFG.projectile.explosionForce * (0.3 + damageNorm * 0.7);
                const radiusNorm = Math.min(1, radiusScale / CFG.projectile.explosionRadius);
                const expCount = Math.max(8, Math.round(CFG.particles.explosionCount * (0.3 + radiusNorm * 0.7)));
                const sparkCount = Math.max(4, Math.round(CFG.particles.explosionSparkCount * (0.3 + radiusNorm * 0.7)));
                // Explosion color shifts: orange (low) → bright red-white (high)
                const expOvr = { color: [1.0, 0.5 - damageNorm * 0.2, 0.1 + damageNorm * 0.2] };
                game.particles.emit(impactPos, upDir, expCount, 'explosion', expOvr);
                game.renderer.compute(game.particles.computeSpawn);
                game.particles.emit(impactPos, upDir, sparkCount, 'spark');
                game.renderer.compute(game.particles.computeSpawn);
                game.enemies.explosionPosU.value.copy(impactPos);
                game.enemies.explosionRadiusU.value = radiusScale;
                game.enemies.explosionForceU.value = forceScale;
                game.enemies.explosionDamageU.value = damage;
                game.renderer.compute(game.enemies.computeExplosion);
                game.explosionSpheres.spawn(impactPos, radiusScale, damageNorm);
                game.audio.play('explosion', impactPos);
                // Self-knockback (no damage) — scales with explosion size
                const toPlayer = game.player.position.clone().sub(impactPos);
                const playerDist = toPlayer.length();
                if (playerDist < radiusScale * 1.5) {
                    const falloff = 1 - Math.min(1, playerDist / (radiusScale * 1.5));
                    const knockForce = forceScale * 0.6 * falloff;
                    if (playerDist > 0.5) toPlayer.normalize();
                    game.player.velocity.x += toPlayer.x * knockForce;
                    game.player.velocity.z += toPlayer.z * knockForce;
                    game.player.velocity.y += knockForce * 0.5;
                    game.player.grounded = false;
                }
            };
            // Mid-air hits from GPU collision (previous frame)
            const gpuHits = game.enemies.consumeHits();
            for (const idx of gpuHits) {
                const p = game.projectiles.pool[idx];
                if (p.active) {
                    const hitPos = p.pos.clone();
                    const dmg = p.damage || CFG.projectile.explosionDamage;
                    p.active = false;
                    p.mesh.visible = false;
                    triggerExplosion(hitPos, dmg, p.explosionRadius, p.explosionForce);
                }
            }
            // Terrain impacts (ground collision)
            const impacts = game.projectiles.update(dt, game.particles, game.renderer);
            for (const impact of impacts) {
                triggerExplosion(impact.pos, impact.damage, impact.explosionRadius, impact.explosionForce);
            }
            // Upload projectile positions + run GPU collision (readback happens after render in animate)
            game.profiler.mark('projCollision');
            game.enemies.uploadProjectilePositions(game.projectiles.pool);
            game.enemies.runProjectileCollision(game.renderer);
            game.profiler.markEnd('projCollision');
            // Particles
            game.profiler.mark('particleCompute');
            game.particles.dtU.value = dt;
            game.renderer.compute(game.particles.computeUpdate);
            game.profiler.markEnd('particleCompute');
            // Explosion spheres
            game.explosionSpheres.update(dt);
            // Pickups
            const prevHP = game.player.health, prevAmmo = game.player.ammo;
            game.pickupManager.update(dt, game.player);
            if (game.player.health > prevHP || game.player.ammo > prevAmmo) {
                game.audio.play('pickup');
            }
            // Audio sync
            game.audio.syncVolumes();
            // Enemy proximity damage
            if (!CFG.debug.godMode) {
                const nearbyCount = game.enemies.getNearbyCount();
                if (nearbyCount > 0) {
                    game.deathCause = 'enemies';
                    game.player.takeDamage(CFG.enemies.damage * Math.min(nearbyCount, 50) * dt);
                }
            }
            // Track kills from GPU
            game.roundStats.kills = game.enemies.getKillCount();
            // Lighting
            game.sunLight.intensity = CFG.lighting.sunIntensity;
            game.sunLight.position.set(CFG.lighting.sunX, CFG.lighting.sunY, CFG.lighting.sunZ).normalize().multiplyScalar(400);
            game.ambientLight.intensity = CFG.lighting.ambientIntensity;
            game.scene.fog.near = CFG.lighting.fogNear;
            game.scene.fog.far = CFG.lighting.fogFar;
            game.sunLight.target.position.copy(game.player.position);
            game.sunLight.target.updateMatrixWorld();
            game.sunLight.position.copy(game.player.position).add(
                new THREE.Vector3(CFG.lighting.sunX, CFG.lighting.sunY, CFG.lighting.sunZ).normalize().multiplyScalar(200)
            );
            // Damage overlay
            if (CFG.debug.damageFlash) {
                const dmg = Math.max(0, 1 - game.player.health / CFG.player.maxHealth) * 0.6;
                document.getElementById('damage-overlay').style.boxShadow = `inset 0 0 ${60 + dmg * 80}px rgba(255,0,0,${dmg})`;
            } else {
                document.getElementById('damage-overlay').style.boxShadow = 'none';
            }
            // Round stats
            game.roundStats.survivalTime += dt;
            // Death → game over
            if (game.player.health <= 0) {
                game.setState('gameover');
            }
        },
        exit(game) {}
    },

    gameover: {
        enter(game) {
            if (document.pointerLockElement) document.exitPointerLock();
            game.player.locked = false;
            game.player.shooting = false;
            // Silence persistent audio
            game.audio.updateHeatWhine(0);
            game.audio.updateHeatSiren(0);
            game.audio.updateRateBuzz(null, false);
            game.audio.updateVentSound(false, 0);
            // Hide HUD but do NOT show gameover overlay yet
            document.getElementById('hud').style.display = 'none';
            document.getElementById('blocker').style.display = 'none';
            // Record death position for camera
            game.deathPos = game.player.position.clone();
            // Hide weapon
            game.player.weaponGroup.visible = false;
            // Big death explosion particles
            const upDir = new THREE.Vector3(0, 1, 0);
            game.particles.emit(game.deathPos, upDir, 120, 'explosion', { color: [1, 0.9, 0.7], size: 0.25 });
            game.renderer.compute(game.particles.computeSpawn);
            game.particles.emit(game.deathPos, upDir, 80, 'spark');
            game.renderer.compute(game.particles.computeSpawn);
            // Spawn large white death sphere (one-off, separate from pool)
            const dsGeo = new THREE.SphereGeometry(1, 20, 14);
            const dsMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.85,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
            });
            game.deathSphere = new THREE.Mesh(dsGeo, dsMat);
            game.deathSphere.position.copy(game.deathPos);
            game.deathSphere.scale.setScalar(0.1);
            game.scene.add(game.deathSphere);
            // Also spawn a pool explosion for immediate flash
            game.explosionSpheres.spawn(game.deathPos, 15, 1.0);
            game.audio.play('explosion', game.deathPos);
            // Death cam setup
            game.goTime = 0;
            game.goPhase = 'deathcam';
            game.deathTimeScale = 0.3;
            // Camera launch: mostly upward with slight random XZ for variety
            const rx = (Math.random() - 0.5) * 6;
            const rz = (Math.random() - 0.5) * 6;
            game.deathCamVel = new THREE.Vector3(rx, 40, rz);
            // Screen shake for impact
            game.shakeTimer = 0.4;
        },
        update(dt, game) {
            game.goTime += dt; // real time for phase transitions

            if (game.goPhase === 'deathcam') {
                const slowDt = dt * game.deathTimeScale;
                // Camera: launch upward with deceleration
                game.deathCamVel.multiplyScalar(1 - dt * 0.7);
                game.camera.position.add(game.deathCamVel.clone().multiplyScalar(slowDt));
                // Swing camera to look down at death position
                game.camera.lookAt(game.deathPos);
                // Screen shake during death cam (decays)
                if (game.shakeTimer > 0) {
                    game.shakeTimer -= dt;
                    const intensity = game.shakeTimer * 6;
                    game.camera.rotation.x += (Math.random() - 0.5) * 0.015 * intensity;
                    game.camera.rotation.y += (Math.random() - 0.5) * 0.015 * intensity;
                }
                // Death sphere: expand and fade over 2.5s
                if (game.deathSphere && game.deathSphere.visible) {
                    const t = Math.min(1, game.goTime / 2.5);
                    const ease = 1 - Math.pow(1 - t, 2);
                    game.deathSphere.scale.setScalar(0.5 + ease * 28);
                    game.deathSphere.material.opacity = 0.85 * (1 - t * t);
                    if (t >= 1) game.deathSphere.visible = false;
                }
                // Ramp time scale back toward 1.0 gradually
                game.deathTimeScale = Math.min(1, game.deathTimeScale + dt * 0.18);
                // Keep particles + explosion spheres updating in slow time
                game.particles.dtU.value = slowDt;
                game.renderer.compute(game.particles.computeUpdate);
                game.explosionSpheres.update(slowDt);
                // Keep enemies moving for dramatic effect
                game.profiler.mark('enemyCompute');
                game.enemies.syncUniforms(slowDt, game.deathPos, game.camera.position);
                game.enemies.updateDensity(slowDt, game.renderer);
                game.renderer.compute(game.enemies.computeUpdate);
                game.renderer.compute(game.enemies.computePhysics);
                game.profiler.markEnd('enemyCompute');
                // After ~3.5s real-time, transition to stats phase
                if (game.goTime > 3.5) {
                    game.goPhase = 'stats';
                    populateGameoverStats(game);
                    const overlay = document.getElementById('gameover-overlay');
                    overlay.style.opacity = '0';
                    overlay.style.transition = 'opacity 1.2s ease-in';
                    overlay.style.display = 'flex';
                    requestAnimationFrame(() => { overlay.style.opacity = '1'; });
                }
            } else {
                // Stats phase: gentle camera drift continues
                game.camera.position.y += dt * 1.5;
                game.camera.lookAt(game.deathPos);
                // Keep particles + enemies decaying
                game.particles.dtU.value = dt;
                game.renderer.compute(game.particles.computeUpdate);
                game.enemies.syncUniforms(dt, game.deathPos, game.camera.position);
                game.renderer.compute(game.enemies.computeUpdate);
                game.renderer.compute(game.enemies.computePhysics);
            }
        },
        exit(game) {
            // Clean up death sphere
            if (game.deathSphere) {
                game.scene.remove(game.deathSphere);
                game.deathSphere.geometry.dispose();
                game.deathSphere.material.dispose();
                game.deathSphere = null;
            }
            // Restore weapon visibility
            game.player.weaponGroup.visible = true;
            // Reset overlay
            const overlay = document.getElementById('gameover-overlay');
            overlay.style.display = 'none';
            overlay.style.opacity = '';
            overlay.style.transition = '';
            document.getElementById('damage-overlay').style.boxShadow = 'none';
        }
    },

    // ── Weapon Sandbox ──────────────────────────────────
    weapontest: {
        enter(game) {
            game.setActiveCamera(game.camera);
            // Hide all normal overlays
            document.getElementById('menu-overlay').style.display = 'none';
            document.getElementById('pregame-overlay').style.display = 'none';
            document.getElementById('gameover-overlay').style.display = 'none';
            document.getElementById('blocker').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            // Show weapon sandbox panel
            const panel = document.getElementById('wpn-sandbox-panel');
            if (panel) panel.style.display = 'block';
            // Place player on ground at origin
            const spawnY = game.terrain.getHeight(0, 0) + CFG.player.height;
            game.player.position.set(0, spawnY, 0);
            game.player.velocity.set(0, 0, 0);
            game.player.health = CFG.player.maxHealth;
            game.player.heat = 0;
            game.player.grounded = true;
            game.player.weaponGroup.visible = true;
            game.player.locked = false; // will become true when pointer lock acquired
            game.player.shooting = false;
            // Hide enemy mesh
            if (game.enemies.mesh) game.enemies.mesh.visible = false;
            // Show click-to-start prompt (pointer lock needs user gesture)
            game._sbPrompt = true;
        },
        update(dt, game) {
            // Unlocked: show click-to-start/resume prompt
            const prompt = document.getElementById('sb-lock-prompt');
            if (!game.player.locked) {
                if (prompt) prompt.style.display = 'flex';
                return;
            }
            if (prompt) prompt.style.display = 'none';
            game._sbPrompt = false;
            game.player.update(dt);
            // Screen shake
            if (game.shakeTimer > 0) {
                game.shakeTimer -= dt;
                const intensity = game.shakeTimer * 8;
                game.camera.rotation.x += (Math.random() - 0.5) * 0.02 * intensity;
                game.camera.rotation.y += (Math.random() - 0.5) * 0.02 * intensity;
            }
            // Shooting (same as playing, but no enemies/death)
            const shots = game.player.tryShoot();
            if (shots === 'overheat') {
                // Just reset heat, don't kill
                game.player.heat = 0;
                const pos = game.player.position.clone();
                const upDir = new THREE.Vector3(0, 1, 0);
                game.particles.emit(pos, upDir, 80, 'explosion');
                game.renderer.compute(game.particles.computeSpawn);
                game.particles.emit(pos, upDir, 50, 'spark');
                game.renderer.compute(game.particles.computeSpawn);
                game.audio.play('explosion');
                game.shakeTimer = 0.6;
            } else if (shots && shots.length) {
                const firstShot = shots[0];
                const pw = game.player.wpnParams.power / 255;
                const sd = game.player.wpnParams.spread / 255;
                const muzzleOvr = {
                    color: [1.0, 0.9 - pw * 0.6, 0.3 - pw * 0.2],
                    size: 0.06 + sd * 0.06,
                };
                game.particles.emit(firstShot.origin, firstShot.direction, CFG.particles.muzzleCount, 'muzzle', muzzleOvr);
                game.renderer.compute(game.particles.computeSpawn);
                const exhaustOvr = {
                    color: [1.0, 0.8 - pw * 0.5, 0.3 - pw * 0.2],
                    size: 0.08 + pw * 0.08,
                };
                game.particles.emit(firstShot.origin, firstShot.direction, 40, 'exhaust', exhaustOvr);
                game.renderer.compute(game.particles.computeSpawn);
                for (const shot of shots) {
                    game.projectiles.fire(shot.origin, shot.direction, shot.speed, shot.damage, game.player.wpnParams, shot.life, shot.explosionRadius, shot.explosionForce);
                }
                game.audio.play('gunshot', null, game.player.wpnParams);
            }
            // Venting
            if (game.player.keys['KeyR'] && game.player.heat > 0) {
                const ventAmount = CFG.heat.ventRate * dt;
                const actualVent = Math.min(game.player.heat, ventAmount);
                game.player.heat -= actualVent;
                const thrust = actualVent * CFG.heat.thrustMult;
                if (game.player.grounded) {
                    game.player.velocity.y = Math.max(game.player.velocity.y, 3);
                    game.player.position.y += 0.05;
                }
                game.player.velocity.y += thrust;
                game.player.grounded = false;
                game.player.shooting = false;
            }
            // Audio
            const isVenting = game.player.keys['KeyR'] && game.player.heat > 0;
            game.audio.updateVentSound(isVenting, game.player.heat / CFG.heat.maxHeat);
            game.audio.updateHeatWhine(game.player.heat);
            game.audio.updateHeatSiren(game.player.heat);
            game.audio.updateRateBuzz(game.player.wpnParams, game.player.shooting);
            // Terrain explosion helper (no enemy damage, just visuals + knockback)
            const triggerExplosion = (impactPos, damage, radius, force) => {
                const upDir = new THREE.Vector3(0, 1, 0);
                const damageNorm = Math.min(1, damage / 100);
                const radiusScale = radius != null ? radius : CFG.projectile.explosionRadius * (0.4 + damageNorm * 0.8);
                const forceScale = force != null ? force : CFG.projectile.explosionForce * (0.3 + damageNorm * 0.7);
                const radiusNorm = Math.min(1, radiusScale / CFG.projectile.explosionRadius);
                const expCount = Math.max(8, Math.round(CFG.particles.explosionCount * (0.3 + radiusNorm * 0.7)));
                const sparkCount = Math.max(4, Math.round(CFG.particles.explosionSparkCount * (0.3 + radiusNorm * 0.7)));
                const expOvr = { color: [1.0, 0.5 - damageNorm * 0.2, 0.1 + damageNorm * 0.2] };
                game.particles.emit(impactPos, upDir, expCount, 'explosion', expOvr);
                game.renderer.compute(game.particles.computeSpawn);
                game.particles.emit(impactPos, upDir, sparkCount, 'spark');
                game.renderer.compute(game.particles.computeSpawn);
                game.explosionSpheres.spawn(impactPos, radiusScale, damageNorm);
                game.audio.play('explosion', impactPos);
                // Self-knockback
                const toPlayer = game.player.position.clone().sub(impactPos);
                const playerDist = toPlayer.length();
                if (playerDist < radiusScale * 1.5) {
                    const falloff = 1 - Math.min(1, playerDist / (radiusScale * 1.5));
                    const knockForce = forceScale * 0.6 * falloff;
                    if (playerDist > 0.5) toPlayer.normalize();
                    game.player.velocity.x += toPlayer.x * knockForce;
                    game.player.velocity.z += toPlayer.z * knockForce;
                    game.player.velocity.y += knockForce * 0.5;
                    game.player.grounded = false;
                }
            };
            // Terrain impacts (no GPU enemy collision in sandbox)
            const impacts = game.projectiles.update(dt, game.particles, game.renderer);
            for (const impact of impacts) {
                triggerExplosion(impact.pos, impact.damage, impact.explosionRadius, impact.explosionForce);
            }
            // Particles + explosion spheres
            game.particles.dtU.value = dt;
            game.renderer.compute(game.particles.computeUpdate);
            game.explosionSpheres.update(dt);
            // Audio sync
            game.audio.syncVolumes();
            // Lighting
            game.sunLight.intensity = CFG.lighting.sunIntensity;
            game.sunLight.position.set(CFG.lighting.sunX, CFG.lighting.sunY, CFG.lighting.sunZ).normalize().multiplyScalar(400);
            game.ambientLight.intensity = CFG.lighting.ambientIntensity;
            game.sunLight.target.position.copy(game.player.position);
            game.sunLight.target.updateMatrixWorld();
            game.sunLight.position.copy(game.player.position).add(
                new THREE.Vector3(CFG.lighting.sunX, CFG.lighting.sunY, CFG.lighting.sunZ).normalize().multiplyScalar(200)
            );
            // Update sandbox panel derived stats readout
            game.updateSandboxPanel();
        },
        exit(game) {
            const panel = document.getElementById('wpn-sandbox-panel');
            if (panel) panel.style.display = 'none';
            if (game.enemies.mesh) game.enemies.mesh.visible = true;
        }
    }
};

// ============================================================
//  GAME (async WebGPU init)
// ============================================================
class Game {
    constructor() {
        this.clock = new THREE.Clock();
        this.fpsFrames = 0; this.fpsTime = 0; this.fpsDisplay = 0;
        this.state = null;
        this.roundStats = { survivalTime: 0, kills: 0, shotsFired: 0 };
        this.attractAngle = 0;
        this.attractTime = 0;
        this.shakeTimer = 0;
        this.goTime = 0;
        this.goCamStart = new THREE.Vector3();
        this._activeCamera = null;
    }

    async init() {
        // Renderer
        updateLoadProgress(5, 'Creating renderer...');
        this.renderer = new THREE.WebGPURenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.setClearColor(new THREE.Color(CFG.lighting.fogColor));
        document.body.appendChild(this.renderer.domElement);

        updateLoadProgress(10, 'Initializing WebGPU...');
        await this.renderer.init();

        // Scene
        updateLoadProgress(20, 'Building scene...');
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.Fog(new THREE.Color(CFG.lighting.fogColor), CFG.lighting.fogNear, CFG.lighting.fogFar);

        // Player camera
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 15000);
        this.scene.add(this.camera);

        // Attract camera (separate, not attached to player)
        this.attractCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 15000);
        this.scene.add(this.attractCamera);
        this._activeCamera = this.camera;

        // Lighting
        this.ambientLight = new THREE.AmbientLight(0x7799bb, CFG.lighting.ambientIntensity);
        this.scene.add(this.ambientLight);
        this.sunLight = new THREE.DirectionalLight(0xffeedd, CFG.lighting.sunIntensity);
        this.sunLight.position.set(CFG.lighting.sunX, CFG.lighting.sunY, CFG.lighting.sunZ).normalize().multiplyScalar(400);
        this.scene.add(this.sunLight);
        this.hemiLight = new THREE.HemisphereLight(0x88bbff, 0x445522, 0.3);
        this.scene.add(this.hemiLight);

        // Sky dome
        this.buildSky();

        // Terrain
        updateLoadProgress(30, 'Generating terrain...');
        this.terrain = new Terrain(this.scene);

        // Player
        this.player = new Player(this.camera, this.terrain);

        // Player shadow
        const pShadowGeo = new THREE.CircleGeometry(0.7, 12);
        pShadowGeo.rotateX(-Math.PI / 2);
        this.playerShadow = new THREE.Mesh(pShadowGeo,
            new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.35, depthWrite: false }));
        this.scene.add(this.playerShadow);

        // Audio
        updateLoadProgress(40, 'Initializing audio...');
        this.audio = new AudioEngine(this.camera);

        // GPU Enemies
        updateLoadProgress(50, `Spawning ${fmtEnemyCount(ENEMY_COUNT)} enemies...`);
        this.enemies = new GPUEnemySystem(this.scene, this.terrain);
        await this.renderer.computeAsync(this.enemies.computeInit);

        // GPU Particles
        updateLoadProgress(70, 'Initializing particles...');
        this.particles = new GPUParticleSystem(this.scene);
        await this.renderer.computeAsync(this.particles.computeInit);

        // Projectiles (CPU)
        updateLoadProgress(80, 'Setting up projectiles...');
        this.projectiles = new ProjectileSystem(this.scene, this.terrain);

        // Explosion spheres
        this.explosionSpheres = new ExplosionSpherePool(this.scene);

        // Pickups
        this.pickupManager = new PickupManager(this.scene, this.terrain);
        this.pickupManager.spawnAll();

        // Build overlay DOM
        updateLoadProgress(90, 'Building interface...');
        this.buildMenuOverlay();
        this.buildPregameOverlay();
        this.buildGameOverOverlay();

        // Performance profiler + graph
        this.profiler = new PerformanceProfiler();
        this.perfGraph = new PerformanceGraphOverlay(this);

        // Debug
        this.debug = new DebugOverlay(this);

        // Pointer lock + events
        this.setupPointerLock();
        window.addEventListener('resize', () => this.onResize());
        // Reload removed — weapon system uses heat/ammo pickups instead

        // Fade out loading screen, start attract
        updateLoadProgress(100, 'Ready');
        analytics.event('game_loaded');
        const ls = document.getElementById('loading-screen');
        ls.classList.add('fade-out');
        setTimeout(() => { ls.style.display = 'none'; }, 800);

        if (WEAPON_SANDBOX) {
            this.buildSandboxPanel();
            this.setState('weapontest');
        } else {
            this.setState('attract');
        }

        // Start loop
        this.renderer.setAnimationLoop(() => this.animate());
    }

    setupPointerLock() {
        const blocker = document.getElementById('blocker');
        // Exit to menu button
        document.getElementById('exit-to-menu-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            blocker.style.display = 'none';
            this.setState('attract');
        });
        // Blocker click → resume playing (only relevant in PLAYING pause state)
        blocker.addEventListener('click', () => {
            if (this.state === 'playing' || this.state === 'pregame' || this.state === 'drop' || this.state === 'weapontest') {
                this.renderer.domElement.requestPointerLock();
            }
        });
        // Click canvas directly to re-lock in weapon sandbox (no blocker overlay)
        this.renderer.domElement.addEventListener('click', () => {
            if (this.state === 'weapontest' && !document.pointerLockElement) {
                this.renderer.domElement.requestPointerLock();
            }
        });
        document.addEventListener('pointerlockchange', () => {
            const locked = document.pointerLockElement === this.renderer.domElement;
            this.player.locked = locked;
            // In weapon sandbox: no blocker, just toggle locked state
            if (this.state === 'weapontest') {
                blocker.style.display = 'none';
                return;
            }
            // In active game states, show blocker when pointer lock lost (pause)
            if (this.state === 'playing' || this.state === 'pregame' || this.state === 'drop') {
                if (this.debug && this.debug.visible) {
                    blocker.style.display = 'none';
                } else if (!locked) {
                    blocker.style.display = 'flex';
                } else {
                    blocker.style.display = 'none';
                }
            }
        });
    }

    onResize() {
        const aspect = window.innerWidth / window.innerHeight;
        this.camera.aspect = aspect;
        this.camera.updateProjectionMatrix();
        this.attractCamera.aspect = aspect;
        this.attractCamera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    setState(name) {
        if (this.state && STATES[this.state] && STATES[this.state].exit) STATES[this.state].exit(this);
        this.state = name;
        if (STATES[name] && STATES[name].enter) STATES[name].enter(this);
    }

    setActiveCamera(cam) {
        if (this.audio && this.audio.listener) {
            if (this._activeCamera) this._activeCamera.remove(this.audio.listener);
            cam.add(this.audio.listener);
        }
        this._activeCamera = cam;
    }

    buildSky() {
        const skyGeo = new THREE.SphereGeometry(6000, 32, 20);
        const skyMat = new THREE.MeshBasicNodeMaterial({ side: THREE.BackSide, fog: false });

        // Normalized direction from sphere center
        const pos = normalize(positionLocal);
        const py = pos.y;  // -1 (bottom) to +1 (top)

        // Derive fog color in LINEAR space from CFG (Three.js Color converts sRGB hex → linear)
        const fogC = new THREE.Color(CFG.lighting.fogColor);
        const fogCol = vec3(fogC.r, fogC.g, fogC.b);  // linear space — matches scene fog exactly

        // Gradient: deep blue at zenith → pale blue-gray → atmospheric haze at horizon → fog below
        const zenith = vec3(0.01, 0.02, 0.16);    // linear: dark blue
        const midSky = vec3(0.17, 0.30, 0.57);    // linear: medium blue
        // These are LINEAR values so they'll look correct after sRGB output conversion

        // Upper sky gradient (above haze band)
        const skyT = smoothstep(float(0.0), float(1.0), py);
        const upperSky = mix(fogCol, mix(midSky, zenith, skyT), skyT);

        // Wispy clouds: elongated noise bands at mid-altitude
        const px = pos.x;
        const pz = pos.z;
        const t = time.mul(0.008);

        // Cloud layer 1: broad wisps
        const cx1 = px.mul(3.0).add(t.mul(0.7));
        const cz1 = pz.mul(3.0).add(t.mul(0.3));
        const cloud1 = sin(cx1.mul(1.2)).mul(cos(cz1.mul(0.8))).add(
            sin(cx1.mul(2.7).add(float(1.3))).mul(0.5)
        ).add(
            cos(cz1.mul(3.1).add(float(2.1))).mul(0.3)
        );
        const cloudMask1 = smoothstep(float(0.2), float(0.6), py).mul(
            smoothstep(float(0.9), float(0.7), py)
        );
        const cloudAlpha1 = smoothstep(float(0.4), float(1.2), cloud1).mul(cloudMask1).mul(0.25);

        // Cloud layer 2: thinner streaks
        const cx2 = px.mul(6.0).add(t.mul(1.1));
        const cz2 = pz.mul(2.0).sub(t.mul(0.5));
        const cloud2 = sin(cx2.mul(1.8)).mul(cos(cz2.mul(3.2))).add(
            sin(cx2.mul(3.5).add(float(4.2))).mul(0.4)
        );
        const cloudMask2 = smoothstep(float(0.15), float(0.5), py).mul(
            smoothstep(float(0.85), float(0.65), py)
        );
        const cloudAlpha2 = smoothstep(float(0.5), float(1.1), cloud2).mul(cloudMask2).mul(0.15);

        // Aurora-like streaks: vertical color bands near zenith
        const aAngle = px.mul(2.0).add(pz).add(t.mul(1.5));
        const streakBase = sin(aAngle.mul(4.0)).mul(cos(aAngle.mul(1.3).add(float(1.7))));
        const streakMask = smoothstep(float(0.5), float(0.85), py);
        const streakAlpha = smoothstep(float(0.3), float(0.9), streakBase).mul(streakMask).mul(0.08);
        const streakColor = vec3(0.4, 0.6, 1.0);

        // Sun glow near the sun direction
        const sunDir = normalize(vec3(
            float(CFG.lighting.sunX),
            float(CFG.lighting.sunY),
            float(CFG.lighting.sunZ)
        ));
        const sunDot = dot(pos, sunDir).max(0.0);
        const sunGlow = pow(sunDot, float(64.0)).mul(0.8);
        const sunHaze = pow(sunDot, float(8.0)).mul(0.15);
        const sunColor = vec3(1.0, 0.92, 0.7);

        // Compose sky + clouds + effects
        const composedColor = mix(upperSky, vec3(1.0, 1.0, 1.0), cloudAlpha1.add(cloudAlpha2))
            .add(streakColor.mul(streakAlpha))
            .add(sunColor.mul(sunGlow.add(sunHaze)));

        // Atmospheric haze band: blends EVERYTHING toward fog color near horizon
        // This extends well above py=0 so fogged terrain blends seamlessly into sky
        // At py <= 0: 100% fog color (below horizon)
        // At py = 0.15: ~50% haze
        // At py >= 0.35: no haze, pure sky
        const hazeStrength = smoothstep(float(0.35), float(0.0), py);
        const finalColor = mix(composedColor, fogCol, hazeStrength);

        skyMat.colorNode = finalColor;
        const skyMesh = new THREE.Mesh(skyGeo, skyMat);
        skyMesh.renderOrder = -1;
        this.scene.add(skyMesh);
        this.skyMesh = skyMesh;
    }

    buildMenuOverlay() {
        const el = document.getElementById('menu-overlay');
        el.innerHTML = '';
        // Title
        const title = document.createElement('div');
        title.className = 'menu-title';
        title.textContent = 'MILLION2ONE';
        el.appendChild(title);
        const sub = document.createElement('div');
        sub.className = 'menu-subtitle';
        sub.textContent = 'DEATH IS INEVITABLE';
        el.appendChild(sub);
        // Version label
        const ver = document.createElement('div');
        ver.className = 'version-label';
        ver.textContent = VERSION;
        el.appendChild(ver);
        // Buttons container
        const btns = document.createElement('div');
        btns.style.cssText = 'display:flex;flex-direction:column;align-items:center';
        const mkBtn = (text, fn) => {
            const b = document.createElement('button');
            b.className = 'menu-btn';
            b.textContent = text;
            b.onclick = fn;
            btns.appendChild(b);
        };
        mkBtn('START GAME', () => this.setState('pregame'));
        mkBtn('WHAT IS THIS?', () => this.showPanel('whatis-panel'));
        mkBtn('HIGH SCORES', () => this.showPanel('scores-panel'));
        mkBtn('SETTINGS', () => this.showPanel('settings-panel'));
        mkBtn('HELP', () => this.showPanel('help-panel'));
        mkBtn('WEAPON SANDBOX', () => {
            window.location.hash = 'weapon';
            window.location.reload();
        });
        el.appendChild(btns);
        // Support banner
        const banner = document.createElement('div');
        banner.className = 'support-banner';
        const supportBtn = document.createElement('button');
        supportBtn.className = 'support-btn';
        supportBtn.textContent = '\u2764 SUPPORT THIS GAME';
        supportBtn.onclick = () => openSupportModal();
        banner.appendChild(supportBtn);
        el.appendChild(banner);

        // "What is this?" panel (shown via menu button)
        const whatisPanel = document.createElement('div');
        whatisPanel.className = 'menu-panel';
        whatisPanel.id = 'whatis-panel';
        whatisPanel.innerHTML = `<h2>WHAT IS THIS?</h2>
            <p>A browser-based FPS experiment: <span class="tag">1,000,000 enemies</span> simulated on the GPU, all at once, in a single HTML file.</p>
            <p class="warn">This is an early prototype. You'll need a relatively beefy machine with a decent GPU to run it smoothly — optimisation hasn't begun yet.</p>
            <p>We're still working out the core gameplay mechanics — weapon tuning, enemy behaviour, movement systems — so things will change. A lot.</p>
            <p>All graphics are placeholder / work-in-progress. If it looks rough, that's because it is!</p>
            <p style="margin-top:12px;color:#8af">Feedback is very welcome. Hit the <span class="tag">SUPPORT THIS GAME</span> button above to share your thoughts or fuel development.</p>`;
        const whatisBack = document.createElement('button');
        whatisBack.className = 'menu-btn back-btn';
        whatisBack.textContent = 'BACK';
        whatisBack.onclick = () => whatisPanel.style.display = 'none';
        whatisPanel.appendChild(whatisBack);
        el.appendChild(whatisPanel);

        // High Scores panel
        const scoresPanel = document.createElement('div');
        scoresPanel.className = 'menu-panel';
        scoresPanel.id = 'scores-panel';
        scoresPanel.innerHTML = '<h2>HIGH SCORES</h2><div class="scores-list"></div>';
        const scoresBack = document.createElement('button');
        scoresBack.className = 'menu-btn back-btn';
        scoresBack.textContent = 'BACK';
        scoresBack.onclick = () => scoresPanel.style.display = 'none';
        scoresPanel.appendChild(scoresBack);
        el.appendChild(scoresPanel);

        // Settings panel
        const settingsPanel = document.createElement('div');
        settingsPanel.className = 'menu-panel';
        settingsPanel.id = 'settings-panel';
        settingsPanel.innerHTML = '<h2>SETTINGS</h2>';
        const addSlider = (label, key, min, max, step) => {
            const row = document.createElement('div');
            row.className = 'debug-row';
            const lbl = document.createElement('label');
            lbl.textContent = label;
            row.appendChild(lbl);
            const [cat, k] = key.split('.');
            const slider = document.createElement('input');
            slider.type = 'range'; slider.min = min; slider.max = max; slider.step = step; slider.value = CFG[cat][k];
            const val = document.createElement('span');
            val.className = 'val';
            val.textContent = Number(CFG[cat][k]).toFixed(step < 1 ? 2 : 0);
            slider.addEventListener('input', () => {
                const v = parseFloat(slider.value);
                CFG[cat][k] = v;
                val.textContent = v.toFixed(step < 1 ? 2 : 0);
                if (this.audio) this.audio.syncVolumes();
            });
            row.appendChild(slider);
            row.appendChild(val);
            settingsPanel.appendChild(row);
        };
        addSlider('Master Volume', 'audio.masterVolume', 0, 1, 0.05);
        addSlider('SFX Volume', 'audio.sfxVolume', 0, 1, 0.05);
        addSlider('Music Volume', 'audio.musicVolume', 0, 1, 0.05);
        // Handedness toggle
        const handRow = document.createElement('div');
        handRow.className = 'debug-row';
        const handLabel = document.createElement('label');
        handLabel.textContent = 'Handedness';
        handRow.appendChild(handLabel);
        const handBtn = document.createElement('button');
        handBtn.className = 'menu-btn';
        handBtn.style.cssText = 'display:inline-block;width:auto;padding:6px 18px;font-size:13px;margin:0';
        handBtn.textContent = CFG.handedness === 'left' ? '◀ LEFT' : 'RIGHT ▶';
        handBtn.onclick = () => {
            CFG.handedness = CFG.handedness === 'left' ? 'right' : 'left';
            handBtn.textContent = CFG.handedness === 'left' ? '◀ LEFT' : 'RIGHT ▶';
            if (game && game.player) game.player.applyHandedness();
        };
        handRow.appendChild(handBtn);
        settingsPanel.appendChild(handRow);

        // --- Enemy Count selector ---
        const enemySection = document.createElement('div');
        enemySection.style.cssText = 'margin-top:16px;padding-top:14px;border-top:1px solid rgba(136,170,255,0.1)';
        const enemyTitle = document.createElement('div');
        enemyTitle.style.cssText = 'color:#8af;font-size:12px;letter-spacing:1.5px;margin-bottom:10px;text-transform:uppercase';
        enemyTitle.textContent = 'Enemy Count';
        enemySection.appendChild(enemyTitle);

        const enemyRow = document.createElement('div');
        enemyRow.style.cssText = 'display:flex;gap:4px;flex-wrap:wrap;margin-bottom:6px';
        const currentCount = ENEMY_COUNT;
        ENEMY_COUNT_OPTIONS.forEach((count, i) => {
            const btn = document.createElement('button');
            btn.className = 'menu-btn';
            btn.style.cssText = 'display:inline-block;width:auto;padding:6px 12px;font-size:12px;margin:0;letter-spacing:1px';
            btn.textContent = ENEMY_COUNT_LABELS[i];
            if (count === currentCount) {
                btn.style.background = 'rgba(136,170,255,0.2)';
                btn.style.borderColor = '#8af';
                btn.style.color = '#fff';
            }
            btn.onclick = () => {
                if (count === currentCount) return;
                try { localStorage.setItem('m2o_enemyCount', count); } catch(e) {}
                location.reload();
            };
            enemyRow.appendChild(btn);
        });
        enemySection.appendChild(enemyRow);

        const enemyNote = document.createElement('div');
        enemyNote.style.cssText = 'color:#555;font-size:10px;letter-spacing:0.5px;line-height:1.5';
        enemyNote.textContent = 'Changing enemy count will restart the game.';
        enemySection.appendChild(enemyNote);
        settingsPanel.appendChild(enemySection);

        // --- System Info ---
        const sysSection = document.createElement('div');
        sysSection.style.cssText = 'margin-top:16px;padding-top:14px;border-top:1px solid rgba(136,170,255,0.1)';
        const sysTitle = document.createElement('div');
        sysTitle.style.cssText = 'color:#8af;font-size:12px;letter-spacing:1.5px;margin-bottom:8px;text-transform:uppercase';
        sysTitle.textContent = 'System Info';
        sysSection.appendChild(sysTitle);

        const caps = window.systemCapabilities;
        if (caps) {
            const lines = [
                { label: 'GPU', value: caps.adapterName, color: '#ccc' },
                { label: 'Benchmark', value: caps.benchmarkMs >= 0 ? caps.benchmarkMs.toFixed(1) + 'ms' : 'N/A', color: caps.benchmarkMs < 5 ? '#4e4' : caps.benchmarkMs < 15 ? '#fa4' : '#f44' },
                { label: 'Verdict', value: caps.verdict.toUpperCase(), color: caps.verdict === 'good' ? '#4e4' : caps.verdict === 'caution' ? '#fa4' : '#f44' },
            ];
            if (caps.memoryHint) lines.push({ label: 'RAM', value: caps.memoryHint + 'GB', color: '#ccc' });
            if (caps.estimatedMaxEnemies > 0) {
                const maxE = caps.estimatedMaxEnemies;
                const maxLabel = maxE >= 1000000 ? (maxE / 1000000).toFixed(1) + 'M' : maxE >= 1000 ? Math.round(maxE / 1000) + 'K' : maxE.toString();
                lines.push({ label: 'Est. Max Enemies', value: '~' + maxLabel + ' @60fps', color: maxE >= ENEMY_COUNT ? '#4e4' : '#fa4' });
            }
            lines.forEach(l => {
                const row = document.createElement('div');
                row.style.cssText = 'display:flex;justify-content:space-between;padding:2px 0;font-size:11px';
                const lbl = document.createElement('span');
                lbl.style.color = '#666';
                lbl.textContent = l.label;
                const val = document.createElement('span');
                val.style.cssText = `color:${l.color};letter-spacing:0.5px`;
                val.textContent = l.value;
                row.appendChild(lbl);
                row.appendChild(val);
                sysSection.appendChild(row);
            });
        } else {
            const na = document.createElement('div');
            na.style.cssText = 'color:#555;font-size:11px';
            na.textContent = 'System check data unavailable.';
            sysSection.appendChild(na);
        }
        settingsPanel.appendChild(sysSection);

        const settingsBack = document.createElement('button');
        settingsBack.className = 'menu-btn back-btn';
        settingsBack.textContent = 'BACK';
        settingsBack.onclick = () => settingsPanel.style.display = 'none';
        settingsPanel.appendChild(settingsBack);
        el.appendChild(settingsPanel);

        // Help panel
        const helpPanel = document.createElement('div');
        helpPanel.className = 'menu-panel';
        helpPanel.id = 'help-panel';
        helpPanel.style.minWidth = '500px';
        const helpRows = [
            { section: 'Movement' },
            { key: 'W A S D', desc: 'Move', detail: 'Forward, left, back, right' },
            { key: 'SHIFT', desc: 'Sprint', detail: 'Hold while moving for 1.8x speed' },
            { key: 'SPACE', desc: 'Jump', detail: 'Only while grounded' },
            { section: 'Combat' },
            { key: 'LEFT CLICK', desc: 'Shoot', detail: 'Hold for continuous fire. Rate depends on your gun config.' },
            { key: 'R', desc: 'Vent heat', detail: 'Hold to vent heat as upward thrust. More heat = more boost. No shooting while venting.' },
            { section: 'Weapon Tuning' },
            { key: 'Hold 1 + Mouse', desc: 'Adjust Spread', detail: 'Left = tighter beam, Right = wider cone. High spread = shotgun.' },
            { key: 'Hold 2 + Mouse', desc: 'Adjust Rate', detail: 'Left = slower, Right = faster fire. High rate = big heat buildup.' },
            { key: 'Hold 3 + Mouse', desc: 'Adjust Power', detail: 'Left = weaker, Right = stronger. Affects damage per hit.' },
            { key: 'Hold 4 + Mouse', desc: 'Adjust Speed', detail: 'Left = slow projectiles, Right = near-hitscan.' },
            { key: '7 / 8 / 9', desc: 'Load presets', detail: '7 = Shotgun, 8 = Sniper, 9 = Everything maxed (danger!)' },
            { section: 'System' },
            { key: 'MOUSE', desc: 'Look around', detail: 'Free mouselook while pointer is locked' },
            { key: 'F', desc: 'Fullscreen', detail: 'Toggle fullscreen mode' },
            { key: '~', desc: 'Debug panel', detail: 'Live-tweak all game parameters. Press again to close.' },
            { key: 'ESC', desc: 'Pause / Release cursor', detail: 'Releases pointer lock. Click to resume.' },
        ];
        let helpHTML = '<h2>CONTROLS</h2>';
        for (const row of helpRows) {
            if (row.section) {
                helpHTML += `<div class="help-section-title">${row.section}</div>`;
            } else {
                helpHTML += `<div class="help-row"><div class="help-key">${row.key}</div><div><div class="help-desc">${row.desc}</div><div class="help-detail">${row.detail}</div></div></div>`;
            }
        }
        helpHTML += `<p style="margin-top:16px;color:#555;font-size:11px">Your gun is fully configurable. Every shot builds heat — let it hit 100 and it explodes, killing you instantly. Vent heat to cool down and gain thrust. Master the cycle to fly.</p>`;
        helpPanel.innerHTML = helpHTML;
        const helpBack = document.createElement('button');
        helpBack.className = 'menu-btn back-btn';
        helpBack.textContent = 'BACK';
        helpBack.onclick = () => helpPanel.style.display = 'none';
        helpPanel.appendChild(helpBack);
        el.appendChild(helpPanel);

    }

    showPanel(id) {
        document.querySelectorAll('.menu-panel').forEach(p => p.style.display = 'none');
        const panel = document.getElementById(id);
        if (panel) {
            panel.style.display = 'block';
            if (id === 'scores-panel') this.populateScores();
        }
    }

    buildPregameOverlay() {
        const el = document.getElementById('pregame-overlay');
        el.innerHTML = `
            <div class="drop-text">CLICK TO DROP</div>
            <div class="drop-sub">WASD move · SHIFT sprint · SPACE jump · R vent heat</div>
        `;
    }

    buildGameOverOverlay() {
        const el = document.getElementById('gameover-overlay');
        el.innerHTML = '';
        // Title
        const title = document.createElement('div');
        title.className = 'go-title';
        title.textContent = 'GAME OVER';
        el.appendChild(title);
        // Death cause
        const deathCause = document.createElement('div');
        deathCause.className = 'go-death-cause';
        el.appendChild(deathCause);
        // Remain count (hero number)
        const remain = document.createElement('div');
        remain.className = 'go-remain';
        el.appendChild(remain);
        // Progress bar
        const bar = document.createElement('div');
        bar.className = 'go-bar';
        const barFill = document.createElement('div');
        barFill.className = 'go-bar-fill';
        bar.appendChild(barFill);
        el.appendChild(bar);
        // Stat line
        const statLine = document.createElement('div');
        statLine.className = 'go-stat-line';
        el.appendChild(statLine);
        // High score text
        const hsText = document.createElement('div');
        hsText.className = 'go-highscore';
        hsText.textContent = 'NEW HIGH SCORE!';
        el.appendChild(hsText);
        // Gun loadout line
        const loadoutLine = document.createElement('div');
        loadoutLine.className = 'go-loadout';
        el.appendChild(loadoutLine);
        // Share button
        const shareBtn = document.createElement('button');
        shareBtn.className = 'go-share-btn';
        shareBtn.textContent = 'SHARE RESULTS';
        shareBtn.onclick = () => {
            const text = this.generateShareText();
            navigator.clipboard.writeText(text).then(() => {
                shareBtn.textContent = '\u2713 COPIED';
                shareBtn.classList.add('copied');
                setTimeout(() => {
                    shareBtn.textContent = 'SHARE RESULTS';
                    shareBtn.classList.remove('copied');
                }, 2000);
            }).catch(() => {
                // Fallback: select text in a textarea
                const ta = document.createElement('textarea');
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                shareBtn.textContent = '\u2713 COPIED';
                shareBtn.classList.add('copied');
                setTimeout(() => {
                    shareBtn.textContent = 'SHARE RESULTS';
                    shareBtn.classList.remove('copied');
                }, 2000);
            });
        };
        el.appendChild(shareBtn);
        // Play again / Main menu
        const buttons = document.createElement('div');
        buttons.className = 'go-buttons';
        const mkBtn = (text, fn) => {
            const b = document.createElement('button');
            b.className = 'menu-btn';
            b.textContent = text;
            b.onclick = fn;
            buttons.appendChild(b);
        };
        mkBtn('PLAY AGAIN', () => this.setState('pregame'));
        mkBtn('MAIN MENU', () => this.setState('attract'));
        el.appendChild(buttons);
        // Support banner
        const goBanner = document.createElement('div');
        goBanner.className = 'support-banner';
        const goSupportBtn = document.createElement('button');
        goSupportBtn.className = 'support-btn';
        goSupportBtn.textContent = '\u2764 SUPPORT THIS GAME';
        goSupportBtn.onclick = () => openSupportModal();
        goBanner.appendChild(goSupportBtn);
        el.appendChild(goBanner);
    }

    saveHighScore(stats) {
        try {
            const scores = this.getHighScores();
            scores.push({ time: stats.survivalTime, kills: stats.kills, shots: stats.shotsFired, date: Date.now() });
            scores.sort((a, b) => b.time - a.time);
            localStorage.setItem('fps_highscores', JSON.stringify(scores.slice(0, 10)));
        } catch (e) { /* localStorage not available */ }
    }

    getHighScores() {
        try {
            return JSON.parse(localStorage.getItem('fps_highscores') || '[]');
        } catch (e) { return []; }
    }

    generateShareText() {
        const kills = this.roundStats.kills;
        const remain = Math.max(0, ENEMY_COUNT - kills);
        const mins = Math.floor(this.roundStats.survivalTime / 60);
        const secs = Math.floor(this.roundStats.survivalTime % 60);
        const timeStr = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        const accuracy = this.roundStats.shotsFired > 0
            ? Math.min(100, Math.round(kills / this.roundStats.shotsFired * 100)) + '%'
            : '\u2014';
        // Progress bar: 20 chars, filled = remaining, empty = killed
        const barLen = 20;
        const filledCount = Math.round((remain / ENEMY_COUNT) * barLen);
        const bar = '\u2588'.repeat(filledCount) + '\u2591'.repeat(barLen - filledCount);
        const loadout = this.roundStats.loadoutHex || '#80808080';
        return [
            'MILLION2ONE',
            `${bar} ${remain.toLocaleString()} remain`,
            `\u23F1 ${timeStr} | \uD83C\uDFAF ${accuracy} | \uD83D\uDC80 ${kills.toLocaleString()}`,
            `\uD83D\uDD2B ${loadout}`,
            'million2.one'
        ].join('\n');
    }

    populateScores() {
        const list = document.querySelector('.scores-list');
        if (!list) return;
        const scores = this.getHighScores();
        if (scores.length === 0) {
            list.innerHTML = '<p style="color:#666">No scores yet. Play a round!</p>';
            return;
        }
        list.innerHTML = scores.map((s, i) => {
            const mins = Math.floor(s.time / 60);
            const secs = Math.floor(s.time % 60);
            return `<p class="score-row">${i + 1}. <span>${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}</span> — ${s.kills} kills — ${s.shots} shots</p>`;
        }).join('');
    }

    async regenerateTerrain() {
        this.terrain.generate();
        this.player.position.y = this.terrain.getHeight(this.player.position.x, this.player.position.z) + CFG.player.height;
        await this.renderer.computeAsync(this.enemies.computeInit);
        this.pickupManager.spawnAll();
        this.enemies.clearKillCount(this.renderer);
    }

    async respawnEnemies() {
        await this.renderer.computeAsync(this.enemies.computeInit);
        this.enemies.clearKillCount(this.renderer);
    }

    // ── Weapon Sandbox Panel ─────────────────────────────
    buildSandboxPanel() {
        const panel = document.createElement('div');
        panel.id = 'wpn-sandbox-panel';
        panel.style.cssText = `
            position: fixed; top: 10px; left: 10px; width: 320px;
            background: rgba(0,0,0,0.85); border: 1px solid #555; border-radius: 8px;
            color: #eee; font: 12px/1.4 monospace; padding: 12px; z-index: 9999;
            display: none; pointer-events: auto; max-height: 95vh; overflow-y: auto;
            user-select: none;
        `;
        panel.innerHTML = `
            <div style="font-size:14px;font-weight:bold;margin-bottom:4px;color:#ff8844;">
                WEAPON SANDBOX
            </div>
            <div style="font-size:10px;color:#666;margin-bottom:8px;">Test and tune weapon feel without enemies</div>
            <details id="sb-help" style="margin-bottom:10px;cursor:pointer;">
                <summary style="font-size:10px;color:#8af;letter-spacing:1px;">HOW TO USE</summary>
                <div style="font-size:10px;color:#999;line-height:1.6;margin-top:6px;padding:6px 8px;background:rgba(136,170,255,0.06);border-radius:4px;">
                    <div style="color:#aaa;margin-bottom:4px;font-weight:bold;">Controls</div>
                    <span style="color:#8af;">Click canvas</span> to lock mouse &amp; shoot · <span style="color:#8af;">ESC</span> to unlock &amp; tweak sliders<br>
                    <span style="color:#8af;">WASD</span> move · <span style="color:#8af;">Shift</span> sprint · <span style="color:#8af;">Space</span> jump · <span style="color:#8af;">R</span> vent heat (jetpack)<br>
                    <span style="color:#8af;">Hold 1-4</span> + mouse = adjust spread/rate/power/speed in-game<br>
                    <span style="color:#8af;">7 / 8 / 9</span> = quick-load presets (Shotgun / Sniper / MAX)
                    <div style="color:#aaa;margin:6px 0 4px;font-weight:bold;">Tuning Guide</div>
                    <span style="color:#5599ff;">SPREAD</span> &rarr; more pellets, slower speed, shorter range, smaller explosions<br>
                    <span style="color:#44ddaa;">RATE</span> &rarr; faster fire, less damage per hit (DPS trade-off)<br>
                    <span style="color:#ff8844;">POWER</span> &rarr; bigger damage &amp; explosion radius per pellet<br>
                    <span style="color:#cc66ff;">SPEED</span> &rarr; faster projectiles, longer range, flatter trajectory<br>
                    <span style="color:#888;">Parameters are <em>soft-coupled</em> &mdash; cranking spread automatically reduces speed &amp; range to create natural archetypes.</span>
                    <div style="color:#aaa;margin:6px 0 4px;font-weight:bold;">What to Look For</div>
                    Watch the <span style="color:#ffaa44;">Derived Stats</span> panel as you adjust &mdash; Total DPS, Max Range, and Pellet Count tell you the archetype story. Fire at the ground to feel explosion radius, self-knockback, and visual scale.
                    <div style="margin-top:8px;">
                        <span style="color:#8af;cursor:pointer;" onclick="window.location.hash='';window.location.reload();">&larr; Back to main game</span>
                    </div>
                </div>
            </details>
            <div id="sb-raw-params"></div>
            <hr style="border-color:#444;margin:10px 0;">
            <div style="font-size:11px;font-weight:bold;color:#5599ff;margin-bottom:6px;">DERIVED STATS (soft-coupled)</div>
            <div id="sb-derived-stats" style="font-size:11px;"></div>
            <hr style="border-color:#444;margin:10px 0;">
            <div style="font-size:11px;font-weight:bold;color:#44ddaa;margin-bottom:6px;">CFG TWEAKS</div>
            <div id="sb-cfg-tweaks"></div>
            <hr style="border-color:#444;margin:10px 0;">
            <div style="font-size:11px;font-weight:bold;color:#cc66ff;margin-bottom:6px;">PRESETS</div>
            <div id="sb-presets" style="display:flex;gap:4px;flex-wrap:wrap;"></div>
        `;
        document.body.appendChild(panel);

        // Click-to-lock prompt (shown when pointer not locked)
        const prompt = document.createElement('div');
        prompt.id = 'sb-lock-prompt';
        prompt.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.4); z-index: 50; cursor: pointer;
            pointer-events: auto;
        `;
        prompt.innerHTML = `
            <div style="font:bold 18px monospace;color:#ff8844;letter-spacing:3px;margin-bottom:8px;">WEAPON SANDBOX</div>
            <div style="font:13px monospace;color:#aaa;">Click to start shooting</div>
            <div style="font:11px monospace;color:#666;margin-top:4px;">ESC to unlock mouse &amp; tweak sliders</div>
        `;
        prompt.addEventListener('click', () => {
            this.renderer.domElement.requestPointerLock();
        });
        document.body.appendChild(prompt);

        // Raw param sliders
        const rawParams = [
            { key: 'spread', label: 'SPREAD', color: '#5599ff' },
            { key: 'rate',   label: 'RATE',   color: '#44ddaa' },
            { key: 'power',  label: 'POWER',  color: '#ff8844' },
            { key: 'speed',  label: 'SPEED',  color: '#cc66ff' },
        ];
        const rawDiv = document.getElementById('sb-raw-params');
        rawParams.forEach(({ key, label, color }) => {
            const row = document.createElement('div');
            row.style.cssText = 'display:flex;align-items:center;gap:6px;margin-bottom:4px;';
            row.innerHTML = `
                <span style="width:52px;color:${color};font-size:11px;font-weight:bold;">${label}</span>
                <input type="range" min="0" max="255" value="${this.player.wpnParams[key]}"
                    data-param="${key}" class="sb-slider"
                    style="flex:1;accent-color:${color};height:16px;cursor:pointer;">
                <span class="sb-val" data-param="${key}" style="width:28px;text-align:right;font-size:11px;">${this.player.wpnParams[key]}</span>
            `;
            rawDiv.appendChild(row);
        });
        // Wire sliders
        rawDiv.querySelectorAll('.sb-slider').forEach(slider => {
            slider.addEventListener('input', () => {
                const key = slider.dataset.param;
                const val = parseInt(slider.value);
                this.player.wpnParams[key] = val;
                rawDiv.querySelector(`.sb-val[data-param="${key}"]`).textContent = val;
            });
        });

        // CFG tweaks
        const cfgTweaks = [
            { path: 'projectile.gravity', label: 'Gravity', min: 0, max: 100, step: 1 },
            { path: 'weapon.convergeDist', label: 'Converge Dist', min: 5, max: 200, step: 5 },
            { path: 'projectile.explosionRadius', label: 'Base Exp Radius', min: 1, max: 80, step: 1 },
            { path: 'projectile.explosionForce', label: 'Base Exp Force', min: 1, max: 120, step: 1 },
            { path: 'heat.coolRate', label: 'Heat Cool Rate', min: 1, max: 50, step: 1 },
            { path: 'heat.ventRate', label: 'Vent Rate', min: 5, max: 100, step: 1 },
        ];
        const cfgDiv = document.getElementById('sb-cfg-tweaks');
        cfgTweaks.forEach(({ path, label, min, max, step }) => {
            const parts = path.split('.');
            const val = CFG[parts[0]][parts[1]];
            const row = document.createElement('div');
            row.style.cssText = 'display:flex;align-items:center;gap:6px;margin-bottom:3px;';
            row.innerHTML = `
                <span style="width:100px;font-size:10px;color:#aaa;">${label}</span>
                <input type="range" min="${min}" max="${max}" step="${step}" value="${val}"
                    data-path="${path}" class="sb-cfg-slider"
                    style="flex:1;accent-color:#44ddaa;height:14px;cursor:pointer;">
                <span class="sb-cfg-val" data-path="${path}" style="width:32px;text-align:right;font-size:10px;">${val}</span>
            `;
            cfgDiv.appendChild(row);
        });
        cfgDiv.querySelectorAll('.sb-cfg-slider').forEach(slider => {
            slider.addEventListener('input', () => {
                const parts = slider.dataset.path.split('.');
                const val = parseFloat(slider.value);
                CFG[parts[0]][parts[1]] = val;
                cfgDiv.querySelector(`.sb-cfg-val[data-path="${slider.dataset.path}"]`).textContent = val;
            });
        });

        // Presets
        const presetsDiv = document.getElementById('sb-presets');
        const presets = [
            { name: 'Shotgun', params: { spread: 230, rate: 50, power: 160, speed: 60 } },
            { name: 'Sniper', params: { spread: 5, rate: 20, power: 255, speed: 255 } },
            { name: 'Gatling', params: { spread: 40, rate: 240, power: 80, speed: 200 } },
            { name: 'Flamer', params: { spread: 180, rate: 200, power: 60, speed: 20 } },
            { name: 'Grenade', params: { spread: 60, rate: 15, power: 255, speed: 40 } },
            { name: 'MAX', params: { spread: 255, rate: 255, power: 255, speed: 255 } },
            { name: 'Reset', params: { spread: 128, rate: 128, power: 128, speed: 128 } },
        ];
        presets.forEach(({ name, params }) => {
            const btn = document.createElement('button');
            btn.textContent = name;
            btn.style.cssText = `
                padding: 3px 8px; font: bold 10px monospace; cursor: pointer;
                background: #333; color: #eee; border: 1px solid #666; border-radius: 4px;
            `;
            btn.addEventListener('click', () => {
                Object.assign(this.player.wpnParams, params);
                // Sync sliders
                rawDiv.querySelectorAll('.sb-slider').forEach(s => {
                    s.value = this.player.wpnParams[s.dataset.param];
                    rawDiv.querySelector(`.sb-val[data-param="${s.dataset.param}"]`).textContent = s.value;
                });
            });
            btn.addEventListener('mouseenter', () => btn.style.background = '#555');
            btn.addEventListener('mouseleave', () => btn.style.background = '#333');
            presetsDiv.appendChild(btn);
        });
    }

    updateSandboxPanel() {
        const statsDiv = document.getElementById('sb-derived-stats');
        if (!statsDiv) return;
        const stats = this.player.getDerivedWeaponStats();
        const maxRange = stats.effectiveSpeed * stats.effectiveLife;
        statsDiv.innerHTML = `
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:2px 12px;">
                <span style="color:#888;">Pellets</span><span style="color:#fff;font-weight:bold;">${stats.pelletCount}</span>
                <span style="color:#888;">Fire Rate</span><span>${stats.fireRate.toFixed(1)} /s</span>
                <span style="color:#888;">Speed</span><span>${stats.effectiveSpeed.toFixed(0)} m/s</span>
                <span style="color:#888;">Life</span><span>${stats.effectiveLife.toFixed(2)}s</span>
                <span style="color:#888;">Max Range</span><span style="color:#ffaa44;">${maxRange.toFixed(0)}m</span>
                <span style="color:#888;">Dmg/Pellet</span><span>${stats.damagePerPellet.toFixed(1)}</span>
                <span style="color:#888;">Total DPS</span><span style="color:#ff6644;font-weight:bold;">${(stats.damagePerPellet * stats.pelletCount * stats.fireRate).toFixed(0)}</span>
                <span style="color:#888;">Spread</span><span>${(stats.spreadAngle * 180 / Math.PI).toFixed(1)}°</span>
                <span style="color:#888;">Exp Radius</span><span>${stats.effectiveRadius.toFixed(1)}</span>
                <span style="color:#888;">Exp Force</span><span>${stats.effectiveForce.toFixed(1)}</span>
                <span style="color:#888;">Heat/Shot</span><span>${stats.heatPerShot.toFixed(2)}</span>
            </div>
        `;
        // Also sync slider positions (in case preset keys 7/8/9 changed them)
        document.querySelectorAll('#sb-raw-params .sb-slider').forEach(s => {
            const key = s.dataset.param;
            if (parseInt(s.value) !== this.player.wpnParams[key]) {
                s.value = this.player.wpnParams[key];
                document.querySelector(`#sb-raw-params .sb-val[data-param="${key}"]`).textContent = this.player.wpnParams[key];
            }
        });
    }

    animate() {
        this.profiler.beginFrame();
        const dt = Math.min(this.clock.getDelta(), 0.05);

        // FPS counter
        this.fpsFrames++;
        this.fpsTime += dt;
        if (this.fpsTime >= 0.5) { this.fpsDisplay = Math.round(this.fpsFrames / this.fpsTime); this.fpsFrames = 0; this.fpsTime = 0; }

        // Dispatch to current state
        try {
            if (this.state && STATES[this.state]) {
                STATES[this.state].update(dt, this);
            }
        } catch (e) { console.error('State update error:', e); }

        // HUD (only visible during playing/drop/weapontest)
        if (this.state === 'playing' || this.state === 'drop' || this.state === 'weapontest') {
            const hpPct = (this.player.health / CFG.player.maxHealth) * 100;
            document.getElementById('health-bar').style.width = hpPct + '%';
            // Ammo display hidden — heat system replaces ammo
            // Weapon parameter sliders
            const sliderColors = { spread: '#5599ff', rate: '#44ddaa', power: '#ff8844', speed: '#cc66ff' };
            const sliderEls = document.querySelectorAll('.wpn-slider');
            sliderEls.forEach(el => {
                const param = el.dataset.param;
                const val = this.player.wpnParams[param];
                const pct = (val / 255 * 100).toFixed(1);
                el.querySelector('.fill').style.height = pct + '%';
                el.querySelector('.fill').style.background = sliderColors[param];
                el.querySelector('.val').textContent = val;
                el.classList.toggle('active', this.player.adjustingParam === param);
            });
            // Heat bar
            const heatPct = (this.player.heat / CFG.heat.maxHeat * 100).toFixed(1);
            const heatBar = document.getElementById('heat-bar');
            heatBar.style.height = heatPct + '%';
            const heatNorm = this.player.heat / CFG.heat.maxHeat;
            if (heatNorm < 0.5) heatBar.style.background = `rgb(${Math.round(heatNorm * 2 * 255)}, ${Math.round(180 + heatNorm * 75)}, 40)`;
            else if (heatNorm < 0.8) heatBar.style.background = `rgb(255, ${Math.round(255 - (heatNorm - 0.5) * 3.33 * 255)}, 20)`;
            else heatBar.style.background = `rgb(255, ${Math.round(60 - (heatNorm - 0.8) * 5 * 60)}, ${Math.round(20 + Math.sin(performance.now() * 0.01) * 20)})`;
            // Kill tracking & streak (skip in weapon sandbox)
            if (this.state !== 'weapontest') {
                const killCount = this.enemies.getKillCount();
                const aliveCount = Math.max(0, ENEMY_COUNT - killCount);
                // Kill streak juice
                if (!this._kcJuice) this._kcJuice = { prevKills: 0, scale: 100, rot: 0, rotDir: 0, lastThousand: 0, lastTenK: 0, streak: 0, maxStreak: 0, idleTime: 99, opacity: 0 };
                const kc = this._kcJuice;
                const newKills = killCount - kc.prevKills;
                if (newKills > 0) {
                    // Spawn pickup drops from kills
                    this.pickupManager.spawnDrops(newKills);
                    kc.streak += newKills;
                    if (kc.streak > kc.maxStreak) kc.maxStreak = kc.streak;
                    kc.idleTime = 0;
                    kc.opacity = 1;
                    kc.scale = Math.min(200, kc.scale + newKills);
                    if (Math.abs(kc.rot) < 0.5) kc.rotDir = Math.random() < 0.5 ? -1 : 1;
                    else kc.rotDir = kc.rot > 0 ? 1 : -1;
                    kc.rot = Math.max(-3, Math.min(3, kc.rot + kc.rotDir * newKills * 0.5));
                    // Milestone dings (based on total kills, not streak)
                    const curThousand = Math.floor(killCount / 1000);
                    const curTenK = Math.floor(killCount / 10000);
                    if (curThousand > kc.lastThousand) this.audio.play('ding100');
                    if (curTenK > kc.lastTenK) this.audio.play('ding1000');
                    kc.lastThousand = curThousand;
                    kc.lastTenK = curTenK;
                }
                kc.prevKills = killCount;
                // Streak idle: fade out after 1s, reset after fully faded
                kc.idleTime += dt;
                if (kc.idleTime > 1) {
                    kc.opacity = Math.max(0, kc.opacity - dt * 5);
                    if (kc.opacity <= 0) kc.streak = 0;
                }
                // Decay scale/rotation
                kc.scale += (100 - kc.scale) * Math.min(1, 3 * dt);
                kc.rot += (0 - kc.rot) * Math.min(1, 4 * dt);
                // Kill streak (center) — full juice
                const kcEl = document.getElementById('kill-count');
                kcEl.textContent = kc.streak > 0 ? kc.streak.toLocaleString() : '';
                kcEl.style.transform = `translateX(-50%) scale(${kc.scale / 100}) rotate(${kc.rot.toFixed(1)}deg)`;
                kcEl.style.opacity = kc.opacity.toFixed(2);
                // Alive count (bottom-right) — 40% juice
                const acScale = 100 + (kc.scale - 100) * 0.4;
                const acRot = kc.rot * 0.4;
                const acEl = document.getElementById('alive-count');
                acEl.textContent = `${aliveCount.toLocaleString()} alive`;
                acEl.style.transform = `scale(${acScale / 100}) rotate(${acRot.toFixed(1)}deg)`;
                const mins = Math.floor(this.roundStats.survivalTime / 60);
                const secs = Math.floor(this.roundStats.survivalTime % 60);
                document.getElementById('timer').textContent =
                    `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
            } else {
                // In weapon sandbox: hide kill/alive counters, show SANDBOX label
                document.getElementById('kill-count').textContent = '';
                document.getElementById('alive-count').textContent = 'WEAPON SANDBOX';
                document.getElementById('timer').textContent = '';
            }
        }

        document.getElementById('info').innerHTML = `FPS: ${this.fpsDisplay}<br>Particles: ${this.particles.POOL_SIZE.toLocaleString()}`;
        this.debug.updateStats(this.fpsDisplay, this.player);

        // Player shadow
        const psY = this.terrain.getHeight(this.player.position.x, this.player.position.z);
        this.playerShadow.position.set(this.player.position.x, psY + 0.12, this.player.position.z);
        this.playerShadow.visible = (this.state === 'playing' || this.state === 'drop' || this.state === 'weapontest');

        // Sky follows camera
        if (this.skyMesh) this.skyMesh.position.copy(this._activeCamera.position);

        // Render with active camera
        this.profiler.mark('renderTime');
        this.renderer.render(this.scene, this._activeCamera);
        this.profiler.markEnd('renderTime');

        // Projectile collision readback (AFTER render to ensure GPU commands are flushed)
        if (this.state === 'playing') {
            this.enemies.checkProjectileHits(this.renderer);
            this.enemies.checkNearbyCount(this.renderer);
            this.enemies.runKillCountReadback(this.renderer);
        }

        this.profiler.endFrame();
        this.perfGraph.draw();
    }
}

// ============================================================
//  TERRAIN EDITOR (accessed via #terrain)
// ============================================================
async function initTerrainEditor() {
    document.body.innerHTML = '';
    document.body.style.cssText = 'margin:0;background:#111;color:#ddd;font-family:"Share Tech Mono",monospace;display:flex;overflow:hidden;height:100vh';

    // --- Panel ---
    const panel = document.createElement('div');
    panel.style.cssText = 'width:340px;min-width:340px;padding:16px;overflow-y:auto;background:rgba(10,10,15,0.95);border-right:1px solid rgba(255,255,255,0.1);display:flex;flex-direction:column;gap:10px';
    const title = document.createElement('div');
    title.style.cssText = 'font-size:18px;font-weight:bold;color:#fff;margin-bottom:4px;letter-spacing:2px';
    title.textContent = 'TERRAIN EDITOR';
    panel.appendChild(title);

    // --- View area (top: 2D heightmap, bottom: 3D orbital) ---
    const viewArea = document.createElement('div');
    viewArea.style.cssText = 'flex:1;display:flex;flex-direction:column;overflow:hidden';

    // --- 2D Heightmap ---
    const canvasWrap = document.createElement('div');
    canvasWrap.style.cssText = 'flex:1;display:flex;align-items:center;justify-content:center;position:relative;min-height:0';
    const canvas = document.createElement('canvas');
    const CSIZE = 512;
    canvas.width = CSIZE; canvas.height = CSIZE;
    canvas.style.cssText = 'image-rendering:pixelated;max-width:100%;max-height:100%;border:1px solid rgba(255,255,255,0.15)';
    canvasWrap.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    const info = document.createElement('div');
    info.style.cssText = 'position:absolute;bottom:8px;left:8px;color:#8af;font-size:11px;letter-spacing:1px;pointer-events:none';
    canvasWrap.appendChild(info);
    viewArea.appendChild(canvasWrap);

    // --- Divider ---
    const divider = document.createElement('div');
    divider.style.cssText = 'height:1px;background:rgba(255,255,255,0.1);flex-shrink:0';
    viewArea.appendChild(divider);

    // --- 3D Orbital View ---
    const view3dWrap = document.createElement('div');
    view3dWrap.style.cssText = 'flex:1;position:relative;min-height:0';
    viewArea.appendChild(view3dWrap);
    const info3d = document.createElement('div');
    info3d.style.cssText = 'position:absolute;top:8px;left:8px;color:#8af;font-size:11px;letter-spacing:1px;pointer-events:none;z-index:1';
    info3d.textContent = 'Drag to orbit · Scroll to zoom';
    view3dWrap.appendChild(info3d);

    document.body.appendChild(panel);
    document.body.appendChild(viewArea);

    // --- Three.js 3D setup ---
    const scene3d = new THREE.Scene();
    scene3d.background = new THREE.Color('#1a1a2e');
    scene3d.fog = new THREE.Fog('#1a1a2e', 800, 2000);
    const cam3d = new THREE.PerspectiveCamera(50, 1, 1, 5000);
    const renderer3d = new THREE.WebGPURenderer({ antialias: true });
    await renderer3d.init();
    renderer3d.domElement.style.cssText = 'width:100%;height:100%;display:block';
    view3dWrap.appendChild(renderer3d.domElement);
    const sun3d = new THREE.DirectionalLight(0xffffff, 1.5);
    sun3d.position.set(1, 2, 0.5).normalize().multiplyScalar(400);
    scene3d.add(sun3d);
    scene3d.add(new THREE.AmbientLight(0x6688aa, 0.5));
    let terrainMesh3d = null;

    // Orbit camera state
    let orbitTheta = 0.4, orbitPhi = 0.8, orbitRadius = 600;
    let orbitTarget = new THREE.Vector3(0, 30, 0);
    let isDragging = false, lastMX = 0, lastMY = 0;

    function updateOrbitCamera() {
        const x = orbitTarget.x + orbitRadius * Math.sin(orbitPhi) * Math.cos(orbitTheta);
        const y = orbitTarget.y + orbitRadius * Math.cos(orbitPhi);
        const z = orbitTarget.z + orbitRadius * Math.sin(orbitPhi) * Math.sin(orbitTheta);
        cam3d.position.set(x, y, z);
        cam3d.lookAt(orbitTarget);
    }

    renderer3d.domElement.addEventListener('mousedown', (e) => { isDragging = true; lastMX = e.clientX; lastMY = e.clientY; });
    window.addEventListener('mouseup', () => isDragging = false);
    window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - lastMX, dy = e.clientY - lastMY;
        lastMX = e.clientX; lastMY = e.clientY;
        orbitTheta += dx * 0.005;
        orbitPhi = Math.max(0.1, Math.min(Math.PI * 0.49, orbitPhi - dy * 0.005));
        updateOrbitCamera();
        renderer3d.render(scene3d, cam3d);
    });
    renderer3d.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();
        orbitRadius = Math.max(50, Math.min(3000, orbitRadius * (1 + e.deltaY * 0.001)));
        updateOrbitCamera();
        renderer3d.render(scene3d, cam3d);
    }, { passive: false });

    // Resize handler
    function resize3d() {
        const rect = view3dWrap.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
            renderer3d.setSize(rect.width, rect.height);
            cam3d.aspect = rect.width / rect.height;
            cam3d.updateProjectionMatrix();
            renderer3d.render(scene3d, cam3d);
        }
    }
    new ResizeObserver(resize3d).observe(view3dWrap);

    // --- Terrain params (local copy) ---
    const T = { ...CFG.terrain };
    const W = { size: CFG.world.size };

    // --- Heightmap color (matches 3D terrain) ---
    function heightColor(h) {
        let r, g, b;
        if (h < 10) { r=0.22; g=0.42; b=0.18; }
        else if (h < 35) { r=0.32; g=0.52; b=0.22; }
        else if (h < 60) { r=0.45; g=0.42; b=0.28; }
        else if (h < 85) { r=0.55; g=0.5; b=0.4; }
        else { r=0.85; g=0.88; b=0.92; }
        return [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];
    }

    // --- Generate & render ---
    function render() {
        const noise = new SimplexNoise(T.seed);
        const { octaves, frequency, amplitude, lacunarity, persistence, offset } = T;
        let rs = T.seed;
        const srng = () => { rs = (rs * 16807 + 1) % 2147483647; return rs / 2147483647; };
        const noiseOffX = srng() * 10000 - 5000, noiseOffZ = srng() * 10000 - 5000;
        const size = W.size, res = CSIZE;
        const img = ctx.createImageData(res, res);
        let hMin = Infinity, hMax = -Infinity, hCenter = 0;
        for (let z = 0; z < res; z++) {
            for (let x = 0; x < res; x++) {
                const wx = (x / res - 0.5) * size, wz = (z / res - 0.5) * size;
                let h = 0, amp = 1, freq = frequency;
                for (let o = 0; o < octaves; o++) { h += noise.noise2D((wx + noiseOffX) * freq, (wz + noiseOffZ) * freq) * amp; amp *= persistence; freq *= lacunarity; }
                const ex = Math.abs(x / res - 0.5) * 2, ez = Math.abs(z / res - 0.5) * 2;
                const edge = Math.max(0, 1 - Math.pow(Math.max(ex, ez), 3) * 1.5);
                h = h * amplitude * edge + offset;
                if (x === Math.floor(res/2) && z === Math.floor(res/2)) hCenter = h;
                if (h < hMin) hMin = h; if (h > hMax) hMax = h;
                const [r, g, b] = heightColor(h);
                const i = (z * res + x) * 4;
                img.data[i] = r; img.data[i+1] = g; img.data[i+2] = b; img.data[i+3] = 255;
            }
        }
        ctx.putImageData(img, 0, 0);
        // Draw spawn crosshair at center
        const cx = Math.floor(res/2), cz = Math.floor(res/2);
        ctx.strokeStyle = '#f44'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(cx-8, cz); ctx.lineTo(cx+8, cz); ctx.moveTo(cx, cz-8); ctx.lineTo(cx, cz+8); ctx.stroke();
        ctx.strokeStyle = 'rgba(255,68,68,0.3)'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(cx, cz, 16, 0, Math.PI*2); ctx.stroke();
        info.textContent = `Height at spawn: ${hCenter.toFixed(1)} | Range: ${hMin.toFixed(1)} to ${hMax.toFixed(1)} | World: ${size}`;

        // --- Update 3D terrain mesh ---
        if (terrainMesh3d) { scene3d.remove(terrainMesh3d); terrainMesh3d.geometry.dispose(); terrainMesh3d.material.dispose(); }
        const TRES = 256;
        const geo = new THREE.BufferGeometry();
        const tr1 = TRES + 1;
        const verts = new Float32Array(tr1 * tr1 * 3);
        const colors = new Float32Array(tr1 * tr1 * 3);
        const indices = [];
        const tScale = size / 1000; // normalise visual size
        for (let tz = 0; tz < tr1; tz++) {
            for (let tx = 0; tx < tr1; tx++) {
                const wx = (tx / TRES - 0.5) * size, wz = (tz / TRES - 0.5) * size;
                let th = 0, tamp = 1, tfreq = frequency;
                for (let o = 0; o < octaves; o++) { th += noise.noise2D((wx + noiseOffX) * tfreq, (wz + noiseOffZ) * tfreq) * tamp; tamp *= persistence; tfreq *= lacunarity; }
                const tex2 = Math.abs(tx / TRES - 0.5) * 2, tez = Math.abs(tz / TRES - 0.5) * 2;
                const tedge = Math.max(0, 1 - Math.pow(Math.max(tex2, tez), 3) * 1.5);
                th = th * amplitude * tedge + offset;
                const i = tz * tr1 + tx;
                const vx = (tx / TRES - 0.5) * 1000, vz = (tz / TRES - 0.5) * 1000;
                verts[i*3] = vx; verts[i*3+1] = th / tScale; verts[i*3+2] = vz;
                const [cr, cg, cb] = heightColor(th);
                colors[i*3] = cr/255; colors[i*3+1] = cg/255; colors[i*3+2] = cb/255;
            }
        }
        for (let tz = 0; tz < TRES; tz++) for (let tx = 0; tx < TRES; tx++) {
            const a = tz*tr1+tx, b = a+1, c = (tz+1)*tr1+tx, d = c+1;
            indices.push(a,c,b,b,c,d);
        }
        geo.setIndex(indices);
        geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geo.computeVertexNormals();
        terrainMesh3d = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ vertexColors: true }));
        scene3d.add(terrainMesh3d);
        // Spawn marker
        const markerGeo = new THREE.SphereGeometry(4, 8, 8);
        const markerMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
        const marker = new THREE.Mesh(markerGeo, markerMat);
        marker.position.set(0, hCenter / tScale + 8, 0);
        terrainMesh3d.add(marker);
        // Update orbit target height
        orbitTarget.y = hCenter / tScale;
        updateOrbitCamera();
        renderer3d.render(scene3d, cam3d);
    }

    // --- Slider builder ---
    function addSlider(label, value, min, max, step, onChange) {
        const row = document.createElement('div');
        row.style.cssText = 'display:flex;align-items:center;gap:8px';
        const lbl = document.createElement('label');
        lbl.style.cssText = 'flex:0 0 100px;color:#aaa;font-size:11px';
        lbl.textContent = label;
        const slider = document.createElement('input');
        slider.type = 'range'; slider.min = min; slider.max = max; slider.step = step; slider.value = value;
        slider.style.cssText = 'flex:1;height:4px;-webkit-appearance:none;background:rgba(255,255,255,0.15);border-radius:2px;outline:none';
        const val = document.createElement('span');
        val.style.cssText = 'flex:0 0 55px;text-align:right;color:#8af;font-size:11px';
        const dec = step < 1 ? (step < 0.01 ? 4 : 2) : 0;
        val.textContent = Number(value).toFixed(dec);
        slider.addEventListener('input', () => {
            val.textContent = Number(slider.value).toFixed(dec);
            onChange(parseFloat(slider.value));
            render();
        });
        row.appendChild(lbl); row.appendChild(slider); row.appendChild(val);
        panel.appendChild(row);
        return slider;
    }

    // --- Section label ---
    function addLabel(text) {
        const l = document.createElement('div');
        l.style.cssText = 'color:#8af;font-size:12px;font-weight:bold;letter-spacing:1px;text-transform:uppercase;margin-top:8px;border-bottom:1px solid rgba(255,255,255,0.08);padding-bottom:4px';
        l.textContent = text;
        panel.appendChild(l);
    }

    // --- Build controls ---
    addLabel('World');
    addSlider('Size', W.size, 1000, 50000, 1000, v => W.size = v);
    addLabel('Terrain');
    addSlider('Seed', T.seed, 1, 9999, 1, v => T.seed = v);
    addSlider('Octaves', T.octaves, 1, 8, 1, v => T.octaves = v);
    addSlider('Frequency', T.frequency, 0.0005, 0.01, 0.0001, v => T.frequency = v);
    addSlider('Amplitude', T.amplitude, 10, 800, 10, v => T.amplitude = v);
    addSlider('Lacunarity', T.lacunarity, 1.0, 4.0, 0.1, v => T.lacunarity = v);
    addSlider('Persistence', T.persistence, 0.1, 0.9, 0.01, v => T.persistence = v);
    addSlider('Offset', T.offset, -50, 100, 1, v => T.offset = v);

    // --- Base64 config ---
    addLabel('Config');
    const configRow = document.createElement('div');
    configRow.style.cssText = 'display:flex;gap:6px;flex-wrap:wrap';
    const configInput = document.createElement('input');
    configInput.type = 'text'; configInput.placeholder = 'Paste base64 config...';
    configInput.style.cssText = 'flex:1;min-width:0;background:rgba(255,255,255,0.08);color:#ddd;border:1px solid rgba(255,255,255,0.15);border-radius:3px;padding:6px 8px;font-family:monospace;font-size:11px';
    const mkBtn = (label, fn) => {
        const b = document.createElement('button');
        b.textContent = label;
        b.style.cssText = 'padding:6px 12px;background:rgba(136,170,255,0.15);color:#8af;border:1px solid rgba(136,170,255,0.3);border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;white-space:nowrap';
        b.addEventListener('click', fn);
        return b;
    };
    const copyBtn = mkBtn('Copy', () => {
        const cfg = { terrain: { ...T }, world: { ...W } };
        const b64 = btoa(JSON.stringify(cfg));
        configInput.value = b64;
        navigator.clipboard.writeText(b64);
        copyBtn.textContent = 'Copied!';
        setTimeout(() => copyBtn.textContent = 'Copy', 1500);
    });
    const loadBtn = mkBtn('Load', () => {
        try {
            const cfg = JSON.parse(atob(configInput.value.trim()));
            if (cfg.terrain) Object.assign(T, cfg.terrain);
            if (cfg.world) Object.assign(W, cfg.world);
            // Refresh sliders — easiest to just rebuild
            location.hash = '#terrain';
            location.reload();
        } catch(e) { configInput.style.borderColor = '#f44'; setTimeout(() => configInput.style.borderColor = 'rgba(255,255,255,0.15)', 1500); }
    });
    // Store config in hash so reload preserves it
    const applyBtn = mkBtn('Apply to Game', () => {
        Object.assign(CFG.terrain, T);
        CFG.world.size = W.size;
        const cfg = { terrain: { ...T }, world: { ...W } };
        const b64 = btoa(JSON.stringify(cfg));
        configInput.value = b64;
        navigator.clipboard.writeText(b64);
        alert('Config copied & applied to CFG. Remove #terrain from URL and reload to play with these settings.');
    });
    configRow.appendChild(configInput);
    configRow.appendChild(copyBtn);
    configRow.appendChild(loadBtn);
    panel.appendChild(configRow);
    const applyRow = document.createElement('div');
    applyRow.style.cssText = 'display:flex;gap:6px';
    applyRow.appendChild(applyBtn);
    const backBtn = mkBtn('← Back to Game', () => { location.hash = ''; location.reload(); });
    applyRow.appendChild(backBtn);
    panel.appendChild(applyRow);

    // --- Hint ---
    const hint = document.createElement('div');
    hint.style.cssText = 'color:#555;font-size:10px;margin-top:auto;padding-top:12px;line-height:1.6';
    hint.textContent = 'Red crosshair = player spawn (0,0). Copy the base64 config and set it in the game source, or paste into the TERRAIN_CONFIG constant.';
    panel.appendChild(hint);

    render();
}

// ============================================================
//  SYSTEM CAPABILITY CHECK
// ============================================================
async function checkSystemCapabilities() {
    const result = {
        webgpu: false,
        adapterName: 'Unknown GPU',
        verdict: 'unsupported',
        benchmarkMs: -1,
        estimatedMaxEnemies: 0,
        message: 'WebGPU is not available in this browser.',
        memoryHint: 0,
    };

    // 1. Check WebGPU availability
    if (!navigator.gpu) {
        return result;
    }

    // 2. Request adapter
    let adapter;
    try {
        adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
    } catch (e) {
        result.message = 'Failed to get GPU adapter: ' + e.message;
        return result;
    }
    if (!adapter) {
        result.message = 'No suitable GPU adapter found.';
        return result;
    }

    // 3. Inspect adapter info + limits
    try {
        const info = adapter.info || {};
        const vendor = info.vendor || '';
        const arch = info.architecture || '';
        const desc = info.description || info.device || '';
        result.adapterName = [vendor, arch, desc].filter(Boolean).join(' ') || 'GPU detected';
    } catch (e) {
        result.adapterName = 'GPU detected';
    }

    const limits = adapter.limits;
    const maxStorageBuf = limits.maxStorageBufferBindingSize || 0;
    const maxBufSize = limits.maxBufferSize || 0;
    // Our enemy system needs: 1M enemies × 48 bytes = ~48MB storage buffer
    const neededStorageBytes = ENEMY_COUNT * 48;
    if (maxStorageBuf < neededStorageBytes) {
        result.webgpu = true;
        result.verdict = 'caution';
        result.message = `GPU storage buffer limit (${(maxStorageBuf / 1048576).toFixed(0)}MB) is tight for ${fmtEnemyCount(ENEMY_COUNT)} enemies (need ~${(neededStorageBytes / 1048576).toFixed(0)}MB). May need to reduce enemy count.`;
    }

    // 4. Request a test device with our required limits
    let testDevice;
    try {
        testDevice = await adapter.requestDevice({
            requiredLimits: {
                maxStorageBufferBindingSize: Math.min(neededStorageBytes + 16777216, maxStorageBuf),
                maxBufferSize: Math.min(neededStorageBytes + 16777216, maxBufSize),
                maxComputeWorkgroupsPerDimension: Math.min(65535, limits.maxComputeWorkgroupsPerDimension || 65535),
            }
        });
    } catch (e) {
        result.webgpu = true;
        result.verdict = 'caution';
        result.message = 'Could not allocate GPU device with required limits. Performance may be limited.';
        return result;
    }

    result.webgpu = true;

    // 5. Mini compute benchmark — write 65536 values, measure throughput
    let benchMs = 999;
    try {
        const N = 65536;
        const bufferSize = N * 4;
        const storageBuffer = testDevice.createBuffer({
            size: bufferSize,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
        });
        const readBuffer = testDevice.createBuffer({
            size: bufferSize,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
        });
        const shaderModule = testDevice.createShaderModule({
            code: `
                @group(0) @binding(0) var<storage, read_write> data: array<f32>;
                @compute @workgroup_size(64)
                fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
                    let i = gid.x;
                    if (i < ${N}u) {
                        // Do some math to actually exercise the GPU
                        var v = f32(i) * 0.001;
                        for (var j = 0u; j < 100u; j = j + 1u) {
                            v = sin(v) * cos(v * 0.7) + 0.5;
                        }
                        data[i] = v;
                    }
                }
            `
        });
        const pipeline = testDevice.createComputePipeline({
            layout: 'auto',
            compute: { module: shaderModule, entryPoint: 'main' }
        });
        const bindGroup = testDevice.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [{ binding: 0, resource: { buffer: storageBuffer } }]
        });

        // Warm-up dispatch
        const warmCmd = testDevice.createCommandEncoder();
        const warmPass = warmCmd.beginComputePass();
        warmPass.setPipeline(pipeline);
        warmPass.setBindGroup(0, bindGroup);
        warmPass.dispatchWorkgroups(Math.ceil(N / 64));
        warmPass.end();
        warmCmd.copyBufferToBuffer(storageBuffer, 0, readBuffer, 0, bufferSize);
        testDevice.queue.submit([warmCmd.finish()]);
        await readBuffer.mapAsync(GPUMapMode.READ);
        readBuffer.unmap();

        // Timed run: 3 dispatches
        const t0 = performance.now();
        for (let run = 0; run < 3; run++) {
            const enc = testDevice.createCommandEncoder();
            const pass = enc.beginComputePass();
            pass.setPipeline(pipeline);
            pass.setBindGroup(0, bindGroup);
            pass.dispatchWorkgroups(Math.ceil(N / 64));
            pass.end();
            enc.copyBufferToBuffer(storageBuffer, 0, readBuffer, 0, bufferSize);
            testDevice.queue.submit([enc.finish()]);
            await readBuffer.mapAsync(GPUMapMode.READ);
            readBuffer.unmap();
        }
        benchMs = (performance.now() - t0) / 3;

        storageBuffer.destroy();
        readBuffer.destroy();
    } catch (e) {
        console.warn('Benchmark failed:', e);
        benchMs = 999;
    }

    // 6. Destroy test device
    testDevice.destroy();

    // 7. Memory hint
    result.memoryHint = navigator.deviceMemory || 0;
    result.benchmarkMs = benchMs;

    // 8. Extrapolate: our benchmark does 65k elements × 100 iterations each.
    // The real game does 1M enemies with ~15 compute passes of varying complexity.
    // Rough estimate: if 65k×100iter takes Xms, then 1M×15 passes ≈ X × (1M/65k) × (15/100) ≈ X × 2.3
    const estimatedFrameGpuMs = benchMs * (ENEMY_COUNT / 65536) * (15 / 100);
    result.estimatedMaxEnemies = Math.round(ENEMY_COUNT * (16.6 / Math.max(0.1, estimatedFrameGpuMs)));

    // 9. Verdict
    if (benchMs >= 999) {
        result.verdict = 'caution';
        result.message = 'GPU benchmark could not complete. Performance is uncertain.';
    } else if (estimatedFrameGpuMs < 10) {
        result.verdict = 'good';
        result.message = `Estimated GPU frame time: ${estimatedFrameGpuMs.toFixed(1)}ms — your system looks great!`;
    } else if (estimatedFrameGpuMs < 25) {
        result.verdict = 'caution';
        result.message = `Estimated GPU frame time: ${estimatedFrameGpuMs.toFixed(1)}ms — may run slowly. Close other tabs and GPU-heavy apps for best results.`;
    } else {
        result.verdict = 'caution';
        result.message = `Estimated GPU frame time: ${estimatedFrameGpuMs.toFixed(1)}ms — performance will likely be limited. Consider a device with a stronger GPU.`;
    }

    return result;
}

function showCapabilityResult(caps) {
    const container = document.getElementById('capability-result');
    const gpuEl = document.getElementById('cap-gpu-name');
    const verdictEl = document.getElementById('cap-verdict');
    const messageEl = document.getElementById('cap-message');
    const btnEl = document.getElementById('cap-continue-btn');

    container.style.display = 'block';
    gpuEl.textContent = caps.adapterName;
    verdictEl.className = 'cap-verdict ' + caps.verdict;

    if (caps.verdict === 'good') {
        verdictEl.textContent = 'SYSTEM OK';
    } else if (caps.verdict === 'caution') {
        verdictEl.textContent = 'CAUTION';
    } else {
        verdictEl.textContent = 'NOT SUPPORTED';
    }
    messageEl.textContent = caps.message;
    if (caps.memoryHint) {
        messageEl.textContent += ` (${caps.memoryHint}GB RAM detected)`;
    }

    return new Promise(resolve => {
        if (caps.verdict === 'good') {
            // Auto-continue after 1.5s
            setTimeout(resolve, 1500);
        } else if (caps.verdict === 'caution') {
            // Show continue button, auto-continue after 4s
            btnEl.style.display = 'inline-block';
            btnEl.onclick = resolve;
            setTimeout(resolve, 4000);
        } else {
            // Unsupported — show error, no auto-continue
            const bar = document.getElementById('load-progress');
            if (bar) { bar.style.background = '#f44'; bar.style.width = '100%'; }
            const statusEl = document.getElementById('load-status-text');
            if (statusEl) { statusEl.style.color = '#f44'; statusEl.textContent = 'Cannot start game'; }
            // Never resolve — halts loading
        }
    });
}

// ============================================================
//  BOOT
// ============================================================
async function main() {
    // Terrain editor mode
    if (location.hash === '#terrain') {
        await initTerrainEditor();
        return;
    }

    // Pre-flight system check
    updateLoadProgress(2, 'Checking system capabilities...');
    const caps = await checkSystemCapabilities();

    if (caps.verdict === 'unsupported') {
        await showCapabilityResult(caps);
        return; // Halt — promise never resolves for unsupported
    }

    // Show result (auto-continues for good, waits for caution)
    await showCapabilityResult(caps);

    // Store for later reference (debug overlay, future metrics)
    window.systemCapabilities = caps;

    // Hide capability result before heavy init
    document.getElementById('capability-result').style.display = 'none';

    try {
        const game = new Game();
        await game.init();
    } catch (e) {
        console.error('Init failed:', e);
        const statusEl = document.getElementById('load-status-text');
        if (statusEl) {
            statusEl.style.color = '#f44';
            statusEl.textContent = 'WebGPU init failed: ' + e.message;
            const bar = document.getElementById('load-progress');
            if (bar) { bar.style.background = '#f44'; bar.style.width = '100%'; }
            const p = document.createElement('p');
            p.style.cssText = 'color:#555;font-size:11px;margin-top:12px;max-width:400px;text-align:center;letter-spacing:0.5px;line-height:1.6';
            p.textContent = 'WebGPU requires a modern browser (Chrome 113+, Firefox 141+, Safari 26+). Check that hardware acceleration is enabled.';
            statusEl.parentNode.appendChild(p);
        }
    }
}
main();
</script>
</body>
</html>
